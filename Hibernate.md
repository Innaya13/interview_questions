# Hibernate

+ [Что такое ORM?](#что-такое-orm)
+ [Что такое JPA?](#что-такое-jpa)
+ [Что появилось раньше JPA или Hibernate?](#что-появилось-раньше-jpa-или-hibernate)
+ [Что такое Hibernate?](#что-такое-hibernate)
+ [Какие ключевые интерфейсы использует Hibernate?](#какие-ключевые-интерфейсы-использует-hibernate)
+ [PROXY: что это такое, для чего и как применяется в Hibernate.](#proxy-что-это-такое-для-чего-и-как-применяется-в-hibernate)
+ [Расскажи про Hibernate кэширование (уровни кэша и что под капотом)](#расскажи-про-hibernate-кэширование-уровни-кэша-и-что-под-капотом)
+ [Как работать с кэшем второго уровня?](#как-работать-с-кэшем-второго-уровня)
+ [Что такое Persistence Context?](#что-такое-persistence-context)
+ [Что такое EntityManager?](#что-такое-entitymanager)
+ [Методы интерфейса EntityManager](#методы-интерфейса-entitymanager)
+ [Какие функции он выполняет?](#какие-функции-он-выполняет)
+ [Каким условиям должен удовлетворять класс чтобы являться Entity?](#каким-условиям-должен-удовлетворять-класс-чтобы-являться-entity)
+ [Расскажи про жизненный цикл сущности Entity, перечисли четыре статуса ЖЦ Entity объекта (Entity Instance’s Life Cycle).](#расскажи-про-жизненный-цикл-сущности-entity-перечисли-четыре-статуса-жц-entity-объекта-entity-instances-life-cycle)
+ [Как влияют операции persist, remove, merge, refresh, detach на Entity объекты каждого из четырех статусов?](#как-влияют-операции-persist-remove-merge-refresh-detach-на-entity-объекты-каждого-из-четырех-статусов)
+ [Может ли абстрактный класс быть Entity?](#может-ли-абстрактный-класс-быть-entity)
+ [Может ли Entity класс наследоваться от не Entity классов (non-entity classes)?](#может-ли-entity-класс-наследоваться-от-не-entity-классов-non-entity-classes)
+ [Может ли Entity класс наследоваться от других Entity классов?](#может-ли-entity-класс-наследоваться-от-других-entity-классов)
+ [Может ли не Entity класс наследоваться от Entity класса? ](#может-ли-не-entity-класс-наследоваться-от-entity-класса)
+ [Что такое встраиваемый (Embeddable) класс?](#что-такое-встраиваемый-embeddable-класс)
+ [Какие требования JPA устанавливает к встраиваемым (Embeddable) классам?](#какие-требования-jpa-предъявляет-к-встраиваемым-embeddable-классам)
+ [Для чего нужны аннотации @Embedded и @Embeddable?](#для-чего-нужны-аннотации-embedded-и-embeddable)
+ [Что такое Mapped Superclass?](#что-такое-mapped-superclass)
+ [Какие стратегии маппинга иерархии наследования (Inheritance Mapping Strategies) описаны в JPA?](#какие-три-стратегии-маппинга-при-наследовании-сущностей-entity-inheritance-mapping-strategies-описаны-в-jpa)
+ [Как мапятся Enum -ы?](#как-мапятся-enumы)
+ [Как мапятся даты (до Java 8 и старше)?](#как-мапятся-даты-до-java-8-и-старше)
+ [Как Hibernate работает с разными типами?](#как-hibernate-работает-с-разными-типами)
+ [Как сохранять в базе данных коллекции базовых типов?](#как-сохранять-в-базе-данных-коллекции-базовых-типов)
+ [Какие есть виды связей (маппинг ассоциаций)?](#какие-есть-виды-связей-маппинг-ассоциаций)
+ [Что такое владелец связи?](#что-такое-владелец-связи)
+ [Что такое каскады?](#что-такое-каскады)
+ [Какие два типа fetch стратегии в JPA вы знаете?](#какие-два-типа-fetch-стратегии-в-jpa-вы-знаете)
+ [Для чего нужна аннотация Basic?](#для-чего-нужна-аннотация-basic)
+ [Для чего нужна аннотация Column?](#для-чего-нужна-аннотация-column)
+ [Для чего нужна аннотация Access?](#для-чего-нужна-аннотация-access)
+ [Для чего нужна аннотация Cacheable?](#для-чего-нужна-аннотация-cacheable)
+ [Каких провайдеров кэша второго уровня знаешь?](#каких-провайдеров-кэша-второго-уровня-знаешь)
+ [Как смапить составной ключ?](#как-смапить-составной-ключ)
+ [Для чего нужна аннотация ID?](#для-чего-нужна-аннотация-id)
+ [Какие @GeneratedValue вы знаете?](#какие-generatedvalue-вы-знаете)
+ [Расскажите про аннотации @JoinColumn и @JoinTable? Где и для чего они используются?](#расскажите-про-аннотации-joincolumn-и-jointable-где-и-для-чего-они-используются)
+ [Для чего нужны аннотации @OrderBy и @OrderColumn, чем они отличаются?](#для-чего-нужны-аннотации-orderrby-и-ordercolumn-чем-они-отличаются)
+ [Для чего нужна аннотация Transient?](#для-чего-нужна-аннотация-transient)
+ [Какие шесть видов блокировок (lock) описаны в спецификации JPA (или какие есть значения у enum LockModeType в JPA)?](#какие-шесть-видов-блокировок-lock-описаны-в-спецификации-jpa-или-какие-есть-значения-у-enum-lockmodetype-в-jpa)
+ [Что такое JPQL/HQL и чем он отличается от SQL?](#что-такое-jpqlhql-и-чем-он-отличается-от-sql)
+ [Что означает полиморфизм (polymorphism) в запросах JPQL (Java Persistence query language) и как его «выключить»?](#что-означает-полиморфизм-polymorphism-в-запросах-jpql-java-persistence-query-language-и-как-его-выключить)
+ [Что такое Criteria API и для чего он используется?](#что-такое-criteria-api-и-для-чего-он-используется)
+ [В чем разница в требованиях к Entity в Hibernate, от требований к Entity, указанных в спецификации JPA?](#в-чем-разница-в-требованиях-к-entity-в-hibernate-от-требований-к-entity-указанных-в-спецификации-jpa)
+ [Расскажите про проблему N+1 Select и путях ее решения.](#расскажите-про-проблему-n1-select-и-путях-ее-решения)
+ [Что такое EntityGraph? Как и для чего их использовать?](#что-такое-entitygraph-как-и-для-чего-их-использовать)
+ [Можно ли в JDBC реализовать кэш?](#можно-ли-в-jdbc-реализовать-кэш)
+ [Какие интерфейсы, классы есть в JDBC?](#какие-интерфейсы-классы-есть-в-jdbc)
+ [Если установить стратегию генерации ключа AUTO, то какую из типов стратеги Hibernate САМ никогда не выберет и почему?](#если-установить-стратегию-генерации-ключа-auto-то-какую-из-типов-стратеги-hibernate-сам-никогда-не-выберет-и-почему)



## Что такое ORM?
 
Object Relational Mapping – способ представления Java Объекта в базе данных, объектно-реляционное сопоставление, облегчает работу разработчика. 
 
ORM преобразует объект в строку в таблице и обратно, используя JDBC API для взаимодействия с базой данных. 

<img width="639" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/598f367f-1b90-4190-84c1-ae9d65683eef">

JDBC - Java DataBase Connectivity — API для работы с реляционными (зависимыми) БД. Платформенно независимый промышленный стандарт взаимодействия Java-приложений с различными СУБД, реализованный в виде пакета java.sql, входящего в состав Java SE. Предоставляет методы для получения и обновления данных. Не зависит от конкретного типа базы. Библиотека, которая входит в стандартную библиотеу, содержит: набор классов и интерфейсов для работы с БД (для нас разработчиков api) + интерфейсы баз данных. 

JDBC реализует механизмы работы подключений к базе данных, создания запросов и обработки результатов.

<img width="652" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/f71a3c47-0712-418d-ab97-a918faacd439">

Наш код –> JDBC –> драйвера разработчиков БД –> БД.

JDBC has 3 entities:

+ Connection (класс). Объект которого отвечает за соединение с базой и режим работы с ней (лекция 3.1.4)
+ Statement (объект для оператора JDBC) используется для отправки SQL-оператора на сервер баз данных. Объект для оператора связан с объектом Connection и является объектом, обрабатывающим взаимодействие между приложением и сервером баз данных.
+ ResultSet. Объект с результатом запроса, который вернула база. Внутри него таблица.

Данные в таблицах (реляционные БД) связаны логикой предметной области.

Одна строка/запись = один объект.

Характеристики (атрибуты) объекта описаны в полях класса и размещаются в колонках таблиц.

<img width="817" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/f9b2b9ea-c718-4b3d-8262-1bc060ade7ef">

+ Запись – инфо об одном объекте.
+ Поле – это атрибут, х-ка объекта.
+ Имя поля – название колонки.

<img width="1143" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/ef21c152-3349-43ef-8c98-8c0c4db20dc7">

<img width="1146" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/ca7adfb9-b379-43a7-acab-7bf6eb1ff45c">

Если нужно создать связь между Объектом и реляционной сущностью, поможет Объектно-Реляционное-Связывание или же – ORM (Object Relational Mapping). 

<img width="1139" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/624fde61-9212-4c17-8f26-103e3fb4f805">

<img width="1145" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/32033001-4072-4409-91c8-707dd89651a8">

[к оглавлению](#hibernate)

## Что такое JPA?

JPA – это стандартная спецификация, описывающая систему управления сохранением Java объектов в базу данных.

Java Persistence API - это спецификация (стандарт, технология), обеспечивающая объектно-реляционное отображение простых JAVA-объектов (Plain Old Java Object - POJO) и предоставляющая  универсальный API для сохранения, получения и управления такими объектами.

JPA (Java Persistence API) описывает правила, а Hibernate использует их. 

Это спецификация (стандарт, технология), обеспечивающая объектно-реляционное отображение простых JAVA-объектов (Plain Old Java Object - POJO) и предоставляющая универсальный API для сохранения, получения и управления такими объектами.  

Сам JPA не умеет ни сохранять, ни управлять объектами, JPA только определяет правила игры: как должен действовать каждый провайдер (Hibernate, EclipseLink, OJB, Torque и т.д.), реализующий стандарт JPA.  

Также JPA определяет правила, как должны описываться метаданные отображения и как должны работать провайдеры. 

<img width="1099" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/6bb34a9f-3063-44e4-b8da-f2fb5aa46e04">

Каждый провайдер обязан реализовывать всё из JPA, определяя стандартное получение, сохранение и управление объектами. Помимо этого, провайдеры могут добавлять свои личные классы и интерфейсы, расширяя функционал JPA.

JPA: 
+ API в пакете javax.persistance (набор интерфейсов EntityManager, Query,EntityTransaction),
+ JPQL - объектный язык запросов (запросы выполняются к объектам)
+ Metadata (аннотации или xml)
 
JAVA-код, написанный только с использованием интерфейсов и классов JPA, позволяет разработчику гибко менять одного провайдера на другого. Например, если приложение использует Hibernate как провайдера, то ничего не меняя в коде можно поменять провайдера на любой другой. Но, если мы в коде использовали интерфейсы, классы или аннотации, например, из Hibernate, то поменяв провайдера на EclipseLink, эти интерфейсы, классы или аннотации уже работать не будут. 

[к оглавлению](#hibernate)

## Что появилось раньше JPA или Hibernate?

На основе Hibernate (2001) появилась спецификация JPA (2006). Хибер раньше.

[к оглавлению](#hibernate)

## Что такое Hibernate?

Hibernate - это провайдер, реализующий спецификацию JPA. Hibernate полностью реализует JPA плюс добавляет функционал в виде своих классов и интерфейсов, расширяя свои возможности по работе с сущностями и БД.

Hibernate – это самая популярная спецификация JPA и является одним из самых востребованных ORM фреймворков для Java. 

Главная цель – создание объектного слоя между кодом    и БД, чтобы работать с таблицами, как с объектами. 

<img width="377" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/5b2a344b-959c-4fd9-807b-26690466dea0">

Hibernate устраняет многословный спагетти код (повторяющийся), который постоянно преследует разработчика при работе с JDBC. Скрывает от разработчика множество кода, необходимого для управления ресурсами и позволяет сосредоточиться на бизнес логике.

Hibernate поддерживает XML так же, как и JPA аннотации, что позволяет сделать реализацию кода независимой. 

Hibernate предоставляет собственный мощный язык запросов (HQL), который похож на SQL. Стоит отметить, что HQL полностью объектно-ориентирован и понимает такие принципы, как наследование, полиморфизм и ассоциации (связи). 

Hibernate — широко распространенный open source проект. Благодаря этому доступны тысячи открытых статей, примеров, а также документации по использованию фреймворка. 

Hibernate легко интегрируется с другими Java EE фреймворками, например, Spring Framework поддерживает встроенную интеграцию с Hibernate. Hibernate поддерживает ленивую инициализацию используя PROXY объекты и выполняет запросы к базе данных только по необходимости. 

Hibernate поддерживает разные уровни кэширования, а следовательно, может повысить производительность. 

Важно, что Hibernate может использовать чистый SQL, а значит поддерживает возможность оптимизации запросов и работы с любым сторонним вендором БД и его фичами. 

Hibernate неявно использует управление транзакциями (большинство запросов нельзя выполнить вне транзакций). 

Hibernate использует HibernateException (unchecked), а значит нет необходимости проверять их в коде каждый раз. 

Hibernate поддерживает все основные СУБД: MySQL, Oracle, PostgreSQL, Microsoft SQL Server Database, HSQL, DB2. 

-----------
Hibernate - это фреймворк для объектно-реляционного отображения (ORM), который предоставляет механизм для сохранения, извлечения и обработки данных из баз данных в объектно-ориентированном стиле. 

С помощью Hibernate можно описывать связи между объектами в Java-приложениях и таблицами в базе данных, при этом Hibernate берет на себя работу по выполнению соответствующих запросов к базе данных. Это позволяет программисту сосредоточиться на программировании логики приложения, не задумываясь о деталях взаимодействия с базой данных. 

Hibernate также позволяет работать с различными базами данных, не изменяя код приложения. Он поддерживает множество баз данных, включая MySQL, Oracle, PostgreSQL и Microsoft SQL Server. С помощью Hibernate можно создавать объектно-ориентированный слой доступа к данным и использовать его для работы с базой данных в рамках Java-приложения.

[к оглавлению](#hibernate)

## Какие ключевые интерфейсы использует Hibernate?

Hibernate использует несколько ключевых интерфейсов, которые являются основой его функциональности:

1. SessionFactory - это интерфейс, который представляет фабрику сессий Hibernate, которые используются для выполнения операций с базой данных. SessionFactory создается один раз при запуске приложения и может использоваться для создания множества сессий.

2. Session - это интерфейс для работы с Hibernate сессией. Сессия используется для управления состоянием объектов, выполнения запросов к базе данных и сохранения изменений в базе данных.

3. Query - это интерфейс, который используется для выполнения запросов на языке HQL (Hibernate Query Language). Query может использоваться для выполнения выборки, удаления и обновления объектов.

4. Criteria - это интерфейс для создания запросов к базе данных на основе критериев. Criteria позволяет строить сложные запросы в объектно-ориентированном стиле.

5. Transaction - это интерфейс, который используется для управления транзакциями в Hibernate. С помощью Transaction можно начать новую транзакцию, зафиксировать ее или откатить.

---------

+ **Session**  	Интерфейс Session является основным инструментом, используемым для связи с Hibernate.  Он предоставляет API, позволяющий создавать, читать, обновлять и удалять постоянные объекты. Сессия имеет простой жизненный цикл. Открываем, выполняем какие-то операции, а потом закрываем. 
 
+ **SessionFactory** 	SessionFactory — это интерфейс, который присутствует в org. hibernate, используется для создания объекта сеанса. Он неизменяем и поточно-безопасен по своей природе. 
 
+ **Configuration** 	Интерфейс используется для настройки и начальной загрузки спящего режима. Экземпляр этого интерфейса используется приложением для указания местоположения документов сопоставления, относящихся к спящему режиму. 
	 
+ **Transaction** 	Определяет единицу работы (транзакцию). Он поддерживает абстракцию от реализации транзакции (JTA, JDBC). Транзакция связана с сеансом и создается путем вызова сеанса. 
 
+ **Query and Criteria** 	Это объектно-ориентированное представление Hibernate Query. Объект Query можно получить, вызвав интерфейс сеанса метода createQuery(). Интерфейс запроса предоставляет множество методов.  
 
Интерфейс Criteria предоставляет методы для применения критериев, таких как получение всех записей таблицы, зарплата которых превышает 50000 и т. д. 

-------------

Hibernate - это библиотека для Java, предоставляющая функциональность объектно-реляционного отображения (ORM) для упрощения взаимодействия с базами данных. Она позволяет избежать непосредственного написания SQL-запросов, обеспечивая тем самым более высокий уровень абстракции и гибкости. В Hibernate существует несколько ключевых интерфейсов, которые определяют его архитектуру:

1. Session Interface (Интерфейс сессии)
Интерфейс Session является основным интерфейсом для взаимодействия с базой данных. Это центральное место, где происходит управление сохранением, удалением и извлечением объектов. Session предоставляет API для выполнения CRUD (Create, Read, Update, Delete) операций над объектами, представляющими записи базы данных. Сессия также отвечает за управление транзакциями и кэшированием первого уровня.

2. SessionFactory Interface (Интерфейс фабрики сессий)
SessionFactory предназначен для создания новых сессий. Это потокобезопасный объект и является синглтоном для приложения. В процессе инициализации SessionFactory настраивает Hibernate на основе конфигурационных файлов или настроек, а также определений сущностей. Каждое соединение с базой данных обслуживается новым объектом Session, созданным с помощью SessionFactory.

3. Configuration Interface (Интерфейс конфигурации)
Интерфейс Configuration предоставляет способы настройки Hibernate. Он отвечает за чтение и обработку файлов конфигурации, таких как hibernate.cfg.xml или аннотаций Java. Configuration управляет свойствами конфигурации и взаимосвязьми. После конфигурации объект Configuration используется для создания объекта SessionFactory.

4. Transaction Interface (Интерфейс транзакции)
Интерфейс Transaction используется для управления транзакциями базы данных. Он позволяет выполнять операции commit (подтверждение), rollback (откат) и задействовать уровни изоляции транзакций. В Java-приложениях рекомендуется использовать интерфейс Transaction вместо стандартного API для работы с транзакциями в JDBC.

5. Query и Criteria Interfaces (Интерфейсы запросов и критериев)
Query и Criteria представляют собой два различных подхода к созданию запросов и получению объектов из базы данных.

Query Interface (Интерфейс запросов) используется для создания объектно-ориентированных или HQL (Hibernate Query Language) запросов к базе данных. HQL предоставляет средства для написания запросов с использованием классов и свойств Java, а не непосредственно таблиц и столбцов базы данных.

Criteria Interface (Интерфейс критериев) предоставляет API для создания запросов с использованием программного кода, а не текстовых запросов. Он позволяет создавать гибкие и динамические запросы, особенно полезные, когда критерии запроса могут меняться во время выполнения программы. Criteria поддерживает создание сложных запросов, включая разбиение на страницы, сортировку, ограничения, объединение, и использование агрегатных функций.

----------

Hibernate - это популярный ORM-фреймворк (Object-Relational Mapping) для Java, предоставляющий удобный способ работы с базами данных. Основные интерфейсы Hibernate, которые используются для фасетирования и управления данными, включают следующие:

1. Session interface (Интерфейс сессии):

Интерфейс сессии является основным интерфейсом для взаимодействия с базой данных. Он представляет одиночное соединение с базой данных и предоставляет методы для операций вставки, выборки, обновления и удаления.

Пример:

```java
Session session = sessionFactory.openSession();
session.beginTransaction();

User user = new User("John", "Doe");
session.save(user); // сохранение объекта user в базу данных

session.getTransaction().commit();
session.close();
```

2. SessionFactory interface (Интерфейс фабрики сессий):

Интерфейс фабрики сессий используется для создания экземпляров сессий; он читает конфигурационное hbm.xml-файл или файл метаданных аннотаций и инстанцирует сессии.

Пример:

```java
Configuration configuration = new Configuration().configure();
ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder()
        .applySettings(configuration.getProperties()).build();
SessionFactory sessionFactory = configuration.buildSessionFactory(serviceRegistry);
```

3. Configuration interface (Интерфейс конфигурации):

Интерфейс конфигурации используется для настройки Hibernate. Он позволяет задать параметры конфигурации, такие как диалект базы данных, настройки соединения и мапинги сущностей.

Пример:

```java
Configuration configuration = new Configuration();
configuration.setProperty("hibernate.dialect", "org.hibernate.dialect.MySQLDialect");
configuration.setProperty("hibernate.connection.url", "jdbc:mysql://localhost/mydatabase");
configuration.setProperty("hibernate.connection.username", "user");
configuration.setProperty("hibernate.connection.password", "password");
configuration.addAnnotatedClass(User.class);
```

4. Transaction interface (Интерфейс транзакции):

Интерфейс транзакции контролирует транзакции базы данных. Он позволяет начать транзакцию, откатить её и подтвердить изменения.

Пример:

```java
Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();

try {
    User user = new User("John", "Doe");
    session.save(user);
    tx.commit(); // подтверждение транзакции
} catch (Exception e) {
    tx.rollback(); // откат транзакции
} finally {
    session.close();
}
```

5. Query and Criteria interfaces (Интерфейсы запросов и критериев):

Интерфейс Query предоставляет функциональность для построения HQL-запросов (Hibernate Query Language), а интерфейс Criteria используется для динамического создания запросов на основе критериев.

Пример запроса (Query):

```java
Session session = sessionFactory.openSession();
String hql = "FROM User WHERE lastName = :lastName";
Query query = session.createQuery(hql);
query.setParameter("lastName", "Doe");
List<User> users = query.list();
```

Пример критерия (Criteria):

```java
Session session = sessionFactory.openSession();
Criteria criteria = session.createCriteria(User.class);
criteria.add(Restrictions.eq("lastName", "Doe"));
List<User> users = criteria.list();
```
 
[к оглавлению](#hibernate)

## PROXY: что это такое, для чего и как применяется в Hibernate

Proxy используется для замены реальной сущности POJO (Plain Old Java Object). 

<img width="1129" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/2a83fe13-dbfd-49f4-b74c-369fcbb18cc9">

Паттерн Заместитель (Proxy) предоставляет объект-заместитель, который управляет доступом к другому объекту. То есть создается объект-суррогат, который может выступать в роли другого объекта и замещать его (перехватывать все вызовы).  
 
В Spring прокси просто оборачивает bean, он может добавить логику до и после выполнения методов. 

<img width="1126" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/8459facb-4147-478c-975f-f64400048e4e">

Hibernate использует объекты Proxy для объектов, чтобы разрешить отложенную LAZY загрузку:   

<img width="640" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/c8d39d3e-5673-4d13-93b0-2d582b475d0b">

Зачем нужна ленивая загрузка? Вы загружаете большую часть своей базы данных, просто загружая один объект Company. Это приведет к проблемам с памятью. Поэтому Hibernate загружает только первый объект и заменяет наборы других объектов прокси. Если вы обращаетесь к прокси-серверу, Hibernate использует текущую сессию для инициализации прокси-сервера и загрузки записей из базы данных. 

PROXY cоздаётся динамически во время компиляции. При доступе к основным свойствам он просто делегирует вызов исходной сущности. 

<img width="1119" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/c9762ace-8379-494b-9f99-b40b23b024d8">

Hibernate может использовать разные библиотеки для создания PROXY: 
+ ByteBuddy (используется в примере выше) 
+ Javaassist (заменил cglib, но все еще есть в исходниках) 
+ Сglib (использовался в первых версиях Hibernate) 

Каждый List, Set, Map тип в классе сущностей замещен PersistentList, PersistentSet, PersistentMap. Эти классы отвечают за перехват вызова неинициализированной коллекции. 

Прокси не выдает никаких операторов SQL. Он просто запускает InitializeCollectionEvent, который обрабатывается связанным прослушивателем, который знает, какой запрос инициализации выпустить (зависит от настроенного плана выборки).  
Proxy объект получаем через метод session.load(), если вызываем геттеры и сеттеры, то  выполняется SELECT в базу на получение реального объекта. 

<img width="1120" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/56866840-b7d4-4080-acd9-75d5675b8d5f">

Справка: паттерн проектирования PROXY 

Заместитель PROXY — структурный шаблон проектирования.  Предоставляет объект суррогат, который контролирует доступ к другому объекту, перехватывая все вызовы.

<img width="780" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/4ead0278-eae8-4070-a56a-b13e0e61f4b3">

Когда использовать прокси? 

<img width="1143" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/105c6ff6-f1ae-4f41-a96b-db8750a0843e">

<img width="1137" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/983d9900-9963-4afd-b136-f90041b1e284">

---------

PROXY - это объект, который создается Hibernate во время выполнения и представляет собой настоящий объект из базы данных. Он реализует ту же интерфейсную часть, что и настоящий объект, и позволяет выполнять над ним те же методы. 

Применение PROXY позволяет отложить загрузку данных из базы данных до тех пор, пока это действительно необходимо для их использования в коде. Это может значительно улучшить производительность приложения, поскольку избегается загрузка большого объема данных, которые могут быть никогда не использованы. 

В Hibernate PROXY используется для ленивой загрузки связанных сущностей (lazy loading), которые ассоциированы с основной сущностью. Например, если у нас есть класс User, который имеет ассоциацию с классом Address, Hibernate может создать PROXY объект Address при загрузке объекта User. 

При обращении к свойству Address объекта User, который не был загружен из базы данных, Hibernate загрузит его из базы данных только тогда, когда это действительно потребуется. 

Кроме того, PROXY в Hibernate может использоваться для отслеживания изменений в сущности. Если изменения были внесены в PROXY объект, Hibernate может автоматически обновить соответствующую запись в базе данных при сохранении объекта. 

В целом, использование PROXY в Hibernate позволяет улучшить производительность приложения, уменьшить количество запросов к базе данных и обеспечить более эффективную работу с сущностями в контексте персистентности данных.

[к оглавлению](#hibernate)

## Расскажи про Hibernate кэширование (уровни кэша и что под капотом) 

Кеширование – один из способов оптимизации работы приложения, ключевой задачей которого является уменьшить количество прямых обращений к БД. 
 
+ **Кэш первого уровня: Session / EntityManager.**
 
Кэшем первого уровня в Hibernate считается СЕССИЯ (либо EntityManager — аналог сессии в JPA). Перед тем, как отправить объект в БД, сессия обязательно хранит, кэширует объект за счёт своих ресурсов.  
 
Session – это обёртка вокруг подключения к БД с помощью JDBC, используется один раз. 
 
Включать в настройках кэширование не нужно, так как, это даже не кэш, а одно название — так по умолчанию работает Hibernate под капотом. 
 
Hibernate хранит отслеживаемые сущности в Map, ключами которой являются id сущностей, а значениями — сами объекты-сущности.  
 
Если извлекаем из базы сущность по id с помощью 
EntityManager.find(), то сущность помещается в Map и хранится там до закрытия сессии. И при повторном find() SQL-команда select в базе данных выполнена не будет. Hibernate возьмет эту сущность из Map — карты отслеживаемых сущностей. 

<img width="1120" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/0933478c-db57-4731-84d1-8e6205b4a2c5">

+ **Кэш второго уровня** — общий кэш всех сессий SessionFactory (фабрика сессий). 
 
Если сессия привязана к транзакции и закрывается каждый раз по ее окончании, то SessionFactory создается один раз и далее ПЕРЕИСПОЛЬЗУЕТСЯ в приложении. 
 
Этот кэш и считается кэшем второго уровня. Это опционально, не обязательно, то есть по умолчанию он не работает, его надо включать. Кэш второго уровня — это прослойка, общая для всех сессий. То есть одна сессия извлекла сущность, а другая может получить к этой сущности потом доступ. Очевидно, что с такой прослойкой есть проблема — данные могут устареть: в базе данные одни, а в кэше второго уровня — другие.  

<img width="498" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/d39f9555-ba19-4a59-9cce-e8c07e136aaf">

+ **Кэш запросов (Query Cache)**

https://youtu.be/C-wEZjEOhWc?t=1560  
 
В Hibernate предусмотрен кэш для запросов, и он интегрирован с кэшем второго уровня.  
 
Это требует двух дополнительных физических мест для хранения кэшированных запросов и временных меток для обновления таблицы БД. Этот вид кэширования эффективен только для часто используемых запросов с одинаковыми параметрами. 
 
Важно: хранит результат запроса, причём ключом является сам запрос и те параметры, которые были переданы в запросе. Хитро устроен: сохраняет не объекты целиком, а их id -шники. 

-----------

Кэширование в Hibernate - это механизм, который предназначен для увеличения производительности приложения. Его цель - избежать повторного получения данных в тех случаях, когда эти данные уже были получены и сохранены в кэше.

Hibernate поддерживает несколько уровней кэша:

1. Первый уровень кэша (First-Level Cache) - это кэш уровня сессии, который хранит объекты, полученные в рамках текущей сессии работы с базой данных. Он представляет собой область памяти, связанную с экземпляром объекта SessionFactory, и автоматически очищается при закрытии сессии или транзакции. Доступ к первому уровню кэша осуществляется через методы получения объектов в рамках текущей сессии.

2. Второй уровень кэша (Second-Level Cache) - это кэш уровня приложения, который хранит объекты, полученные из базы данных в рамках всех сессий приложения. Он может использоваться для сохранения данных, которые часто запрашиваются. Второй уровень кэша может быть настроен различными способами, например, можно использовать сторонние реализации кэша, такие как Ehcache или Infinispan.

3. Кэш запросов (Query Cache) - это кэш, который хранит результаты выполнения запросов к базе данных. Он может использоваться для кэширования результатов запросов, которые часто выполняются в приложении. Кэш запросов также может быть настроен через различные реализации кэша.

Также необходимо его включить и указать какой запрос нужно кэшировать (используя для данного запроса метод - query.setCacheable(true))

<img width="802" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/e780b11c-88cc-4a29-92cc-1c65cb5401ca">

Hibernate использует механизм сериализации для сохранения объектов в кэше. Объекты, полученные из базы данных, сохраняются в кэше в виде сериализованных объектов, а при запросе они восстанавливаются из кэша и десериализуются.

Кэширование в Hibernate может значительно увеличить производительность приложения, особенно если в приложении часто выполняются повторяющиеся запросы к базе данных. Однако, кэширование может привести к проблемам согласованности данных, если кэш не управляется должным образом. Поэтому важно правильно настроить кэширование в Hibernate и заботиться о его согласованности с базой данных.

Кэш в Hibernate - это обычно кэш в памяти, который сохраняется в heap, а не в stack.

В Hibernate есть два типа кэша: кэш первого уровня и кэш второго уровня. Кэш первого уровня находится внутри объекта сессии Hibernate и непосредственно связан с ней. Кэш второго уровня расположен за пределами объекта сессии и может использоваться для кэширования данных между различными объектами сессии в приложении.

Кэш второго уровня в Hibernate обычно использует кучу (heap) Java Virtual Machine для хранения кэшированных данных, хотя могут быть расширения, направленные на сохранение кэша на диске, в других ресурсах или на других серверах.

<img width="754" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/7ee22f4e-7728-494b-8d1e-283ab61d5723">

---------
Если я с помощью HQL обновлю в базе данных сущность типа Employee, то Hibernate удалит все сущности типа Employee в кэше первого уровня, но в кэше второго уровня ничего удалять не будет?

✅ Верно понято! Если вы используете HQL (Hibernate Query Language) для обновления сущностей типа Employee в базе данных, Hibernate автоматически сбрасывает (очищает) кэш первого уровня для всех сущностей типа Employee, находящихся в текущей сессии. Это гарантирует, что при следующем обращении к базе данных для получения сущностей типа Employee, Hibernate выполнит запрос заново и получит обновленные данные.

Однако кэш второго уровня непосредственно не очищается Hibernate при обновлении сущностей с использованием HQL. Кэш второго уровня обычно настраивается внешним образом (например, с использованием поставщика кэша), и его сброс или инвалидация должны быть управлены отдельно. Это позволяет кэшу второго уровня сохранять общие данные между разными сессиями, даже если данные в базе данных изменяются.

Если вам необходимо сбросить или инвалидировать кэш второго уровня вручную после обновления данных, вам придется воспользоваться соответствующими методами или инструментами, предоставляемыми вашим поставщиком кэша второго уровня.


А в каких случаях Hibernate не удаляет, а обновляет объект в кэше первого уровня? 

Если вносите изменения в объекты с использованием методов Session API Hibernate (например, метод `session.update(Object)`), то Hibernate будет обновлять объекты в кэше первого уровня, а не удалять их.

Когда вы используете методы с понятным контекстом изменений (например, `session.update(Object)` или `session.saveOrUpdate(Object)`), Hibernate понимает, что изменения вносятся в конкретный объект и выполняет обновление этого объекта в кэше первого уровня. Это позволяет избежать удаления всех объектов указанного типа из кэша первого уровня.

В то же время, при использовании некоторых запросов HQL или SQL напрямую (например, `session.createQuery().executeUpdate()`), Hibernate не может точно определить, какие объекты были изменены, поэтому он предполагает, что все объекты данного типа могли быть изменены, и выполняет удаление всех объектов указанного типа из кэша первого уровня для избежания несогласованности данных.

Таким образом, для обновления объектов в кэше первого уровня рекомендуется использовать методы сессии Hibernate, которые обновляют объекты явным образом.

Однако, стоит отметить, что Hibernate имеет различные уровни кэширования, и кэш первого уровня является только одной из его частей. Hibernate также предоставляет кэш второго уровня и кэш запросов, которые могут быть настроены для более точного управления кэшированием и обновлением объектов.

Чтобы Hibernate обновил объект в кэше первого уровня, вам нужно получить объект `Employee` с помощью сессии Hibernate, внести изменения в свойство `name` этого объекта и сохранить его обратно в базу данных при помощи метода `session.update(Object)`. Например:

```java
Employee employee = session.get(Employee.class, 4); // Получить объект Employee с id = 4
employee.setName("Alex"); // Внести изменения в свойство name
session.update(employee); // Обновить объект в базе данных и кэше первого уровня
```

Таким образом, Hibernate будет обновлять объект `Employee` в кэше первого уровня, а не удалять все объекты типа `Employee`.

--------------
<img width="776" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/7def81c5-ec9e-462e-87f6-831c16e5efb6">

--------------
Если объекта нет ни в кэше первого, ни второго уровня, то Hibernate выгружает его из БД и кладет только в кэш первого уровня или в кэш второго уровня тоже, если он включен?

Если объект не найден ни в кэше первого уровня (L1-кэш), ни в кэше второго уровня (L2-кэш), то Hibernate загружает его из базы данных и помещает в кэш первого уровня. Он не помещает новый объект напрямую в кэш второго уровня, если он не был предварительно загружен и кэширован в кэше первого уровня.

Кэш второго уровня (L2-кэш) является общим кэшем для всех сессий Hibernate и используется для хранения общих данных, которые могут быть использованы различными сессиями. Если объект не найден в кэше первого уровня, Hibernate загружает его из базы данных и помещает в кэш первого уровня для дальнейшего использования в рамках текущей сессии. Кэш второго уровня не связан напрямую с загрузкой объектов из базы данных, и объекты не помещаются в него непосредственно при загрузке из БД. Однако, после того как объект загружен и находится в кэше первого уровня, он может быть скопирован или перемещен в кэш второго уровня, при условии, что соответствующий поставщик кэша и конфигурация настроены для этого.

Таким образом, если объект не найден ни в кэше первого уровня, ни в кэше второго уровня, Hibernate загружает его из базы данных и помещает только в кэш первого уровня.

-------------------
ДРУГОЙ ВОПРОС

<img width="1179" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/6b725827-3a08-4a34-be77-ec945b62b074">

JPA говорит о двух видах кэшей (cache): 
+ first-level cache (кэш первого уровня) — кэширует данные одной транзакции 
+ second-level cache (кэш второго уровня) — кэширует данные дольше чем одна транзакция.  

Провайдер JPA может, но не обязан реализовывать работу с кэшем второго уровня. Такой вид кэша позволяет сэкономить время доступа и улучшить производительность, однако оборотной стороной является возможность получить устаревшие данные. 

[к оглавлению](#hibernate)

## Как работать с кэшем второго уровня?                                           

https://javac-dmx.blogspot.com/2015/01/13-hibernate.html

https://habr.com/ru/post/135176/  
 
Если кэш первого уровня привязан к объекту сессии, то кэш второго уровня привязан к объекту – фабрике сессий (Session Factory object) => видимость этого кэша гораздо шире. 
 
Тут будет выполнено 2 запроса в базу, 
т.к. по умолчанию кэш второго уровня отключен → 

<img width="460" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/343e9b1c-517d-4dca-8553-22fe95195418">

Для включения необходимо добавить следующие строки в конфиг файле JPA (persistence.xml): 

<img width="932" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/580d9ddc-2157-4b24-92b6-5de9b9cbee09">

Обратите внимание на первую строчку. Hibernate сам не реализует кеширование как таковое. А лишь предоставляет структуру для его реализации, поэтому подключить можно любую реализацию, которая соответствует спецификации ORM фреймворка. Из популярных реализаций можно выделить: EHCache, OSCache, SwarmCache, JBoss TreeCache. 

Также понадобится отдельно настроить и саму реализацию кэша. В случае с провайдером кэширования EHCache это нужно сделать в файле ehcache.xml  Еще нужно указать самому хибернейту, что именно кэшировать. Это легко можно сделать с помощью аннотаций, например так → 

<img width="432" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/2e9716a2-85a7-44c6-8ef7-ff166f25bfc5">

Только после всех этих манипуляций кэш второго уровня будет включен и в примере выше будет выполнен только 1 запрос в базу. 
 
Важно! Hibernate НЕ хранит объекты классов, а хранит информацию в виде массивов строк, чисел и т. д. И идентификатор объекта выступает указателем на эту информацию. Концептуально это нечто вроде Map, в которой id объекта — ключ, а массивы данных — значение. Приблизительно это выглядит так:

<img width="316" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/420751f5-52fd-419e-b198-40095ebe311d">

Это разумно, учитывая, сколько памяти занимает каждый хранимый объект. 
 
Зависимости класса по умолчанию также не кэшируются. Например, если рассмотреть класс выше — SharedDoc, то при выборке коллекция users будет доставаться из БД, а не из кэша второго уровня. Если нужно кэшировать и зависимости, то класс должен выглядеть так → 

<img width="453" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/2676f177-fa24-44a6-ba8d-159e60e2aa80">

Чтение из кэша второго уровня происходит только в том случае, если нужный объект не был найден в кэше первого уровня (см. рисунок выше). 
 
**Стратегии кеширования**

Проблема заключается в том, что кэш второго уровня доступен из нескольких сессий сразу и несколько потоков программы могут одновременно в разных транзакциях работать с одним и тем же объектом.  
 
Следовательно, надо как-то обеспечивать их одинаковым представлением этого объекта.  
 
В Hibernate существует четыре стратегии одновременного доступа к объектам в кэше: 
+ Read-only (только чтение) 
+ Read-write (чтение-запись) 
+ Nonstrict-read-write (не строгое чтение-запись) 
+ Transactional (транзакционное)

<img width="916" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/e3b7501f-282f-4ab2-ab4f-0fe6f13ca3c8">

CacheMode (используется для кэша первого уровня!)
Hibernate позволяет очень гибко управлять кешированием. Ты можешь настроить режим кеширования для каждой отдельной сессии или даже для каждого запроса к базе данных.

Всего таких режимов пять:

+ GET
+ IGNORE
+ NORMAL
+ PUT
+ REFRESH

В таблице ниже описана их работа:

<img width="802" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/ea60307e-bb97-4333-991c-761de9dcc93a">

<img width="827" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/1452dcd9-4156-46d4-9694-ed90a56191ec">

-----------------
ДРУГОЙ ВОПРОС

Каким способом можно в коде работать с кэшем второго уровня (удалять все или определенные Entity из кэша, узнать закэшировалась ли сущность Entity и т.п.)? 

Для работы с кэшем второго уровня (second level cache) в JPA описан Cache интерфейс, содержащий большое количество методов по управлению кэшем второго уровня.  

Если он поддерживается провайдером JPA, конечно. Объект данного интерфейса можно получить с помощью метода getCache() у EntityManagerFactory. 

JPA сообщает о пяти значениях shared-cache-mode из persistence.xml, который определяет как будет использоваться second-level cache: 
+ ALL — все Entity могут кэшироваться в кеше второго уровня 
+ NONE — кеширование отключено для всех Entity 
+ ENABLE_SELECTIVE — кэширование работает только для тех Entity, у которых установлена аннотация Cacheable(true) или её xml эквивалент, для всех остальных кэширование отключено 
+ DISABLE_SELECTIVE — кэширование работает для всех Entity, за исключением тех у которых установлена аннотация Cacheable(false) или её xml эквивалент 
+ UNSPECIFIED — кеширование не определенно, каждый провайдер JPA использует свою значение по умолчанию для кэширования. 

[к оглавлению](#hibernate)

## Что такое Persistence Context?

Персистентный контекст - это набор экземпляров сущностей, загруженных из БД или только что созданных. Персистентный контекст является своего рода кэшем данных в рамках транзакции - это и есть кэш первого уровня. Внутри контекста персистентности происходит управление экземплярами сущностей и их жизненным циклом. 

------------

Java Persistence API (JPA) использует интерфейс javax.persistence.EntityManager для управления экземплярами Entity и их жизненным циклом (Hibernate делает это с помощью интерфейса org.hibernate.Session).  

<img width="471" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/2d60509a-c3b4-4d54-a8a3-e11275ba2086">
 
Каждый экземпляр EntityManager связан с Persistence Context, который является своего рода кэшем данных в рамках транзакции — это и есть кэш первого уровня.  
 
Persistence контекст бывает двух типов в зависимости от этапа жизненного цикла: 
+ Persistence контекст области транзакции (Transaction scope persistence context) 
+ Расширенный persistence контекст (Extended persistence context) 

Для EntityManager, управляемого контейнером, можно выбрать тип persistence контекста. Укажите тип контекста в атрибуте type @PersistenceContext. Типом по умолчанию является Transaction scope. Обратите внимание, что расширенный контекст всегда используется для EntityManager, управляемого приложением (в этом случае нельзя выбирать тип контекста). 

<img width="735" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/a13539fc-a9c5-47ad-9c9b-8b536961e30d">

Если у нас есть ссылка на другую сущность с типом `fetch.lazy` (ленивая загрузка) внутри нашей сущности, вот как это будет работать в двух типах Persistence контекста:

1️⃣ Persistence контекст области транзакции:
   При использовании этого типа контекста, связанная сущность с типом `fetch.lazy` не будет автоматически загружена в рамках текущей транзакции. Если вы попытаетесь обратиться к этой связанной сущности после завершения транзакции (т.е., когда Persistence контекст области транзакции станет недоступным), вы получите исключение или ошибку.

2️⃣ Расширенный persistence контекст:
   В случае использования этого типа контекста, вы сможете загрузить связанную сущность с типом `fetch.lazy` даже после завершения транзакции, так как расширенный контекст существует дольше и может простирается за пределы одной транзакции. Вы сможете выполнить запрос или операцию загрузки связанной сущности в рамках другой транзакции, когда Persistence контекст все еще доступен.

Таким образом, при использовании Persistence контекста области транзакции, доступ к связанным сущностям с типом `fetch.lazy` будет ограничен временем жизни транзакции, в то время как использование расширенного контекста позволит вам загружать связанные сущности даже после завершения транзакции.

-------------
Persistence Context - это особая область памяти, используемая при работе с базой данных в рамках Java Persistence API (JPA).

У каждого потока выполнения приложения может быть свой Persistence Context, который представляет собой набор сущностей (Java-объектов, соответствующих записям в базе данных), полученных из базы данных или созданных приложением и готовых к сохранению в БД. 

Persistence Context берет на себя управление объектами, изменения в которых нужно сохранить в базе данных. Он отслеживает изменения состояния объектов, и при необходимости сохраняет эти изменения в базу данных, либо откатывает их в случае ошибки.

Таким образом, Persistence Context упрощает процесс работы с базой данных в Java-приложениях, позволяя разработчикам удобно и безопасно сохранять и получать данные из базы.

Persistence Context представляет собой механизм управления жизненным циклом объектов-сущностей, таких как создание, считывание, изменение и удаление.

Persistence Context - это механизм управления объектами сущностей в рамках JPA (Java Persistence API). Он представляет собой контекст выполнения, в котором хранятся и управляются все объекты, связанные с EntityManager (то есть все сущности, которые были загружены/сохранены/обновлены/удалены с помощью EntityManager). 

Persistence Context определяет состояние и жизненный цикл каждой сущности в контексте. Жизненный цикл сущности включает в себя следующие состояния: 

1. New (новый объект)
2. Managed (управляемый объект)
3. Detached (отсоединенный объект)
4. Removed (удаленный объект)

Persistence Context использует несколько методов для определения того, как взаимодействовать с каждой сущностью в рамках ее текущего состояния. 

Если объект был только что создан и еще не сохранен в базе данных, Persistence Context помечает его как новый объект (New), и ожидает от EntityManager дальнейших инструкций: сохранить его с помощью метода `persist()`, обновить с помощью метода `merge()`, объединить измененное состояние сущности с текущей версией базы данных (в случае, если сущность уже сохранена) или отсоединить его от EntityManager'а (с помощью метода `detach()`).

Если объект был получен из базы данных с помощью метода `find()`, EntityManager помечает его как управляемый объект (Managed), и любые изменения, внесенные в его состояние, будут автоматически сохраняться в базе данных. 

Если объект был удален с помощью метода `remove()`, EntityManager помечает его как удаленный объект (Removed), и удалит его из базы данных при следующем вызове метода `flush()`. 

Если объект был до этого управляемым, но с помощью метода `detach()` был отсоединен от EntityManager'а, то он помечается как отсоединенный объект (Detached), и любые изменения, внесенные в его состояние, не будут автоматически сохраняться в базе данных. 

Таким образом, Persistence Context отслеживает состояние каждой сущности и предоставляет EntityManager'у необходимые инструкции по ее сохранению, обновлению, удалению или отсоединению.

[к оглавлению](#hibernate)

## Что такое EntityManager?

EntityManager - это интерфейс JPA, используемый для взаимодействия с персистентным контекстом. EntityManager описывает API для всех основных операций над Entity, а также для получения данных и других сущностей JPA. По сути - главный API для работы с JPA.

Персистентный контекст - это набор экземпляров сущностей, загруженных из БД или только что созданных. Персистентный контекст является своего рода кэшем данных в рамках транзакции - это и есть кэш первого уровня. Внутри контекста персистентности происходит управление экземплярами сущностей и их жизненным циклом. 

EntityManager автоматически сохраняет в БД все изменения, сделанные в его персистентном контексте, в момент коммита транзакции, либо при явном вызове метода flush().

Один или несколько EntityManager образуют или могут образовать persistence context.

Если проводить аналогию с обычным JDBC, то EntityManagerFactory будет аналогом DataSource, а EntityManager аналогом Connection.

Создание EntityManagerFactory довольно дорогая операция, поэтому обычно её создают один раз и на всё приложение. А чаще всего не создают сами, а делегируют это фреймворку, такому как Spring, например Интерфейс Session из Hibernate представлен в JPA как раз интерфейсом EntityManager.

<img width="526" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/b8da10cc-68c5-4f8f-9058-890181cb22d3">

[к оглавлению](#hibernate)

## Методы интерфейса EntityManager     

https://docs.oracle.com/javaee/7/api/javax/persistence/EntityManager.html  

<img width="752" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/6a4b7557-fe7f-45bd-9c52-8fab61185b5c">

---------

EntityManager является основным компонентом JPA (Java Persistence API), который управляет сущностями (entities) в базе данных. Вот некоторые из методов интерфейса EntityManager:

1. persist(Object entity) - сохраняет новую или обновляет существующую сущность в базе данных. 

Метод persist() используется для сохранения новой сущности в базе данных. При вызове этого метода сущность сохраняется в контексте персистенции, и при следующем вызове метода flush() все сущности, находящиеся в контексте персистенции, будут сохранены в базу данных.

2. find(Class<T> entityClass, Object primaryKey) - найдет сущность по заданному первичному ключу.

3. remove(Object entity) - удаляет сущность из базы данных.

4. createQuery(String qlString) - создает запрос на выборку данных из базы данных.

5. merge(Object entity) - обновляет существующую сущность в базе данных.

6. refresh(Object entity) - обновляет сущность в соответствии с данными, хранящимися в базе данных.

7. flush() - сбрасывает все ожидающие операции в базу данных.

8. getReference(Class<T> entityClass, Object primaryKey) - возвращает объект-ссылку на сущность.

9. clear() - очищает кэш EntityManager.

10. isJoinedToTransaction() - возвращает true, если EntityManager присоединен к транзакции.

11. Метод detach() используется для отсоединения сущности от контекста персистенции. Если сущность находится в контексте персистенции, то вызов метода detach() удаляет ее из контекста персистенции. Однако сущность все еще остается привязанной к базе данных, и ее можно загрузить снова при необходимости. Метод detach() - это способ отсоединить объект от контекста персистентности и избежать сохранения его изменений в базе данных.

Однако сама сущность не удаляется из базы данных, а ее состояние остается в памяти и может быть повторно присоединено, используя метод merge().

12. Метод contains() позволяет проверить, находится ли сущность в контексте персистенции. Если сущность находится в контексте персистенции, метод возвращает значение true, в противном случае - false.

Метод persist() используется для сохранения новых сущностей в базе данных. Если сущность уже была сохранена, то вызов метода persist() ничего не изменит. Если же сущность не сохранена, то она получит статус "управляемой" и будет сохранена в базе данных после вызова метода flush().

Метод contains() может быть использован для проверки, находится ли сущность в контексте персистенции. Если сущность не находится в контексте персистенции, ее можно загрузить снова с помощью метода find(), или обратиться к базе данных напрямую.

[к оглавлению](#hibernate)

## Какие функции он выполняет? 
 
EntityManager вставляет (insert) объект управляемой сущности в persistence context (контекст постоянства) и управляет объектами сущности. Когда приложение передает entity объект в persist method или обновляет значение поля управляемого entity объекта, статус entity объекта в persistence контексте изменяется. 

<img width="840" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/c0de336a-ae1e-4f53-80ad-a72b78b23266">

А для синхронизации требуется транспорт и этим транспортом является транзакция. 

EntityManager синхронизирует статусы объектов сущностей в persistence контексте и таблице базы данных непосредственно перед фиксацией (commit -ом) транзакции.  

Чтобы применить статусы объектов сущностей в persistence контексте к таблице БД, SQL-операторы обновления выпускаются коллективно и одновременно. В результате время блокировки базы данных сокращается, и, следовательно, можно улучшить параллельное выполнение и эффективно обновлять данные. 
 
Изменения, накопленные в EntityManager, при помощи транзакции были закоммичены (commit), т.е. подтверждены и сохранены в БД. 

<img width="582" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/7af05e8a-00a5-4a3b-aa82-f82084ef54f2">

<img width="897" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/9ad60c6d-2e58-42da-a951-f806342b4f40">

**Основные функции EntityManager:**
+ Операции над Entity: persist (добавление Entity под управление JPA), merge (изменение), remove (удаление), refresh (обновление данных), detach (удаление из-под управления контекста персистентности), lock (блокирование Entity от изменений в других thread). 
+ Получение данных: find (поиск и получение Entity), createQuery, createNamedQuery, createNativeQuery, contains, createNamedStoredProcedureQuery, createStoredProcedureQuery. 
+ Получение других сущностей JPA: getTransaction, getEntityManagerFactory, getCriteriaBuilder, getMetamodel, getDelegate.  
+ Работа с EntityGraph: createEntityGraph, getEntityGraph. 
+ Общие операции над EntityManager или всеми Entities: close, isOpen, getProperties, setProperty, clear.  

Объекты EntityManager НЕ являются поток безопасными. Это означает, что каждый поток должен получить свой экземпляр EntityManager, поработать с ним и закрыть его в конце.

-----------
EntityManager в JPA (Java Persistence API) выполняет следующие функции:

1. Управление состоянием объекта: EntityManager отслеживает состояние объектов в персистентном контексте. Это означает, что он отслеживает изменения объектов, такие как добавление, удаление и изменение состояния объектов, и обновляет их в базе данных при необходимости.

2. Управление жизненным циклом объекта: EntityManager управляет жизненным циклом объекта, начиная с создания объекта и заканчивая его удалением. Он также управляет отношениями между объектами в базе данных.

3. Исполнение запросов: EntityManager позволяет выполнять запросы к базе данных, включая чтение и запись данных. Он использует язык запросов JPQL (Java Persistence Query Language), который позволяет выполнить запросы на языке Java, без зависимости от конкретной базы данных.

4. Управление транзакциями: EntityManager управляет транзакциями при работе с базой данных. Он начинает транзакцию при запросе и коммитит ее, когда все изменения были успешно применены.

5. Кэширование данных: EntityManager позволяет кэшировать данные, чтобы ускорить доступ к данным в базе данных. Он использует два типа кэширования: кэш первого уровня (EntityManager cache) и кэш второго уровня (shared cache), который хранится вне EntityManager.

6. Работа с объектами в разных средах: EntityManager позволяет работать с объектами в разных средах (например, в разных транзакциях или потоках выполнения), обеспечивая синхронизацию состояния объектов между различными средами.

[к оглавлению](#hibernate)

## Каким условиям должен удовлетворять класс чтобы являться Entity?

Entity – это легковесный хранимый объект бизнес-логики (persistent domain object). Основная программная сущность – это entity класс, который так же может использовать дополнительные классы, как вспомогательные или для сохранения состояния еntity. 
 
Entity Class – это Java класс, который отображает информацию таблицы в базе данных. Это также POJO класс, в котором используются Hibernate аннотации для связи класса с 
таблицей из базы данных. 

https://javarush.com/groups/posts/2259-jpa--znakomstvo-s-tekhnologiey  

Персистентное состояние сущности представлено персистентными полями или персистентными свойствами (методами). В JPA персистентные поля и свойства принято называть атрибутами класса-сущности. 
 
Персистентное поле – это поле сущности, которое отражается в БД в виде столбца таблицы.  
 
Персистентное свойство – это методы, поведение сущности, которые аннотированы вместо полей для доступа провайдера к ним (полям).  
 
Эти поля или свойства используют аннотации объектнореляционного сопоставления (маппинга) для сопоставления сущностей и отношений между ними с реляционными данными в хранилище данных.  Примеры аннотаций: @OneToOne, @OneToMany, @ManyToOne, @ManyToMany.  

<img width="349" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/f6c91cf2-99c0-4f9b-a2a6-f35932341e80">
 
Есть два вида доступа к состоянию сущности:  
 
Доступ по полю, когда аннотации стоят над полями.  В этом случае провайдер, например, Hibernate, обращается к полям класса напрямую, используя Reflection. 
 
Доступ по свойству (методу), когда аннотации стоят над методами-геттерами. В этом случае провайдер, например, Hibernate, обращается к полям класса через методы.  
 
Требования к Entity классу в JPA:      

<img width="1028" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/93a05392-590e-4622-815b-c59d0b9d0546">

<img width="1018" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/d2af611b-bd90-4eb4-902d-0be2dc530cb2">

<img width="1033" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/96821c6d-16ac-46ec-97b1-8cfab7fd30f6">

<img width="1007" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/1311cf49-27fc-488a-9e43-23a232f53b14">

[к оглавлению](#hibernate)

## Расскажи про жизненный цикл сущности Entity, перечисли четыре статуса ЖЦ Entity объекта (Entity Instance’s Life Cycle).

<img width="685" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/7abfd84d-b3c9-4ecb-94d0-8b1ca549de41">

<img width="946" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/e758de9b-af02-4bfa-bebe-00289907e733">

**Этап №1 New, переходное состояние (Transient State)**
 
Объект создан, не имеет primary key, не является частью контекста персистентности (не управляется JPA);  

Переходное состояние — это первое состояние объекта сущности. Когда мы создаем объект POJO класса с помощью оператора new, объект находится в переходном состоянии. Этот объект не связан ни с одной сессией, следовательно это состояние не связано ни с одной таблицей БД. Итак, если мы внесем какие-либо изменения в данные класса POJO, таблица базы данных не изменится. Временные объекты не зависят от Hibernate и существуют в куче памяти. 
 
<img width="433" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/cf10d890-c649-4b5a-a8aa-61abd5b31614">

**Этап №2 Managed, постоянное состояние (Persistent State)**
 
Объект создан, имеет primary key, является частью контекста персистентности (управляется JPA); 
 
Как только объект подключается к сессии, он переходит в постоянное состояние.  
 
Есть два способа преобразовать переходное состояние в постоянное состояние: 
+ Используя сессию, сохранить объект сущности в таблице базы данных. 
+ Используя сессию, загрузить объект сущности в таблицу базы данных. 

В этом состоянии. каждый объект представляет собой одну строку в таблице БД. Следовательно, если внести какиелибо изменения в данные, то hibernate обнаружит это и внесет изменения в таблицу базы данных. 

<img width="244" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/6712a3b1-e373-4d1d-8fd1-9b269c1ea899">

<img width="899" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/b2fd2642-7b50-4d80-8f19-c71b52386501">

**Этап №3 Detached, отсоединённое состояние (Detached State)**

Объект создан, имеет primary key, не является (или больше не является) частью контекста персистентности (не управляется JPA); 

Для преобразования объекта из постоянного в отсоединенное состояние нужно либо закрыть сессию, либо очистить кеш. Поскольку сессия будет закрыта или кеш очищен, любые изменения, внесенные в данные, не повлияют на таблицу базы данных. При необходимости отсоединенный объект можно повторно подключить к новой сессии.  

<img width="915" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/13670e09-0a79-48d2-9a0e-3095ccf27d52">

**Этап №4 Removed, состояние «удалено» (Removed State)**

Объект создан, является частью контекста персистентности (управляется JPA), будет удален при commit-е транзакции (закрытии сессии или вызове метода flush()).

В жизненном цикле спящего режима это последнее состояние. Когда объект сущности удаляется из базы данных, объект сущности находится в удаленном состоянии. Это делается путем вызова операции delete(). Поскольку Entity объект находится в удаленном состоянии, любое изменение данных не повлияет на таблицу базы данных. 

<img width="900" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/a4ec3272-bfc7-4470-8c38-78bb9fb92e5f">

[к оглавлению](#hibernate)

## Как влияют операции persist, remove, merge, refresh, detach на Entity объекты каждого из четырех статусов? 

<img width="775" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/08715976-e847-4989-81fc-afa761c7ba85">
<img width="777" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/eca38db1-0e14-4b9f-b0e4-1fd19e6afa6f">

https://vladmihalcea.com/jpa-persist-and-merge/

https://stackoverflow.com/questions/1069992/jpa-entitymanager-why-use-persist-over-merge

Операция `merge()` в JPA вызывает исключение для объектов со статусом "removed", потому что такие объекты считаются удаленными из базы данных и уже не связаны с Persistence Context.

Чтобы сохранить объект со статусом detached, можно использовать операцию merge вместо persist. Операция merge выполняет либо вставку нового объекта, либо обновление существующего объекта в базе данных.

При вызове `merge()` для объекта со статусом "removed", JPA пытается восстановить его состояние из базы данных. Однако, поскольку объект был помечен как удаленный, JPA не может выполнить такое восстановление. В результате возникает исключение.

С другой стороны, операция `merge()` не вызывает исключение для объектов со статусом "transient" (еще не управляемых объектов), потому что для них она выполняет операцию вставки (insert) нового объекта в базу данных.

При вызове `merge()` для объекта со статусом "transient", JPA создает новую копию переданного объекта и вставляет ее в базу данных. Поэтому операция `merge()` успешно обрабатывает такие объекты без вызова исключения.

Но важно отметить, что операция `merge()` возвращает новый объект, который представляет объединенное состояние. Это означает, что после вызова `merge()` вам нужно использовать возвращаемый объект для продолжения работы, поскольку исходный объект уже не связан с Persistence Context.

Операция persist в JPA выполняет проверку наличия объекта в базе данных с помощью операции select. Если такой объект уже существует в базе данных, JPA генерирует исключение.

Да, операция `merge` также неявно вызывает операцию `select` для проверки наличия объекта в базе данных.

Операция `merge` в JPA используется для объединения (обновления) состояния объекта из контекста персистентности в базу данных. Если объект с тем же идентификатором уже существует в базе данных, операция `merge` выполнит операцию `select`, чтобы получить текущие значения свойств объекта из базы данных. Затем она сравнит эти значения с новыми значениями из контекста персистентности и выполнит необходимые обновления.

Если объект с заданным идентификатором отсутствует в базе данных, операция `merge` создаст новую запись с новыми значениями объекта.

Когда объект становится "управляемым" (managed), это означает, что JPA отслеживает все изменения в объекте. Таким образом, когда JPA выполняет операцию сохранения (persist), он проверяет, есть ли уже объект с таким же идентификатором в базе данных.

Если объект уже существует в базе данных, JPA обновляет его значения, и это называется операцией "merge". Обратите внимание, что операция merge копирует значения из вашего объекта в уже существующий объект в базе данных, а не создает новую запись.

Однако, если объект является "отсоединенным" (detached), JPA не знает, был ли объект ранее сохранен в базе данных или нет. JPA не имеет контекста об отсутствующих объектах и не знает, какую операцию выполнить - вставить новую запись или обновить существующую.

Поэтому операция persist вызывает исключение для объектов со статусом detached. Чтобы явно указать JPA, что нужно сделать с отсоединенным объектом, вы должны использовать операцию merge. Merge позволяет JPA определить, нужно ли вставить новую запись или обновить существующую на основе идентификатора объекта.

Короче говоря, операция persist предназначена для сохранения новых объектов, а merge - для объединения изменений с уже существующими объектами в базе данных.

Важно отметить, что в JPA удаление объектов из базы данных с помощью операции `remove()` не означает немедленного удаления из памяти. Объекты все еще могут оставаться в Persistence Context до момента сборки мусора, когда они становятся недостижимыми.

[к оглавлению](#hibernate)

## Может ли абстрактный класс быть Entity?
 
Абстрактный класс может быть Entity классом. Абстрактный Entity класс отличается от обычных Entity классов только тем, что нельзя создать объект этого класса.  
 
Имена абстрактных классов могут использоваться в запросах.  
 
Абстрактные Entity классы используются в наследовании, когда их потомки наследуют поля абстрактного класса: 

<img width="776" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/6caff097-4b49-4946-9b57-f3645e5fb122">

[к оглавлению](#hibernate)

## Может ли Entity класс наследоваться от не Entity классов (non-entity classes)? 
 
Да, сущности могут наследоваться от НЕ Entity классов, которые, в свою очередь, могут быть как абстрактными, так и обычными.  
 
Состояние (поля) НЕ Entity суперкласса НЕ является персистентным, то есть не хранится в БД и не обрабатывается провайдером (Hibernate), поэтому любое такое состояние (поля), унаследованное Entity классом, также НЕ будет отображаться в БД. 
 
Не Entity суперклассы не могут участвовать в операциях EntityManager или Query. 

Любые маппинги или аннотации отношений в не Entity суперклассах игнорируются

<img width="565" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/5567e4bb-80a0-4c77-9d25-1cf065d13329">

[к оглавлению](#hibernate)

## Может ли Entity класс наследоваться от других Entity классов? 

Да, может. 

[к оглавлению](#hibernate)

## Может ли не Entity класс наследоваться от Entity класса? 

Да, может. 

<img width="1045" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/2d20f944-633e-4984-9c05-db89c55257a0">

[к оглавлению](#hibernate)

## Что такое встраиваемый (Embeddable) класс?

Встраиваемый (Embeddable) класс Это класс, который не используется сам по себе, а только как часть одного или нескольких Entity классов. Hibernate называет эти классы компонентами. JPA называет их встраиваемыми. В любом случае, концепция одна и та же: композиция значений.

Встраиваемый класс помечается аннотацией @Embeddable.

Встраиваемый класс может быть встроен в несколько классов-сущностей, но встроенный объект с конкретным состоянием принадлежит исключительно владеющей им сущности и не может использоваться одновременно другими сущностями, он не является общим для нескольких сущностей. То есть, если класс Person с полями name и age встроен и в класс Driver, и в класс Baker, то у обоих последних классов появятся оба поля из класса Person. Но если у объекта Driver эти поля будут иметь значения "Иван" и "35", то эти же поля у объекта Baker могут иметь совершенно иные значения, никак не связанные с объектом Driver.

В целом, встраиваемый класс служит для того, чтобы выносить определение общих атрибутов для нескольких сущностей, можно считать что JPA просто встраивает в сущность вместо объекта такого класса те атрибуты, которые он содержит.

Особенности встраиваемых классов

+ все поля встраиваемого класса, даже коллекции, станут полями класса, в который происходит встраивание;
+ встраиваемые классы могут быть встроены в одну и ту же сущность несколько раз, нужно только поменять имена полей;
+ экземпляры встраиваемых классов, в отличие от экземпляров сущностей, не имеют собственного персистентного состояния, вместо этого они существуют только как часть состояния объекта, которому они принадлежат;
+ встраиваемые классы могут использовать в качестве полей:
  - базовые типы;
  - коллекции базовых типов (с аннотацией @ElementCollection);
  - другие встраиваемые классы;
  - коллекции других встраиваемых классов (с аннотацией @ElementCollection);
  - сущности;
  - коллекции сущностей;
+ сущность может использовать в качестве полей одиночные встраиваемые классы и коллекции встраиваемых классов;
+ встраиваемые классы могут использоваться в качестве ключей и значений Map.

-------------
Можно также применять это для денормализации БД (ускорений запросов к БД).  Для этой цели используют аннотации @Embeddable и @Embedded, предоставляемые Java Persistence API (JPA). Тестировать производительность в продакшене (!). 
 
Пример. Определим контекст модели данных. 
Создадим таблицу company. В ней будет храниться основная информация: название компании, адрес и телефон, а также информация о контактном лице (рис. слева). Контактное лицо должно быть абстрагировано в отдельный класс. Однако мы не хотим создавать отдельную таблицу, что можно сделать? 
 
JPA предоставляет аннотацию @Embeddable, чтобы объявить, что класс будет внедрен другими объектами. Определим класс для абстрагирования сведений о контактном лице. Аннотация JPA @Embedded используется для встраивания типа в другой объект. 
 
Изменим класс Company. Добавим аннотации JPA, а также изменим использование ContactPerson вместо отдельных полей:

<img width="1102" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/bd6d50ed-ff15-41ce-b812-7323840d2aa1">

В результате есть сущность Company, содержащая данные контактного лица и сопоставление с одной таблицей базы данных. НО все еще есть еще одна проблема, и это то, как JPA будет отображать эти поля в столбцы базы данных. 
 
**Переопределение атрибутов.**

Поля назывались так: contactFirstName в исходном классе Company, а теперь firstName в классе ContactPerson.  Таким образом, JPA захочет сопоставить их с contact_first_name и first_name соответственно. Кроме того, колонка phone теперь дублируется. 
 
Необходимо использовать @AttributeOverrides и @AttributeOverride для переопределения свойств столбца встроенного типа. Добавим это в поле «Контактное лицо» в сущности «Компания» (рис. ниже). 
 
Поскольку эти аннотации помещаются в поле, то могут быть разные переопределения для каждого включающего объекта. 

<img width="1111" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/80aafed4-c3d2-4420-8cc5-fc1a561fddc3">

Итак, Embeddable класс – это класс, который не используется сам по себе, а только как часть одного или нескольких Entity классов. Entity класс может содержать как одиночные встраиваемые классы, так и коллекции таких классов. Также такие классы могут быть использованы как ключи или значения map.  
 
Во время выполнения каждый встраиваемый класс принадлежит только одному объекту Entity класса и не может быть использован для передачи данных между объектами Entity классов (то есть такой класс не является общей структурой данных для разных объектов).  
 
В целом, такой класс служит для того, чтобы выносить определение общих атрибутов для нескольких Entity, можно считать, что JPA просто встраивает в Entity вместо объекта такого класса те атрибуты, которые он содержит. 

[к оглавлению](#hibernate)

## Какие требования JPA предъявляет к встраиваемым (Embeddable) классам?

+ Должны соответствовать требованиям для сущностей (раздел 2.1 Java Persistence API), за исключением того, что у встраиваемых классов не ставится аннотация @Entity и может отсутствовать первичный ключ (@Id).
+ Должны быть аннотированы @Embeddable.

Например, у нас может быть встраиваемый класс ClassA, который представляет собой композицию строкового и числового значений, и эти два поля будут добавлены в класс EntityA:

<img width="941" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/9fc4b5dc-b57e-4d45-8f6d-6a9449a985f4">

Так как мы можем встраивать классы в неограниченное количество других классов, то у каждого класса, содержащего встраиваемый класс, мы можем изменить названия полей из встраиваемого класса. Например, у класса Driver поля из встраиваемого класса Person будут изменены с name на driver_name и с age на driver_age:
```java
@Embeddable
public class Person {

  private String name;
  private int age;

}

@Entity
public class Driver {

  @Embedded
  @AttributeOverrides({
    @AttributeOverride( name ="name",
              column = @Column(name ="driver_name")),
    @AttributeOverride( name ="age",
              column = @Column(name ="driver_age"))

  })

  private Person person;

  ...

}
```
Можно использовать для денормализации БД (ускорений запросов к БД).

[к оглавлению](#hibernate)

## Для чего нужны аннотации @Embedded и @Embeddable? 

**@Embeddable** Аннотация JPA, размещается над классом для указания того, что класс является встраиваемым в другие классы и будет внедрен другими сущностями, то есть поля этого встраиваемого класса будут добавляться к полям других сущностей и будут представлять столбцы в таблице этой сущности. 

Так, во встраиваемый класс мы можем выделить общие поля для разных сущностей, не создавая для него таблицу. Встраиваемый класс сам не является сущностью. 
 
**@Embedded** аннотация JPA, используется для размещения над полем в классе-сущности для указания того, что внедряется встраиваемый класс.

<img width="782" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/3795c39d-4943-4a65-b927-df589c8587b3">

<img width="910" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/c4a191dc-7fa8-4d5b-9a94-3bad7b9f86ed">

<img width="953" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/f6b2a7c9-1a87-428a-a6a5-8a0658a2271f">

[к оглавлению](#hibernate)

## Что такое Mapped Superclass?                            

https://www.logicbig.com/tutorials/java-ee-tutorial/jpa.html 

<img width="891" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/1fd56366-e62c-44d5-83e4-3de26ba45d1f">

Это стратегия наследования полей, когда базовый класс НЕ является отдельной Entity сущностью Hibernate и НЕ имеет своей таблицы в базе данных.    

Mapped Superclass (сопоставленный суперкласс) – это класс, от которого наследуются Entity, он может содержать аннотации JPA, однако сам такой класс  не является Entity, ему не обязательно выполнять все требования, установленные для Entity (например, он может не содержать первичного ключа).  
 
Эти суперклассы чаще всего используются, когда есть общая для нескольких классов сущностей информация о состоянии и отображении, которую можно вынести в Mapped Superclass.

<img width="1209" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/432f06a1-e1a4-4c3d-85ad-3c388cc3ec1c">

В этом примере в БД будут таблицы FULLTIMEEMPLOYEE и PARTTIMEEMPLOYEE, но таблицы EMPLOYEE не будет. Особенности Mapped Superclass: 
+ Должен быть помечен аннотацией @MappedSuperclass или описан в xml файле.
+ Не может использоваться в операциях EntityManager или Query, вместо этого нужно использовать классы-наследники.
+ Не может состоять в отношениях с другими сущностями, т.е. в Entity нельзя создать поле с типом сопоставленного суперкласса.
+ Может быть абстрактным.
+ Не имеет своей таблицы в БД. 
 
Основным недостатком использования сопоставленного суперкласса является то, что полиморфные запросы невозможны, то есть мы не можем загрузить всех наследников Mapped Superclass.  

**Mapped Superclass v.s. Embeddable class**

Сходства:  
+ не являются сущностями и могут иметь все аннотации, кроме @Entity;
+ не имеют своих таблиц в БД;
+ не могут использоваться в операциях EntityManager или Query.  
 
Различия:  
+ MappedSuperclass – это наследование, а Embeddable class – это композиция (экземпляр «части» может входить только в одно целое (или никуда не входить));  
+ Поля из Mapped Superclass могут быть у сущности в одном экземпляре, а полей из Embeddable class может быть сколько угодно (встроив в сущность Embeddable class несколько раз и поменяв имена полей);  
+ В Entity нельзя создать поле с типом сопоставленного суперкласса, а с Embeddable можно и нужно. 

--------
Mapped Superclass - это специальная аннотация в Java Persistence API (JPA), которая служит для определения базового класса с набором атрибутов и методов, которые будут наследовать и использоваться в других сущностях-потомках, которые могут быть связаны с таблицами в базе данных.

Несмотря на то, что класс, аннотированный с @MappedSuperclass, не привязан к определенной таблице базы данных и сам по себе не инстанцируется, он предоставляет общую функциональность и атрибуты для сущностей-наследников. Классы, расширяющие такой Mapped Superclass, становятся JPA сущностями и могут быть аннотированы с @Entity, чтобы легко маппить их на таблицы БД.

Аннотация @MappedSuperclass используется, когда необходимо разделить общие свойства или методы между разными сущностями, но без создания собственной таблицы для базового класса.

Пример:

```java
@MappedSuperclass
public abstract class BaseEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // другие общие атрибуты или методы

}
```

Сущность с наследованием:

```java
@Entity
@Table(name = "sample_entity")
public class SampleEntity extends BaseEntity {

    // атрибуты и методы специфичные для SampleEntity
}
```

В этом примере, сущность SampleEntity будет наследовать атрибуты и методы из базового класса BaseEntity (такие как id). Это может сильно упростить структуру сущностей, если множество сущностей имеют аналогичные атрибуты или методы.

[к оглавлению](#hibernate)

## Какие три стратегии маппинга при наследовании сущностей (Entity Inheritance Mapping Strategies) описаны в JPA?

https://habr.com/ru/articles/337488/

Стратегии  наследования  нужны  для  того,  чтобы  дать  понять  провайдеру (Hibernate)  как  ему  отображать  в  БД  сущности-наследники.  Для  этого  нам  нужно декорировать  родительский  класс  аннотацией  @Inheritance  и  указать  один  из  типов отображения: SINGLE_TABLE, TABLE_PER_CLASS, JOINED.

Следующие  три  стратегии  используются  для  отображения  данных  сущности- наследника и родительской сущности:

+ SINGLE_TABLE. Одна таблица на всю иерархию классов.
+ TABLE_PER_CLASS. Таблица для каждого конкретного класса сущностей.
+ JOINED. Стратегия «соединения», при которой поля или свойства, специфичные для подклассов, отображаются в таблицах этих подклассов, а поля или свойства родительского класса отображаются в таблице родительского класса.

<img width="992" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/03e8e774-8ac2-483f-b3ed-20996cfa1f75">

**TABLE_PER_CLASS** (отдельная таблица для каждого конкретного класса сущностей, использует UNION, потом по обзей таблицк делает выборки)

https://javarush.com/quests/lectures/questhibernate.level15.lecture04 

<img width="787" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/3c4bf5db-27e6-4bfd-9c81-7c5363200ee1">

Каждый класс-наследник имеет свою таблицу.  
 
Во всех таблицах подклассов хранятся все поля этого класса плюс те, которые унаследованы от суперкласса. 

**МИНУСЫ:** 
 
+ Плохая поддержка полиморфизма (polymorphic relationships), т.к. для выборки всех классов иерархии потребуется большое количество отдельных sql-запросов для каждой таблицы-наследника или использование UNION запроса для соединения таблиц всех наследников в одну таблицу.  
+ Повторение одних и тех же атрибутов в таблицах. При TABLE PER CLASS не работает стратегия генератора первичных ключей IDENTITY, поскольку может быть несколько объектов подкласса, имеющих один и тот же идентификатор, и запрос базового класса приведет к получению объектов с одним и тем же идентификатором (даже если они принадлежат разным типам). 

**ПЛЮСЫ:** 
+ Если нужно получить отдельную сущность, то можно обратиться к соответствующей таблице (не нужно искать во всех таблицах). 

**Сохранение и загрузка данных:**

<img width="1151" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/691a290c-4fd4-4787-80b8-2de965e0e122">

**SINGLE_TABLE** (одна таблица на всю иерархию классов) 
 
<img width="1158" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/92bdecc6-a7fb-4da1-9a4d-f0b2856bf4c9">
 
Например, если есть entity Employee c классами-потомками FullTimeEmployee и PartTimeEmployee, то при такой стратегии все FullTimeEmployee и PartTimeEmployee записываются в таблицу Employee, и при этом в таблице появляется дополнительная колонка с именем DTYPE, в которой будут записаны значения, определяющие принадлежность к классу.  

По умолчанию эти значения формируются из имён классов, в этом примере либо «FullTimeEmployee», либо «PartTimeEmployee». Но можно их поменять в аннотации у каждого класса-наследника: @DiscriminatorValue("F"). Если хотим поменять имя колонки, то необходимо указать её новое имя в параметре аннотации у класса-родителя: @DiscriminatorColumn(name=EMP_TYPE).

<img width="1173" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/9b3e14be-d269-4409-b5a9-061fbaad53e0">

Эта стратегия обеспечивает хорошую поддержку полиморфных отношений между сущностями и запросами, которые охватывают всю иерархию классов сущностей: 

<img width="1099" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/6d9c8683-716a-4ea2-860c-16d60e1448d5">

**JOINED** (стратегия соединения) 

<img width="687" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/ff9f0f8f-2c92-4425-af3b-c83845db6ee7">

В этой стратегии корневой класс иерархии представлен отдельной таблицей, а каждый наследник имеет свою таблицу, в которой отображены только поля этого класса-наследника.

То есть таблица подкласса не содержит столбцы для полей, унаследованных от родительского класса, за исключением поля для первичного ключа @Id, который должен быть определен только в родительской таблице.  

Столбец первичного ключа в таблице подкласса служит внешним ключом первичного ключа таблицы суперкласса. Также в таблице родительского класса добавляется столбец DiscriminatorColumn с DiscriminatorValue для определения типа наследника.

<img width="1159" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/9609eeb4-4fd2-42fb-ab34-1e71010ee8e5">

Эта стратегия обеспечивает хорошую поддержку полиморфных отношений, но требует выполнения одной или нескольких операций соединения таблиц при создании экземпляров подклассов сущностей. В глубоких иерархиях классов это может привести к недопустимому снижению производительности. Точно так же запросы, которые покрывают всю иерархию классов, требуют операций соединения между таблицами подклассов, что приводит к снижению производительности: 

<img width="1152" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/df2132f6-379b-439d-a275-13a694c27403">

[к оглавлению](#hibernate)

## Как мапятся Enum`ы?

**По порядковым номерам**

Если мы сохраняем в БД сущность, у которой есть поле-перечисление (Enum), то в таблице этой сущности создаётся колонка для значений этого перечисления и по умолчанию в ячейки сохраняется порядковый номер этого перечисления (ordinal).

<img width="684" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/2417db56-41b1-4b3e-a590-ae89b3dc0fcd">

В JPA типы Enum могут быть помечены аннотацией @Enumerated, которая может принимать в качестве атрибута EnumType.ORDINAL или EnumType.STRING, определяющий, отображается ли перечисление (enum) на столбец с типом Integer или String соответственно.  

@Enumerated(EnumType.ORDINAL) – это значение по умолчанию, говорит о том, что в базе будут храниться порядковые номера Enum (0, 1, 2…). Проблема с этим типом отображения возникает, когда нам нужно изменить наш Enum.  

Если мы добавим новое значение в середину или просто изменим порядок перечисления, мы сломаем существующую модель данных. Такие проблемы могут быть трудно уловимыми, и нам придется обновлять все записи базы данных. 

**По именам**

@Enumerated(EnumType.STRING) означает, что в базе будут храниться имена Enum.  

Так мы можем безопасно добавлять новые значения перечисления или изменять порядок перечисления. Однако переименование значения enum все равно нарушит работу базы данных.  

Кроме того, даже несмотря на то, что это представление данных гораздо более читаемо по сравнению с параметром @Enumerated(EnumType.ORDINAL), оно потребляет намного больше места, чем необходимо. Это может оказаться серьезной проблемой, когда нам нужно иметь дело с большим объемом данных. 

**@PostLoad и @PrePersist**

Другой вариант – это использование стандартных методов обратного вызова из JPA. Можно смапить перечисления в БД и обратно в методах с аннотациями @PostLoad и @PrePersist. 

Аннотация @PostLoad используется для выполнения каких-либо действий сущности после ее загрузки из базы данных. Например, можно установить значения для полей, которые не хранятся в базе данных. Аннотация @PrePersist используется для выполнения каких-либо действий над сущностью перед сохранением ее в базу данных. Например, можно установить дату и время создания для новой сущности.

Идея состоит в том, чтобы в Entity иметь не только поле с Enum, но и вспомогательное поле. 

<img width="622" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/3e31af43-4827-4435-9188-24e143e45b94">

Поле с Enum аннотируем @Transient, а в БД будет храниться значение из вспомогательного поля. Создадим Enum с полем priority, содержащем числовое значение приоритета (см. код ниже).

<img width="514" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/6f6f8f0f-8398-4e6e-9b8c-5b710435fab4">

Здесь добавили метод Priority.of(), чтобы упростить получение экземпляра Priority на основе его значения int. Теперь, чтобы использовать его в классе Article, нужно добавить два атрибута и реализовать методы обратного вызова.

Несмотря на то, что этот вариант дает нам бо́льшую гибкость по сравнению с ранее описанными решениями, он не идеален.

Просто кажется неправильным иметь в entity целых два атрибута, представляющих одно перечисление.  
 
Кроме того, если мы используем этот вариант, мы не сможем использовать значение Enum в запросах JPQL. 

**Converter**

В JPA с версии 2.1 можно использовать Converter для конвертации Enum -а в некое его значение для сохранения в БД и получения из БД. Все, что нужно сделать, это создать новый класс, который реализует интерфейс javax.persistence.AttributeConverter и аннотировать его с помощью @Converter.

Аннотация @Converter используется для конвертации значения атрибута в базу данных и из нее

<img width="1174" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/d457e98a-f74f-4335-bd01-7c838daa6f5c">

Тут установили @Converter(autoApply=true), чтобы JPA автоматически применял логику преобразования ко всем сопоставленным атрибутам типа Category.

В противном случае пришлось бы поместить аннотацию @Converter непосредственно над полем Category у каждой сущности, где оно имеется. В результате в столбце таблицы будут храниться значения: "S", "M" или "T".  

То есть можно просто установить собственные правила преобразования перечислений в соответствующие значения базы данных, если использовать интерфейс AttributeConverter. 

Более того, можно безопасно добавлять новые значения enum или изменять существующие, не нарушая уже сохраненные данные. Это решение просто в реализации и устраняет все недостатки с @Enumerated(EnumType.ORDINAL), @Enumerated(EnumType.STRING) и методами обратного вызова. 

[к оглавлению](#hibernate)

## Как мапятся даты (до Java 8 и старше)? 
 
При работе с датами рекомендуется установить определенный часовой пояс для драйвера JDBC. Таким образом, приложение будет независимым от текущего часового пояса системы.

Другой способ – настроить свойство hibernate.jdbc.time_zone в файле свойств Hibernate, который используется для создания фабрики сессий. Таким образом, можно указать часовой пояс один раз для всего приложения. 

**java.sql**

Hibernate позволяет отображать различные классы даты/времени из Java в таблицах баз данных. Стандарт SQL определяет три типа даты/времени:  
+ DATE представляет календарную дату путем хранения лет, месяцев и дней. Эквивалентом JDBC является java.sql.Date.  
+ TIME представляет время дня и хранит часы, минуты и секунды.  Эквивалентом JDBC является java.sql.Time.  
+ TIMESTAMP хранит как DATE, так и TIME плюс наносекунды.  

Эквивалентом JDBC является java.sql.Timestamp. 

Поскольку эти типы соответствуют SQL, их сопоставление относительно простое. Можно использовать аннотацию @Basic или @Column:

<img width="534" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/dfff2952-5370-4a2b-8d65-61a9d3afe46c">

Далее можно установить соответствующие значения:

<img width="766" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/ef995da0-f32b-4beb-8e45-c0b71f38635e">

Использование типов java.sql для полей сущностей не всегда может быть хорошим выбором. Эти классы специфичны для JDBC и содержат множество устаревших функций.  

Чтобы избежать зависимостей от пакета java.sql, начали использовать классы даты/времени из пакета java.util вместо классов java.sql.Timestamp и java.sql.Time. 

**java.util**

Точность представления времени составляет одну миллисекунду. Для большинства практических задач этого более чем достаточно, но иногда хочется иметь точность повыше. Поскольку классы в данном API изменяемые (не immutable), использовать их в многопоточной среде нужно с осторожностью. В частности java.util.Date можно признать «эффективно» поток безопасным, если вы не вызываете у него устаревшие методы. 

**java.util.Date**

Тип java.util.Date содержит информацию о дате и времени с точностью до миллисекунд. Но так как классы из этого пакета не имели прямого соответствия типам данных SQL, приходилось использовать над полями java.util.Date аннотацию @Temporal, чтобы дать понять SQL, с каким конкретно типом данных она работает.  

<img width="414" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/0a3ddebf-7dfc-4ec1-9745-bad27d869c20">

Для этого у аннотации @Temporal нужно было указать параметр TemporalType, который принимал одно из трёх значений: DATE, TIME или TIMESTAMP, что позволяло указать базе данных с какими конкретными типами данных она работает. 

Тип java.util.Date имеет точность до миллисекунд, и недостаточно точен для обработки SQL-значения Timestamp, который имеет точность вплоть до наносекунд. Поэтому, когда мы извлекаем сущность из базы данных, неудивительно, что в этом поле мы находим экземпляр java.sql.Timestamp, даже если изначально мы сохранили java.util.Date. Но это не страшно, так как Timestamp наследуется от Date. java.util.Calendar  

Как и в случае java.util.Date, тип java.util.Calendar может быть сопоставлен с различными типами SQL, поэтому мы должны указать их с помощью @Temporal. Разница лишь в том, что Hibernate не поддерживает отображение (маппинг) Calendar на TIME:

<img width="512" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/ecf1f03e-9d5c-4ef2-943f-9a8919138f87">

**java.time**

Начиная с Java 8, доступен новый API даты и времени для работы с временными значениями. Этот API-интерфейс устраняет многие проблемы классов java.util.Date и java.util.Calendar.  
Все классы в новом API неизменяемые (immutable) и, как следствие, поток безопасные. Точность представления времени составляет одну наносекунду, что в миллион раз точнее чем в пакете java.util.  

Типы данных из пакета java.time напрямую отображаются (маппятся) на соответствующие типы SQL и поэтому нет необходимости явно указывать аннотацию @Temporal:  
+ LocalDate соответствует DATE.  
+ LocalTime и OffsetTime соответствуют TIME.  
+ Instant, LocalDateTime, OffsetDateTime и ZonedDateTime соответств. TIMESTAMP.

Это означает, что можно пометить эти поля только аннотацией @Basic (или @Column), например:

<img width="474" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/81b273b4-df29-461a-9476-a7f6ab91c041">

Каждый временной класс в пакете java.time имеет статический метод parse() для анализа предоставленного значения типа String с использованием соответствующего формата. Вот как можно установить значения полей сущности:

<img width="1180" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/0458e40f-1d2a-4f44-af71-f2483cc0ad09">

-------------

Java предлагает два класса для работы с датами и временем: java.util.Date и java.util.Calendar. Они были введены в разные времена и имеют разные особенности и ограничения.

java.util.Date:
1. Введён в Java 1.0.
2. Date представляет собой мгновенное значение времени в миллисекундах с 1 января 1970 года в формате UTC (Coordinated Universal Time).
3. Он предоставляет конструкторы и методы для получения и установки даты и времени. Однако многие из этих методов считаются устаревшими (deprecated), так как они вводили путаницу и неэффективность, и были заменены классом Calendar.

java.util.Calendar:
1. Введён в Java 1.1.
2. Calendar представляет собой абстрактный класс и предоставляет методы для работы с датами, временем и календарными системами.
3. Эта API более гибкая и мощная. Она позволяет учитывать часовые пояса, выполнять арифметику даты и др.
4. Calendar использует различные наследуемые классы (как например, GregorianCalendar для григорианского календаря) для операций с датой и временем.

Несмотря на это, стоит учитывать, что в Java 8 была представлена новая API для работы с датой и временем (java.time), которая служит современной альтернативой для java.util.Date и java.util.Calendar. Java.time предоставляет набор хорошо продуманных классов, таких как LocalDateTime, LocalDate, LocalTime, ZonedDateTime и других, которые упрощают работу с датами и временем, улучшая читаемость кода и обеспечивая корректное поведение при работе с часовыми поясами и переходом на летнее время.

-----------------

В Java 8 была добавлена новая библиотека для работы с датами и временем - java.time. Она предоставляет более удобное и безопасное API для работы с датами и временем, чем старая библиотека java.sql.

Существует несколько причин, почему java.time лучше подходит для работы с датами в БД:

1. java.sql предоставляет только несколько типов данных для хранения и работы с датами (например, java.sql.Date, java.sql.Time, java.sql.Timestamp), в то время как java.time предоставляет множество типов данных для различных нужд (например, LocalDate, LocalDateTime, ZonedDateTime).
2. java.time более безопасна для использования, потому что она строго типизирована и не допускает ошибок, связанных с приведением типов.
3. java.time включает в себя более широкий набор функций и методов для работы с датами и временем, что упрощает их обработку и форматирование.
4. Многие СУБД, такие как MySQL, PostgreSQL и Oracle, поддерживают тип данных TIMESTAMP WITH TIME ZONE, который можно использовать для хранения даты и времени в соответствии с java.time. 

Таким образом, java.time является более современной и удобной библиотекой для работы с датами и временем, и часто используется вместо java.sql для работы с БД.

[к оглавлению](#hibernate)

## Как Hibernate работает с разными типами? 
 
Подробно о типах Hibernate читаем по ссылке: http://hibernate-refdoc.3141.ru/ch6.Types 

Пользовательские типы в Hibernate: https://habr.com/ru/articles/91328/
 
Для экземпляров классов ТИПОМ считается название класса, например при объявлении экземпляра TextView используется TextView tv = findViewById(R.id.some_id); 

<img width="1169" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/c0853686-ca46-4796-bc19-f90ac339fda1">

Тип Hibernate описывает различные аспекты поведения типа Java, такие как «как проверяется равенство?» или «как клонируются значения?». 

<img width="925" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/801b4857-65a8-4e57-964c-8e253ac50285">

Есть также базовые типы (они же основные), встраиваемые типы и коллекции. 

<img width="955" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/9f9ab6e5-f525-4580-876d-0929a4f49614">

Базовые типы (любые типы с реализацией Serializable), для которых и используется аннотация @Basic, соответствуют одному столбцу в БД. Эта аннотация НЕ обязательная. 

<img width="940" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/08120d4c-b7d8-4e31-8ff7-2f301598bf5a">

[к оглавлению](#hibernate)

## Как сохранять в базе данных коллекции базовых типов?

Если у сущности есть поле с коллекцией, то мы привыкли ставить над ним аннотации 
@OneToMany либо @ManyToMany. Но данные аннотации применяются в случае, когда это коллекция других сущностей (entities).  
 
Но что, если у сущности коллекция не других сущностей, а базовых или встраиваемых (embeddable) типов, то есть коллекция элементов? См. Как Hibernate работает с разными типами? 
 
Для этих случаев в JPA имеется специальная аннотация @ElementCollection, которая указывается в классе сущности над полем коллекции базовых или встраиваемых типов.  
 
Все записи коллекции хранятся в отдельной таблице, то есть в итоге получаем ДВЕ таблицы:  
•одну для сущности 
•вторую для коллекции элементов  
 
Конфигурация для таблицы коллекции элементов указывается с помощью аннотации @CollectionTable, которая используется для указания имени таблицы коллекции и @JoinColumn, который ссылается на первичную таблицу. 

<img width="1034" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/1ecd5885-6df7-40fa-bcd6-076f72e637d1">

Аннотация @ElementCollection похожа на отношение @OneToMany, за исключением того, что целью являются базовые и встраиваемые типы, а не сущности.  
 
Можно использовать аннотации @AttributeOverrides и @AttributeOverride для настройки отображения в таблице полей базовых или встраиваемых типов.  
 
Коллекции могут иметь тип java.util.Map, которые состоят из ключа и значения. Для этого типа коллекций применяются следующие правила:  
+ Ключ или значение Map может быть базовым типом языка программирования Java, встраиваемым классом или сущностью.
+ Если значение Map является встраиваемым классом или базовым типом, используйте аннотацию @ElementCollection  

<img width="680" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/66c9eb80-65df-47dd-9751-11883f169bbe">

+ Если значение Map является сущностью, используйте аннотацию @OneToMany или @ManyToMany 
+ Использовать тип Map только на одной стороне двунаправленной связи. 

Аннотация @MapKeyColumn позволяет настроить столбец «ключ» в таблице Map. Аннотация @Column позволяет настроить столбец «значение» в таблице Map.  

Использование коллекций элементов имеет один большой недостаток: элементы коллекции не имеют идентификатора, и Hibernate не может обращаться индивидуально к каждому элементу коллекции. 

Когда нужно добавить новый объект в коллекцию или удалить из коллекции существующий элемент, Hibernate удаляет все строки из таблицы элементов и вставляет новые строки по одной для каждого элемента в коллекции.  

То есть при добавлении одного элемента в коллекцию, Hibernate не добавит одну строку в таблицу коллекции, а очистит её и заполнит по новой всеми элементами.  
Поэтому коллекции элементов следует использовать только для очень маленьких коллекций, чтобы Hibernate не выполнял слишком много операторов SQL. Во всех других случаях рекомендуется использовать коллекции сущностей с @OneToMany 

[к оглавлению](#hibernate)

## Какие есть виды связей (маппинг ассоциаций)? 

<img width="1046" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/4afa223a-439a-4484-8b3c-36b0a74662a9">

**Первое слово относится к классу Entity, второе к полю в этом классе (ассоциации).** 
 
Например, много отзывов об одной книге. В классе Review над полем book будет аннотация @ManyToOne.  А в классе Book аннотация @OneToMany над полем-коллекцией reviews. 
 
Направления в отношениях сущностей: unidirectional и bidirectional 
 
Однонаправленные (uni-directional associations): одна сторона знает про отношения, а другая нет. Однонаправленные отношения имеют только одного владельца связи. 

<img width="1046" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/d4a15e6d-4192-41ad-95f6-b7c232dfd0bd">

<img width="1032" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/aaaba065-52ad-4309-8be0-f2182c50ca4c">

**Атрибут моделирует ассоциацию, а аннотация объявляет тип отношения.**
 
Маппинг ассоциации зависит только от исходной таблицы (source table, владелец связи) и целевого объекта (target entity). Если у отдела (один) есть набор, коллекция сотрудников (много), а у сотрудника нет собственного отдела, тогда используем unidirectional @OneToMany.  
 
В этом случае @JoinColumn должен быть в классе ВЛАДЕЛЬЦА СВЯЗИ (department).  У нас это Департамент, т.к. на него ссылается внешний ключ класса Employees.  
 
Двунаправленные (bi-directional associations): каждая сущность имеет поле, которое ссылается на другую сущность. Через это поле код первой сущности может получить доступ ко второй сущности, находящейся на другой стороне отношений.  
 
Если у первой сущности есть поле, ссылающееся на вторую сущность, и наоборот, то в этом случае говорят, что обе сущности знают друг о друге, и что они состоят в двунаправленных отношениях.

<img width="1017" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/5635427a-8b4b-4130-922a-217ce3a6a52d">

<img width="986" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/ece9b30c-42cd-410d-a4d9-bfad1bec4c1d">

[к оглавлению](#hibernate)

## Что такое владелец связи?

Односторонние и двусторонние отношения в Hibernate: https://habr.com/ru/articles/542328/

Обязанности владельца связи в JPA заключаются в следующем:

1. Создание и обновление внешних ключей: Владелец связи отвечает за создание и обновление значений внешних ключей, которые связывают связанные сущности. В вашем случае, `Employee` будет создавать и обновлять внешний ключ на `Department`.

2. Каскадное удаление и обновление: Владелец связи также управляет каскадными операциями удаления и обновления. Это означает, что при удалении или обновлении владельца связи, JPA автоматически может удалить или обновить связанные сущности. В вашем случае, если удалить `Employee`, JPA может в зависимости от настроек также удалить или обновить связанный `Department`.

3. Контроль операций сохранения и обновления: Владелец связи определяет порядок сохранения и обновления связанных сущностей. Например, если вы сохраняете `Employee`, JPA сначала сохранит `Employee`, а затем автоматически сохранит связанный `Department`.

В общем, владелец связи в JPA имеет больше контроля над отношениями и обновлением внешних ключей. Это обеспечивает целостность данных и координирует взаимодействие между связанными сущностями при выполнении операций сохранения и обновления.

В отношениях между двумя сущностями всегда есть одна владеющая сторона, а владеемой может и не быть, если это однонаправленные отношения.

**Владелец связи и владеемый**

По сути, у кого есть внешний ключ на другую сущность - тот и владелец связи. То есть,  если  в  таблице одной  сущности  есть  колонка,  содержащая внешние  ключи  от  другой сущности, то первая сущность признаётся владельцем связи, вторая сущность - владеемой.

В однонаправленных отношениях сторона, которая имеет поле с типом другой сущности, является владельцем этой связи по умолчанию, например:

```java
@Entity
public class LineItem {

    @Id
    private Long id

    @OneToOne
    private Product product;

}

@Entity
public class Product {

    @Id
    private Long id

    private String name;

    private Double price;

}
```
В этом примере владельцем является сущность LineItem, так как она имеет поле типа  Product.  А  Product  ничего  не  знает  о  LineItem,  так  как  не  имеет  такого  поля.

Получается, что в таблице LineItem есть колонка с внешним ключом на таблицу Product, а в таблице Product колонки LineItem нет.

Двунаправленные отношения имеют как сторону-владельца, так и владеемую сторону:

```java
@Entity
public class CustomerOrder {

    @Id
    private Long id

    @OneToMany(mappedBy = \"customerOrder\")
    private Set<LineItem> lineItems = new HashSet<>();

}

@Entity
public class LineItem {

    @Id
    private Long id

    @OneToOne
    private Product product;  37

    @ManyToOne
    private CustomerOrder customerOrder;

}
```
В данном примере владельцем связи является сторона LineItem, потому что в таблице LineItem есть колонка с внешними ключами на таблицу CustomerOrder. Да и по правилам Java, сторона @ManyToOne всегда является владельцем связи, а элемент mappedBy определяет поле в объекте, который является владельцем отношения.

Тут так и получается: сторона @ManyToOne - LineItem; элемент mappedBy определяет поле \"customerOrder\" в объекте LineItem.

Хотя  интуитивно  и  кажется,  что  владельцем  связи  является  сущность CustomerOrder,  ведь  CustomerOrder  -  это  заказ  нашего  покупателя,  состоящий  из позиций (LineItem), и, вроде как, заказ главнее одной позиции, но нет. LineItem в своей таблице владеет ключами от CustomerOrder, поэтому LineItem и является владельцем. 

Владельца  связи  и  владеемого  легко  спутать  с  родителем  отношения  и ребенком.  В  нашем  случае  CustomerOrder  является  владеемым  и  одновременно родителем в отношениях, а LineItem является владеющим и одновременно ребенком в отношениях.

**Родительская сущность (таблица)** - это  сущность  (таблица),  на  которую  ссылается  внешний  ключ  из  дочерней сущности (таблицы).

**Дочерняя сущность (таблица)** - это  сущность  (таблица),  в  которой  есть  колонка  с  внешним  ключом, ссылающимся на родительскую сущность (таблицу).

------------

<img width="1003" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/02c96a6a-6189-4e05-a1c1-e7715e69e601">

Связи бывают однонаправленными и двунаправленными: unidirectional и bidirectional. 

Обозначения на UML: стрелка с направлением, либо одна соединительная линия. 

В реляционных БД связи осуществляются с использованием внешнего ключа (1-1) или таблицы соединения (1-N, N-N). 
 
Множественность связи (или кардинальность):

Связь с более чем одним объектом (Many) является типом коллекции: List, Set, Map.  
 
**Владелец связи.**

При однонаправленной связи владелец – это инициатор связи, при двунаправленной владельца надо явно указывать. 
 
Общий принцип: на КОГО ссылаются, тот и владелец связи. 
 
При однонаправленной связи настраиваем параметры внешнего ключа таблицы во владеющей сущности. 
 
Если связь двунаправленная, то владеющая сторона определяет параметры, а противоположная указывает в поле mappedBy имя соответствующего параметра владеющей связью сущности (атрибут mappedBy ВСЕГДА на ведомой стороне). 
 
Каждая из связей однонаправленная или двунаправленная может быть одним видом отношений. 
  
Все возможные виды связей помнить не нужно (многие очень похожи друг на друга), поэтому достаточно запомнить лишь некоторые:

<img width="352" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/59431428-66a0-4d93-b406-6eaa8ab3c989">

Разумно правильно определять тип загрузки сущности (fetch = LAZY or EAGER). 
 
По дефолту: 
+ Для @OneToOne, @ManyToOne fetch = EAGER (т.к. загружается только одна сущность) 
+ Для @OneToMany, @ManyToMany fetch = LAZY (оптимизация, производительность) 
 
Можно для сущности задавать упорядочивание элементов-коллекций: 
+ @OrderBy(attribute_name_1 DESC, attribute_name_2 ASC).
  
Упорядочение при выборке согласно указанным атрибутам сущности 
+ @OrderColumn(name = "column_index_name").  

Коллекция будет упорядочена в соответствии с индексом элементов, записанных в отдельном столбце.  Есть потеря производительности, т.к. данный столбец надо держать актуальным. 

[к оглавлению](#hibernate)

##  Что такое каскады?

Если посмотреть документацию, то CascadeType – это Enum, в котором перечисления соответствуют этапам ЖЦ Entity:

<img width="282" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/a1aa08f5-9111-462d-be34-380eddbde29d">

Как работают каскады, что за кулисами? 

JPA позволяет распространять операции с сущностями (например, persist или remove) на связанные сущности.  Это означает, что при включенном каскадировании если сущность – ВЛАДЕЛЕЦ СВЯЗИ переходит в одно из своих состояний, то зависимая сущность без явных команд перейдёт в то же состояние (например, будет удалена):

<img width="748" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/957d4ba1-b7d2-4365-9a54-b3e2b1ae6584">

Как правило, каскадные операции применяются от владельца связи к зависимым сущностям, но они могут распространяться и в обратном направлении (хотя это совсем не нужно). Главное условие: между ними должно быть двунаправленное отношение, иначе каскадные операции выполняются только в одном направлении. 

Каскадирования  можно  добиться,  указав  у  любой  из  аннотаций  @OneToOne, @ManyToOne, @OneToMany, @ManyToMany элемент cascade и присвоив ему одно или несколько значений из перечисления CascadeType (ALL, DETACH, MERGE, PERSIST, REFRESH, REMOVE).

[к оглавлению](#hibernate)

## Какие два типа fetch стратегии в JPA вы знаете? 

Для чтения связанных объектов из БД используются две стратегии загрузок (fetch type): EAGER и LAZY. В первом случае объекты коллекции сразу загружаются в память, во втором случае — только при обращении к ним. Оба этих подхода имеют достоинства и недостатки.

В случае FetchType.EAGER в памяти будут находиться все загруженные объекты, даже если нужен только один объект из десятка (сотен/тысяч). При использовании данной стратегии необходимо быть внимательным, поскольку при загрузке какого-нибудь корневого объекта, который связан со всеми остальными объектами и коллекциями, можно случайно попытаться загрузить в память и всю базу. 

Согласно стратегии FetchType.LAZY связанные объекты загружаются только по мере необходимости, т.е. при обращении. Но при этом требуется, чтобы соединение с базой (или транзакция) сохранялись. Если точно, то требуется, чтобы объект был attached. Поэтому для работы с lazy объектами тратится больше ресурсов на поддержку соединений. 

Тип связи и тип загрузки по умолчанию:

<img width="589" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/c76ca723-361a-4881-b69e-2b9eeab70513">

---------
В Java Persistence API (JPA) существует два типа стратегий загрузки (fetching strategies), которые определяют как и когда ассоциированные сущности и коллекции будут загружены из базы данных. Эти стратегии контролируют механизмы загрузки данных при работе с объектно-реляционным отображением (ORM).

1. Eager (жадная стратегия):
Жадная загрузка подразумевает получение всех ассоциированных данных вместе с основным объектом. При использовании стратегии eager все привязанные объекты и коллекции будут немедленно загружены, когда основной объект будет извлечен из базы данных.

Например, если у вас есть сущность "User" и у нее есть ассоциация Many-to-One с сущностью "Address", то при использовании стратегии eager загрузки, при извлечении пользователя из базы данных, соответствующий адрес также будет загружен из базы данных. Таким образом, все ассоциированные данные будут доступны без дополнительных запросов к базе данных, но может возникнуть проблема производительности, если ассоциированные данные очень большие или их много.

2. Lazy (ленивая стратегия):
Ленивая загрузка подразумевает отложенное получение ассоциированных данных по требованию. Когда объект сущности извлекается из базы данных, только его собственные поля (не ассоциированные данные) будут загружены. Ассоциированные объекты или коллекции будут загружены только при доступе к ним в коде. 

Например, если у вас есть сущность "User" и у нее есть ассоциация Many-to-One с сущностью "Address", при использовании ленивой стратегии, объект "Address" будет загружен только тогда, когда вы попытаетесь получить доступ к полю, связанному с адресом. Это позволяет оптимизировать производительность и снизить количество запросов к базе данных, но может привести к проблемам N+1 запросов (когда каждый объект в коллекции требует дополнительного запроса для получения своих ассоциированных данных).

Выбор между стратегиями eager и lazy зависит от конкретных требований вашего приложения. Если вы знаете, что всегда будете использовать ассоциированные данные, и они не очень большие, то можете использовать стратегию eager, чтобы избежать дополнительных запросов к базе данных. Если эти данные редко используются или могут быть большими, то лучше выбрать стратегию lazy для оптимизации производительности.

[к оглавлению](#hibernate)

## Для чего нужна аннотация Basic? 
 
Аннотация @Basic для поля или свойства означает, что это Basic Type* (базовый тип), и Hibernate должен использовать стандартное сопоставление для его сохранения. Также в параметрах аннотации можно указать fetch стратегию доступа к полю и является ли это поле обязательным или нет. Однако, это необязательная аннотация.  
 
* JPA поддерживает различные типы данных Java в качестве сохраняемых полей объекта, часто называемых базовыми типами. К ним относятся примитивы Java и их классы-оболочки, String, java.math.BigInteger и java.math.BigDecimal, различные доступные классы даты и времени, перечисления и любой другой тип, который реализует интерфейс java.io.Serializable.

----------
В контексте Hibernate, аннотации Basic используются для определения базовых атрибутов для свойств сущностей. Аннотация Basic указывает, что свойство является основным (basic), то есть оно не является отображением отношений или составных компонентов, а представляет базовое значение свойства. 

Аннотация Basic может использоваться для свойств, которые имеют простые типы данных, такие как числа, строки, даты и т. д. Она позволяет определить информацию о маппинге свойства на столбец базы данных, его название, тип данных и дополнительные атрибуты, такие как уникальность, возможность быть нулевым и т. д.

Пример использования аннотации Basic для свойства сущности:

```java
@Entity
public class Product {
    @Id
    private Long id;

    @Basic
    private String name;

    // остальные свойства и методы сущности
}
```

В данном примере аннотация Basic используется для свойства name класса Product. Она указывает Hibernate, что это свойство является базовым и должно быть отображено в столбец таблицы базы данных с аналогичным именем. Аннотации Basic можно комбинировать с другими аннотациями для более точной настройки маппинга свойств сущностей.

[к оглавлению](#hibernate)

## Для чего нужна аннотация Column? 
 
Аннотация говорит к какому именно столбцу в таблице БД мы привязываем поле класса. 
 
Аннотация @Column сопоставляет поле класса столбцу таблицы, а её атрибуты определяют поведение в этом столбце, используется для генерации схемы базы данных. 

Атрибут nullable аннотации @Column указывает, может ли соответствующий столбец в таблице быть null. 

Аннотация @Column позволяет указать имя столбца в таблице и ряд других свойств:  insertable/updatable – можно ли добавлять/изменять данные в колонке (by default = true); length – длина, для строковых типов данных, по умолчанию 255 символов. 

--------------------

Аннотация `@Column` позволяет настраивать различные атрибуты столбца, такие как имя столбца, тип данных, длина, ограничения на значения и т.д. Путем использования этой аннотации вы можете контролировать, как данные из этого поля класса будут сохраняться и извлекаться из базы данных.

Это позволяет ORM-фреймворку автоматически генерировать и выполнять SQL-запросы, создавать таблицы и осуществлять маппинг полей класса на столбцы базы данных, учитывая указанные атрибуты столбцов.

[к оглавлению](#hibernate)

## Для чего нужна аннотация Access?  
 
Аннотация определяет тип доступа (access type) для класса entity, суперкласса, embeddable или отдельных атрибутов, то есть как JPA будет обращаться к атрибутам 
entity, как к полям класса (FIELD, по умолчанию) или как к свойствам класса (PROPERTY), имеющим гетеры (getter) и сеттеры (setter). 

<img width="1023" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/cbb964c2-c03e-453d-8623-9a9a116aae4e">

-----------
Аннотация Access в Hibernate используется для указания доступа к полям или свойствам класса при выполнении операций с базой данных. 

При работе с Hibernate существует два способа доступа к полям или свойствам класса: полями (field access) и свойствами (property access). 

Аннотация Access позволяет контролировать, как Hibernate будет получать и устанавливать значения полей или свойств класса. С ее помощью можно указать, будет ли Hibernate использовать прямой доступ к полям или через методы-сеттеры и геттеры.

Примеры использования аннотации Access:

1. Доступ через поля:
```java
@Entity
@Access(AccessType.FIELD)
public class MyClass {
    @Id
    private Long id;
    
    private String name;
    
    //...
}
```

2. Доступ через свойства:
```java
@Entity
@Access(AccessType.PROPERTY)
public class MyClass {
    private Long id;
    
    private String name;
    
    @Id
    @GeneratedValue
    public Long getId() {
        return id;
    }
    
    public void setId(Long id) {
        this.id = id;
    }
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    //...
}
```

При указании AccessType.FIELD Hibernate будет обращаться к полям напрямую, игнорируя геттеры и сеттеры. При указании AccessType.PROPERTY Hibernate будет использовать геттеры и сеттеры для доступа к данным.

Выбор между доступом через поля или свойства зависит от организации кода и требований приложения. Аннотация Access позволяет гибко настроить способ доступа к данным в Hibernate.

[к оглавлению](#hibernate)

## Для чего нужна аннотация Cacheable? 
 
Cacheable — позволяет включить или выключить использование кэша второго уровня (second-level cache) для данного Entity (если провайдер JPA поддерживает работу с кешированием и настройки кэша (second-level cache) стоят как ENABLE_SELECTIVE или DISABLE_SELECTIVE.  
Аннотация @Cacheable размещается над классом Entity. Её действие распространяется на эту сущность и её наследников, если они не определили другое поведение. 

------------
Аннотация `@Cacheable` в контексте Hibernate используется для указания, что сущность (класс) может быть кэширована. Кэширование является одним из способов оптимизации доступа к данным в базе данных.

Когда сущность помечена аннотацией `@Cacheable`, Hibernate сохраняет ее экземпляры в кэше при выполнении запросов к базе данных. Это позволяет сократить количество обращений к базе данных во время повторных запросов.

Для того чтобы использовать кэширование сущностей в Hibernate, необходимо настроить источник кэша, такой как реализация интерфейса `org.hibernate.cache.CacheProvider`. Это может быть, например, сторонний кэш, такой как Ehcache или Infinispan.

Кроме того, при использовании аннотации `@Cacheable` можно задать дополнительные параметры, такие как имя региона кэша или время жизни элемента в кэше. Например:

```java
@Entity
@Cacheable
@Cache(region = "myEntityCache", usage = CacheConcurrencyStrategy.READ_WRITE)
public class MyEntity {
    // поля и методы сущности
}
```

В данном примере сущность `MyEntity` будет кэшироваться в регионе с именем "myEntityCache" с стратегией кэширования `READ_WRITE`.

Использование `@Cacheable` может значительно повысить производительность приложения, уменьшая количество запросов к базе данных и ускоряя доступ к данным.

[к оглавлению](#hibernate)

## Каких провайдеров кэша второго уровня знаешь? 

Ehcache и Infinispan - это две популярные системы кэширования, которые позволяют улучшить производительность приложений, сохраняя данные в определенном хранилище для более быстрого доступа.

Ehcache:
Ehcache - это открытая библиотека кэширования, которая предоставляет простой и легковесный способ кэширования данных в памяти. Он позволяет разработчикам добавлять кэширование в свои приложения, что помогает значительно сократить нагрузку на базу данных и улучшить отзывчивость системы.

Ehcache работает путем сохранения данных в памяти в виде ключ-значение пар. Когда приложение запрашивает данные, Ehcache проверяет наличие данных в кэше и, если данные найдены, возвращает их без обращения к источнику данных. Если данных нет в кэше, Ehcache загружает их из источника данных (например, базы данных) и сохраняет в кэше для будущих запросов.

Ehcache поддерживает различные стратегии вытеснения для управления памятью и временем жизни данных в кэше. Он также предлагает возможность распределенного кэширования, позволяя развернуть кэш на нескольких узлах и синхронизировать данные между ними.

Infinispan:
Infinispan - это распределенная платформа кэширования данных, которая предназначена для обработки больших объемов данных и предлагает расширенные функциональные возможности в сравнении с Ehcache. Infinispan может быть использован как локальный кэш в рамках одного JVM, так и как распределенный кэш на нескольких узлах.

Infinispan поддерживает не только кэширование в памяти, но также может сохранять данные на диске или в базе данных, обеспечивая более долговременное хранилище. Он также предоставляет возможность репликации и инвалидации (invalidation) данных между узлами, что позволяет поддерживать согласованность данных в распределенной среде.

Infinispan предоставляет механизмы для масштабирования и управления кэшем, такие как разделение данных на фрагменты (шардирование) и автоматическое перераспределение данных при добавлении или удалении узлов в кластере.

Отличия и схожесть:
1. Модель данных: Оба Ehcache и Infinispan используют модель ключ-значение для хранения данных в кэше.

2. Распределенность: Ehcache предлагает распределенное кэширование, но не имеет таких мощных механизмов масштабирования и управления распределенным кэшем, как Infinispan.

3. Хранилище данных: Ehcache обычно хранит данные только в оперативной памяти, в то время как Infinispan может сохранять данные на диске или в базе данных.

4. Функциональность: Infinispan предлагает более продвинутые функциональные возможности, такие как репликация, инвалидация данных, масштабирование кэша и управление транзакциями, в то время как Ehcache ориентирован на простоту и легковесность.

5. Зависимости: Ehcache является отдельной библиотекой, которую можно легко интегрировать в приложение, в то время как Infinispan является достаточно сложной платформой с большим количеством зависимостей и требует настройки и установки.

В целом, Ehcache хорошо подходит для простых кэширующих задач, где требуется легковесное решение, в то время как Infinispan предлагает более расширенный функционал и подходит для более сложных и масштабируемых сценариев кэширования. Выбор между ними зависит от требований и потребностей конкретного приложения.

-------------

https://habr.com/ru/articles/268747/

В Hibernate существует четыре стратегии одновременного доступа к объектам в кэше: 
 
+ Read-only (только чтение) 
+ Read-write (чтение-запись) 
+ Nonstrict-read-write (не строгое чтение-запись) 
+ Transactional (транзакционное) 
 
См. также вопрос: как работать с кэшем второго уровня? 

Чем менее строгую стратегию для кэша вы выбираете, тем большая производительность у кэша второго уровня. Hibernate имеет стратегию кэша по умолчанию, для этого нужно использовать в файле настроек hibernate.cfg.xml свойство:  hibernate.cache.default_cache_concurrency_strategy  

Например, сделаем стратегию кэша по умолчанию read-write: 

<property name="hibernate.cache.default_cache_concurrency_strategy">read-write</property> 

Рассмотрим несколько известных кэш провайдеров: какие стратегии они поддерживают? 

<img width="1022" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/8753a9ab-32f4-4dd6-800c-71a51ee23e15">

---------
В контексте Java Persistence API (JPA) кэш второго уровня используется для ускорения доступа к данным из базы данных. Он представляет собой промежуточное хранилище данных, расположенное между базой данных и приложением, и предоставляет механизм кэширования для сущностей или запросов.

Существует несколько популярных провайдеров кэша второго уровня JPA, которые широко используются в индустрии. Давайте рассмотрим некоторые из них подробнее:

1. Ehcache: Ehcache является одним из наиболее популярных провайдеров кэша второго уровня. Он прост в использовании и хорошо поддерживается в экосистеме Java. Ehcache предлагает механизм кэширования на основе ключ-значение и поддерживает разные стратегии кэширования, такие как LRU (Least Recently Used), LFU (Least Frequently Used), FIFO (First In, First Out) и т.д. Этот провайдер легко интегрируется с JPA через API-интерфейс, и его настройка достаточно гибка.

2. Infinispan: Infinispan является мощным и расширяемым фреймворком кэширования, который можно использовать в качестве провайдера кэша второго уровня для JPA. Он обеспечивает высокую скорость работы и отличается от других провайдеров механизмом распределенного кэширования. Infinispan также поддерживает разные стратегии кэширования и предоставляет широкий набор функций для управления кэшем и его конфигурации.

3. Hazelcast: Hazelcast - это еще один провайдер кэша второго уровня, который предлагает распределенное кэширование и широкий набор функций. Он позволяет создавать кластеризованные кэши, что позволяет распределить данные по нескольким узлам для повышения масштабируемости и доступности приложения. Hazelcast также предоставляет возможность кэширования разных типов данных, таких как карты (map), многоуровневые кэши и т.д.

4. Apache Ignite: Apache Ignite - это открытая платформа, которая можно использовать в качестве провайдера кэша второго уровня для JPA. Ее главная функциональность - это распределенное кэширование и вычисления. Ignite поддерживает разные алгоритмы кэширования, распределенные транзакции и предоставляет возможность выполнения SQL-запросов непосредственно на кэшированных данных.

Это лишь несколько примеров популярных провайдеров кэша второго уровня для JPA. Каждый из них имеет свои особенности, функциональные возможности и требования к настройке. При выборе провайдера кэша второго уровня следует учитывать свои потребности, требования к масштабируемости, распределенности, производительности и другие факторы, которые важны для вашего приложения.

[к оглавлению](#hibernate)

## Как смапить составной ключ? 
 
Составной первичный ключ, также называемый составным ключом, представляет собой комбинацию из двух или более столбцов для формирования первичного ключа таблицы. В соответствии с JPA, допустимые типы атрибутов для первичного ключа:  
+ примитивные типы и их обертки 
+ строки 
+ BigDecimal и BigInteger 
+ java.util.Date и java.sql.Date 
 
В JPA есть требования к составному ключу:  
+ составной КЛЮЧ должен быть представлен классом первичного ключа, при этом используется одна из двух аннотаций: @IdClass и @EmbeddedId;  
+ КЛАСС первичного ключа должен быть public и иметь public конструктор без аргументов;  
+ КЛАСС первичного ключа должен имплементировать маркерный интерфейс Serializable; 
+ КЛАСС первичного ключа должен иметь методы equals и hashCode;  
+ АТРИБУТЫ, представляющие поля составного ключа, могут быть базовыми, составными и @ManyToOne, но НЕ могут быть коллекциями или @OneToOne. 

Однако, первое правило имеется только в JPA.  

Hibernate позволяет определять составные идентификаторы без «класса первичного ключа» с помощью нескольких атрибутов с аннотацией @Id. 

**@IdClass**

Допустим, есть таблица Account, в ней два столбца: accountNumber и accountType, которые формируют составной ключ. Чтобы обозначить оба этих поля как части составного ключа мы должны создать класс, например, AccountId с этими полями: 

<img width="1053" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/885f33c7-e163-4e33-9ad8-e217e4914e7e">

Затем нужно аннотировать сущность Account аннотацией @IdClass и объявить поля из класса AccountId в entity Account с такими же именами и аннотировать их @Id 

<img width="608" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/6dfa9670-fd9e-4781-8306-c63e14534131">

**@EmbeddedId** 

Является альтернативой аннотации @IdClass. Рассмотрим пример: необходимо сохранить информацию о книге с заголовком и языком в качестве полей Primary Key. 
 
В этом случае класс первичного ключа, BookId, должен быть аннотирован @Embeddable. 
 
Затем нужно встроить этот класс в сущность Book, используя @EmbeddedId. 

<img width="1098" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/e6c74f45-e169-4734-a258-fe619a0e7cf7">

**@IdClass v.s. @EmbeddedId**

C аннотацией @IdClass пришлось указывать столбцы дважды - в AccountId и в Account. Но с @EmbeddedId мы этого не сделали; 

JPQL-запросы с @IdClass проще. С @EmbeddedId, чтобы получить доступ к полю, нужно из сущности обратиться к встраиваемому классу и потом к его полю:

<img width="1096" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/f214adc9-6c47-4d0e-b9bb-369c3612579c">

@EmbeddedId более подробна, чем @IdClass, поскольку можно получить доступ ко всему объекту первичного ключа, используя метод доступа к полю в классе-сущности. Это также дает четкое представление о полях, которые являются частью составного ключа, поскольку все они агрегированы в классе, который доступен только через метод доступа к полям;  

@IdClass может быть предпочтительным выбором по сравнению с @EmbeddedId в ситуациях, когда класс составного первичного ключа поступает из другого модуля или устаревшего кода, а также когда невозможно его изменить, например, чтобы установить аннотацию @EmbeddedId. Для таких сценариев, когда нельзя изменить класс составного ключа, аннотация @IdClass является единственным выходом; 

Если нужно получить доступ к частям составного ключа по отдельности, можно использовать @IdClass, но в тех местах, где часто используется полный идентификатор в качестве объекта, @EmbeddedId предпочтительнее. 

---------
Для смаппинга (отображения) составного ключа в JPA (Java Persistence API) можно использовать аннотацию `@EmbeddedId` или `@IdClass`. Оба варианта позволяют определить составной ключ в сущности и установить соответствующие связи с полями класса.

Вариант с `@EmbeddedId`:
1. Создайте класс, который будет представлять составной ключ. Этот класс должен иметь аннотацию `@Embeddable` и содержать все поля, составляющие ключ.
2. В классе сущности, которую вы хотите смаппить, создайте приватное поле, используя созданный класс составного ключа, и пометьте его аннотацией `@EmbeddedId`.
3. Добавьте getter и setter для поля с составным ключом.

Пример кода для смаппинга составного ключа с использованием `@EmbeddedId`:

```java
@Embeddable
public class CompositeKey implements Serializable {
    private Long field1;
    private String field2;
    // Добавьте конструкторы, equals, hashCode и геттеры/сеттеры
}

@Entity
public class EntityWithCompositeKey {
    @EmbeddedId
    private CompositeKey compositeKey;
    // Добавьте остальные поля и связи
    // Добавьте геттеры/сеттеры
}
```

Вариант с `@IdClass`:
1. Создайте класс, который будет представлять составной ключ. Этот класс должен содержать все поля, составляющие ключ.
2. В классе сущности, которую вы хотите смаппить, определите поля, составляющие ключ, и пометьте их аннотацией `@Id`.
3. Укажите класс составного ключа с помощью аннотации `@IdClass` над классом сущности.

Пример кода для смаппинга составного ключа с использованием `@IdClass`:

```java
public class CompositeKey implements Serializable {
    private Long field1;
    private String field2;
    // Добавьте конструкторы, equals и hashCode
}

@Entity
@IdClass(CompositeKey.class)
public class EntityWithCompositeKey {
    @Id
    private Long field1;
    
    @Id
    private String field2;
    
    // Добавьте остальные поля и связи
    // Добавьте геттеры/сеттеры
}
```

Оба подхода позволяют смаппить составной ключ в JPA. Выбор между ними зависит от ваших предпочтений и требований.

[к оглавлению](#hibernate)

## Для чего нужна аннотация ID? 
 
@Id определяет простой (не составной) первичный ключ, состоящий из одного поля. 

<img width="1080" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/9d0d3b20-b2f0-4a71-9814-4bf9aa934bb3">

В соответствии с JPA, допустимые типы атрибутов для первичного ключа:  
+ примитивные типы и их обертки 
+ строки 
+ BigDecimal и BigInteger 
+ java.util.Date и java.sql.Date

-------------
В JPA (Java Persistence API) аннотация @Id используется для обозначения поля или свойства модели данных, которое является первичным ключом для сущности (Entity) в базе данных. Первичный ключ уникально идентифицирует каждую запись в таблице базы данных.

Аннотация @Id может быть применена к различным типам полей или свойств, таким как числовые (например, int, long), UUID (универсальный уникальный идентификатор), строковые типы (например, String) и т.д. Она используется для указания, что значение данного поля или свойства будет использоваться как первичный ключ при сохранении сущности в базу данных или при поиске сущности по ее идентификатору.

Использование аннотации @Id является одним из основных требований JPA для работы с базой данных. Она позволяет определить уникальные идентификаторы для сущностей и обеспечивает возможность управления объектами базы данных через JPA.

[к оглавлению](#hibernate)

## Какие @GeneratedValue вы знаете? 

https://habr.com/ru/companies/haulmont/articles/653843/

https://habr.com/ru/companies/otus/articles/686136/
 
<img width="930" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/f1d2b785-c699-419f-80df-fcab518866f5">
  
Чтобы значение первичного ключа генерировалось автоматически, нужно добавить первичному ключу, отмеченному аннотацией @Id, аннотацию @GeneratedValue.

Согласно спецификации JPA возможно 4 различных варианта стратегии генерации ключа: AUTO, IDENTITY, SEQUENCE, TABLE.  

Если не указать значение явно, то типом генерации по умолчанию будет AUTO. Спецификация JPA строго не определяет поведение этих стратегий. 

**AUTO** 
 
Указывает, что Hibernate должен выбрать подходящую стратегию для конкретной базы данных, учитывая её диалект, так как у разных БД разные способы по умолчанию.  
 
То, как провайдер должен реализовывать тип генерации AUTO, оставлено на усмотрение провайдера. Поведение по умолчанию – исходить из типа поля идентификатора.  С версии Hibernate 5.0 для числовых значений генерация основана на SEQUENCE, и, если БД её не поддерживает, то на TABLE.  
 
Пример AUTO, в котором значения первичного ключа будут уникальными на уровне базы данных:

<img width="333" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/407aa116-4380-40d1-b0ad-0134cbbd9727">
 
Интересная особенность, представленная в Hibernate 5, это UUIDGenerator. Чтобы его использовать, необходимо объявить идентификатор типа UUID с аннотацией @GeneratedValue:

<img width="962" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/92a02c63-33ab-43e4-a7fc-b8a4ffc1e29a">

**IDENTITY**

Указывает, что для генерации значения первичного ключа будет использоваться столбец IDENTITY, имеющийся в базе данных. Значения в столбце автоматически увеличиваются, что позволяет базе данных генерировать новое значение при каждой операции вставки.  

С точки зрения базы данных это очень эффективно, поскольку столбцы с автоинкрементом хорошо оптимизированы и не требуют каких-либо дополнительных операторов. Процесс инкремента (получения следующего) первичного ключа происходит вне текущей выполняемой транзакции, поэтому откат транзакции может в конечном итоге обнулить уже присвоенные значения (могут возникнуть пропуски значений).  

Если используется Hibernate, то применение IDENTITY имеет существенный недостаток. Так как Hibernate нужен первичный ключ для работы с managed-объектом в persistence context, а мы не можем узнать значение первичного ключа ДО выполнения инструкции INSERT, то Hibernate должен немедленно выполнить оператор INSERT, чтобы получить этот самый первичный ключ, сгенерированный БД.  

Только после этого у Hibernate будет возможность работать с сущностью в контексте персистентности, после чего выполнить операцию persist.  

Но Hibernate, в соответствии со своей идеологией, использует стратегию “транзакционная запись-после” (transactional write behind), согласно которой он пытается максимально отложить сброс данных в БД из контекста персистентности, чтобы не делать много обращений к БД.  

Так как поведение при IDENTITY противоречит идеологии и стратегии “транзакционная запись-после”, Hibernate отключает пакетные вставки (batching inserts) для объектов, использующих генератор IDENTITY. Однако, пакетные обновления и удаления (batching updates и batching deletes) всё же поддерживаются.  

IDENTITY является самым простым в использовании типом генерации, но не самым лучшим с точки зрения производительности. Стратегия генератора первичных ключей IDENTITY не работает при TABLE PER CLASS, поскольку может быть несколько объектов подкласса, имеющих один и тот же идентификатор, и запрос базового класса приведет к получению объектов с одним и тем же идентификатором (даже если они принадлежат разным типам). 

**SEQUENCE**
 
Указывает, что для получения значений первичного ключа Hibernate должен использовать имеющиеся в базе данных механизмы генерации последовательных значений (Sequence). Но если БД не поддерживает тип SEQUENCE, то Hibernate автоматически переключится на тип TABLE.  
 
SEQUENCE – это объект базы данных, который генерирует инкрементные целые числа при каждом последующем запросе. SEQUENCE намного более гибкий, чем IDENTITY, т.к.:  
 
+ не содержит таблиц, и одну и ту же последовательность можно назначить нескольким столбцам или таблицам 
+ может предварительно распределять значения для улучшения производительности 
+ может определять шаг инкремента, что позволяет воспользоваться «объединенным» алгоритмом Hi/Lo                 https://www.baeldung.com/hi-lo-algorithm-hibernate  
+ не ограничивает пакетные вставки JDBC в Hibernate 
+ не ограничивает модели наследования Hibernate.  
 
При SEQUENCE для получения следующего значения из последовательности базы данных требуются дополнительные операторы SELECT, но это не влияет на производительность для большинства приложений. И если приложению необходимо сохранить огромное количество новых сущностей можно использовать некоторые специфичные для Hibernate оптимизации, чтобы уменьшить количество операторов.  
 
Для работы с этой стратегией Hibernate использует свой класс SequenceStyleGenerator. 

SEQUENCE – тип генерации, рекомендуемый документацией Hibernate и самый простой способ задать безымянную генерацию последовательности: 

<img width="808" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/b6ddac76-977e-4a41-af79-6a960349b0ef">

Для всех сущностей с безымянной последовательностью Hibernate будет использовать одну и ту же hibernate_sequence, из которой будет брать для них id -шник. 

Используя аннотацию @SequenceGenerator, можно указать конкретное имя последовательности для таблицы, а также иные параметры. Также можно настроить под себя несколько разных последовательностей (SEQUENCE-генераторов), указав, например, имя последовательности и начальное значение (код ниже) 

<img width="859" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/289c1ebf-88f3-428c-beaa-dc1272948015">
 
В этом примере установили имя последовательности и начальное значение, поэтому генерация первичного ключа начнется с 4. Для каждой последовательности сгенерированные значения являются уникальными.  

Можно назначать разные последовательности разным сущностям, и они будут брать id шники из этой последовательности.  

В зависимости от требований приложения, можно иметь один генератор на всё приложение, по генератору на каждую сущность или несколько генераторов, которыми пользуются несколько сущностей.  
Например, есть 10 сущностей, для трех из них создадим последовательность с именем first_sequence, из которой они будут брать id -шники. Для пяти других сущностей создадим последовательность с именем second_sequence, из которой они будут брать свои id шники. А для оставшихся двух сущностей можем задать безымянную последовательность, и в этом случае id -шники для них будут браться по умолчанию из hibernate_sequence. 

**TABLE**

В настоящее время GenerationType.TABLE используется редко.  

Hibernate должен получать первичные ключи для сущностей из специальной создаваемой для этих целей таблицы, способной содержать несколько именованных сегментов значений для любого количества сущностей.  

Основная идея заключается в том, что подобная таблица (например, hibernate_sequence) может содержать несколько сегментов со значениями идентификаторов для разных сущностей. Это требует использования пессимистических блокировок, которые помещают все транзакции по получению идентификаторов в очередь.  

Это замедляет работу приложения. Третья стратегия, GenerationType.TABLE, не зависит от поддержки конкретной базой данных и хранит счётчики значений в отдельной таблице.  

С одной стороны это более гибкое и настраиваемое решение, с другой стороны более медленное и требующее большей настройки. Вначале требуется создать (вручную!) и проинициализировать (!) таблицу для значений ключей. Затем создать генератор и связать его со идентификатором, используя аннотацию @TableGenerator можно настроить этот тип генерации:

<img width="529" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/f2657347-a01a-4aa2-b9da-3c30dcbdafd1">

------------
Аннотация `@GeneratedValue` в Java используется для указания способа автоматической генерации значений для полей сущностей в базе данных. Она часто используется в связке с аннотацией `@Id`, которая указывает поле как первичный ключ.

Вот некоторые варианты, которые могут быть использованы со `@GeneratedValue`:

1. `AUTO`: Это значение по умолчанию. При использовании этой стратегии, поставщик постоянства (например, Hibernate, EclipseLink) автоматически выбирает стратегию генерации на основе базы данных, с которой он работает. Например, при использовании СУБД MySQL это обычно означает использование автоинкрементных полей.

2. `IDENTITY`: Поставщик постоянства делегирует генерацию первичного ключа на базу данных. Обычно это реализуется через автоинкрементные поля.

3. `SEQUENCE`: Поставщик постоянства использует базу данных для генерации последовательности номеров, которые затем используются в качестве первичных ключей. Обычно требуется дополнительная конфигурация для определения имени последовательности.

4. `TABLE`: Генерация первичных ключей осуществляется с помощью специальной таблицы в базе данных, содержащей информацию о последнем сгенерированном значении. Обычно требуется дополнительная конфигурация для определения имени таблицы и столбцов в ней.

5. `UUID`: Применяется для генерации уникальных идентификаторов в формате Universally Unique Identifier (UUID). Генерируемое значение представляет собой случайное 128-битное число.

Конкретные стратегии генерации могут отличаться в зависимости от используемого поставщика постоянства (например, Hibernate, EclipseLink) и базы данных (например, MySQL, Oracle). Соответствующая документация поставщика постоянства и базы данных может предоставить более подробную информацию о доступных стратегиях генерации и их конфигурации.

[к оглавлению](#hibernate)

##  Расскажите про аннотации @JoinColumn и @JoinTable? Где и для чего они используются? 
 
Аннотация @JoinColumn используется для указания столбца FOREIGN KEY, используемого при установлении связей между сущностями или коллекциями. 

Только сущность-владелец связи может иметь внешние ключи от другой сущности (ведомой). Однако, можно указать аннотацию @JoinColumn как во владеющей таблице, так и в ведомой, но столбец с внешними ключами всё равно появится во владеющей таблице.  

Особенности использования: 

@OneToOne означает, что появится столбец addressId в таблице сущности-владельца связи Office, который будет содержать внешний ключ, ссылающийся на первичный ключ ведомой сущности Address. 

<img width="520" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/62fa92a6-d62b-48c6-aa02-001cc37832b5">

@OneToMany или @ManyToOne: можно использовать атрибут mappedBy для того, чтобы столбец с внешними ключами находился на владеющей стороне ManyToOne (в таблице Email): 

<img width="1211" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/deed4c2d-22ff-4767-92e2-c8ca591c4b66">

В этом примере таблица Email (владелец связи) имеет столбец employee_id, в котором хранится значение идентификатора и внешний ключ к таблице Employee. Если не указать mappedBy, то будет создана сводная (третья) таблица с первичными ключами из двух основных таблиц. 

**@JoinColumns (множественное число)**

Аннотация @JoinColumns используется для группировки нескольких аннотаций @JoinColumn, которые используются при установлении связей между сущностями или коллекциями, у которых составной первичный ключ и требуется несколько колонок для указания внешнего ключа. 

В каждой аннотации @JoinColumn должны быть указаны элементы name и referencedColumnName: 

<img width="733" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/48f7be4e-b70d-4040-9fad-ba0288b73d8a">

**@JoinTable**

Аннотация @JoinTable используется для указания связывающей (сводной, третьей) таблицы между двумя другими таблицами. 
 
<img width="880" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/48ffb078-087e-4eab-8ace-653eba4b90f0">
 
Хороший пример: задача на ПП Rest Security (слева поле в классе User, справа data.sql) 

<img width="1109" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/31da949a-eb5b-4268-924e-5912033d720d">

[к оглавлению](#hibernate)

## Для чего нужны аннотации @OrderrBy и @OrderColumn, чем они отличаются? 
 
https://www.logicbig.com/tutorials/java-ee-tutorial/jpa/order-by-annotation.html

Эти аннотации служат для установки порядка выдачи элементов коллекций Entity. 
 
Аннотация @OrderBy указывает порядок, в соответствии с которым должны располагаться элементы коллекций сущностей, базовых или встраиваемых типов при их извлечении из БД. Эта аннотация может использоваться с аннотациями @ElementCollection, @OneToMany, @ManyToMany.  

Если коллекция содержит элементы базового типа, то упорядочивание будет по значению базовых объектов. Например, номера телефонов будут упорядочены в их естественном порядке: 

<img width="428" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/4358b036-22f4-4ffa-b34b-a2dfb575c5b2">

Если коллекция относится к типу @Embeddable, то нотация с точкой ("".") используется для ссылки на атрибут внутри встроенного атрибута. Например, тут адреса будут упорядочены по названиям стран

<img width="426" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/2d288c17-8208-420d-9aac-007a7ddb11d1">

Где адрес определяется как: 

<img width="241" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/c0786f3e-7c9c-4990-8c0d-bb20af255a37">
 
Можно использовать дополнительно ASC или DESC, чтобы указать, является ли порядок восходящим или нисходящим. По умолчанию — ASC (восходящий). 
  
Когда @OrderBy используется с отношением 
 
@OrderBy работает только с прямыми свойствами, если используется с отношением @OneToMany или @ManyToMany. Например, так (рис. 1) для сущности Task (рис. 2). 

<img width="1086" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/11ca93d1-5bca-4df1-aa51-60ff8d6e2bec">

Доступ через точку (".") не работает в случае отношений. Попытка использовать вложенное свойство, например. @OrderBy("supervisor.name") приведет к исключению во время выполнения. 
 
Если элемент упорядочивания не указан для ассоциации объектов (т. е. аннотация используется без какого-либо значения), предполагается упорядочивание по первичному ключу связанного объекта (рис. 3). В приведенном случае сбор задач будет упорядочен по номеру задачи (id -шник). 

**@OrderColumn**

Аннотация @OrderColumn создает столбец в таблице, который используется для поддержания  постоянного  порядка  в  списке,  но  этот  столбец  не  считается  частью состояния сущности или встраиваемого класса.

Hibernate  отвечает  за  поддержание  порядка  как  в  базе  данных  при  помощи столбца,  так  и  при  получении  сущностей  и  элементов  из  БД.  Hibernate  отвечает  за обновление  порядка  при  записи  в  базу  данных,  чтобы  отразить  любое  добавление, удаление или иное изменение порядка, влияющее на список в таблице.

Аннотация  @OrderColumn  может  использоваться  с  аннотациями @ElementCollection,  @OneToMany,  @ManyToMany  -  указывается  на  стороне отношения,  ссылающегося  на  коллекцию,  которая  должна  быть  упорядочена.  В примере ниже Hibernate добавил в таблицу Employee_PhoneNumbers третий столбец PHONENUMBERS_ORDER, который и является результатом работы @OrderColumn: 
```sql
'Show Columns from Employee_PhoneNumbers'

[EMPLOYEE_ID, BIGINT(19), NO, PRI, NULL]

[PHONENUMBERS, VARCHAR(255), YES, , NULL]

[PHONENUMBERS_ORDER, INTEGER(10), NO, PRI, NULL]

'Select * FROM Employee_PhoneNumbers'

[1, 111-111,111, 0]

[1, 222-222,222, 1]

[2, 333-333-333, 0]

[2, 444-444-444, 1]

[2, 666-666-666, 2]

[3, 555-555-555, 0]
```
**@OrderBy vs @OrderColumn**

Порядок,  указанный  в  @OrderBy,  применяется  только  в  рантайме  при выполнении запроса к БД, То есть в контексте персистентности, в то время как при использовании @OrderColumn, порядок сохраняется в отдельном столбце таблицы и поддерживается при каждой вставке/обновлении/удалении элементов.

---------------
Аннотации `@OrderBy` и `@OrderColumn` используются в контексте объектно-реляционного отображения (Object Relational Mapping, ORM) при работе с базами данных в Java-приложениях, особенно в связи с фреймворками, такими как Hibernate.

Аннотация `@OrderBy` используется для указания порядка сортировки элементов в коллекции или отношении. Она применяется к полю, имеющему тип коллекции (например, `List`, `Set`, `Map`) или отношения, такому как `@OneToMany` или `@ManyToMany`. При использовании `@OrderBy` указывается имя свойства или столбца, по которому нужно производить сортировку. Например:

```java
@OneToMany
@OrderBy("name ASC")
private List<Employee> employees;
```

В данном примере, список сотрудников будет отсортирован по возрастанию имени.

Аннотация `@OrderColumn` используется для задания дополнительного столбца, который будет содержать порядок сортировки элементов в коллекции или отношении. Она также применяется к полю, имеющему тип коллекции или отношения. При использовании `@OrderColumn` указывается имя столбца, который будет хранить порядковые значения. Например:

```java
@OneToMany
@OrderColumn(name = "order")
private List<CartItem> items;
```

В данном примере, каждый элемент списка `items` будет иметь соответствующее порядковое значение в столбце `order`.

Таким образом, основное отличие между `@OrderBy` и `@OrderColumn` заключается в том, что `@OrderBy` определяет порядок сортировки элементов, используя значения какого-либо свойства или столбца, а `@OrderColumn` добавляет дополнительный столбец в таблицу, который будет хранить порядковые значения элементов коллекции или отношения.

-----------
Аннотация `@OrderColumn` является частью Java Persistence API (JPA) и используется для управления упорядоченными коллекциями в объектно-реляционном отображении (ORM).

`@OrderColumn` может быть применена к коллекциям, таким как `List` или `Set`, чтобы добавить специальный столбец в базу данных, который будет хранить информацию о порядке элементов в коллекции. Таким образом, порядок элементов сохраняется и может быть использован при извлечении данных из базы данных.

Вот пример использования аннотации `@OrderColumn`:

```java
@Entity
public class MyClass {
    @Id
    private Long id;

    @OneToMany
    @OrderColumn(name = "order_index")
    private List<ChildClass> children;
    // ...
}
```

В приведенном выше примере аннотация `@OrderColumn` применяется к полю `children`, которое является коллекцией `List` объектов типа `ChildClass`. Благодаря этой аннотации будет создан дополнительный столбец `order_index` в таблице базы данных, который будет хранить индексы упорядоченных элементов.

При сохранении объекта `MyClass` в базу данных, значения индексов элементов коллекции `children` будут автоматически сохранены в столбец `order_index`, чтобы сохранить порядок элементов.

```java
@Entity
public class ChildClass {
    @Id
    private Long id;
    // ...
}
```

В примере выше показана простейшая реализация класса `ChildClass`, который может быть связан с классом `MyClass` через отношение "один-ко-многим" (`@OneToMany`).

При извлечении данных из базы данных, порядок элементов коллекции `children` можно сохранить, используя запрос JPA:

```java
EntityManager entityManager = // получение экземпляра EntityManager
MyClass myObject = entityManager.find(MyClass.class, id);
List<ChildClass> orderedChildren = myObject.getChildren();
```

В данном случае, `orderedChildren` будет содержать список элементов `children`, сохраненных в базе данных с сохранением порядка, заданного индексами.

Важно отметить, что использование аннотации `@OrderColumn` может вносить дополнительные задержки при вставке и удалении элементов в коллекцию, так как требуется обновление значения индексов в базе данных. Поэтому, если сохранение порядка элементов не является обязательным, можно рассмотреть альтернативные способы управления порядком, например, с помощью аннотации `@OrderBy`.

[к оглавлению](#hibernate)

## Для чего нужна аннотация @Transient?

Аннотация  @Transient  используется  для  объявления  того,  какие  поля  у сущности, встраиваемого класса или Mapped SuperClass не будут сохранены в базе данных.

Persistent  fields  (постоянные  поля)  -  это  поля,  значения  которых  будут  по умолчанию сохранены в БД. Ими являются любые не статические и не финальные поля. 

Transient fields (временные поля):
+ статические и финальные поля сущностей;
+ иные поля, объявленные явно с использованием Java-модификатора transient, либо JPA-аннотации @Transient.

<img width="1036" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/7e2bf8aa-240d-4987-b8aa-1c9674c8ec88">

Ключевое слово transient говорит о том, что объект нельзя сериализовать или десериализовать. 
 
Если добавить к полю модификатор transient, то  после восстановления его значение будет null. 
 
У Hibernate есть JPA аннотация @transient  

Она исключает поля и свойства Entity из маппинга (property or field is not persistent). 

Добавили аннотацию, в идее пропал жёлтый кружок слева, значит поле не будет маппиться. 
 
На практике не стоит использовать, т.к. в Entity лучше хранить те поля, которые маппятся на соответствующие поля в таблице базы данных. 

<img width="461" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/d71ae3e4-edfb-4156-8e7c-dea39321c3b5">

[к оглавлению](#hibernate)

## Какие шесть видов блокировок (lock) описаны в спецификации JPA (или какие есть значения у enum LockModeType в JPA)?       

https://youtu.be/C-wEZjEOhWc?t=1952  
 
КОРОТКИЙ ОТВЕТ 
 
У JPA есть шесть видов блокировок, повышающих производительность. 
 
Простыми словами: 
 
Суть оптимистичной блокировки: к одному ресурсу вряд ли будут конкурирующие обращения и поэтому транзакции НЕ блокируют друг друга. Ставим тогда, когда к одним и тем же данным редко одновременно обращаются разные транзакции. ОПТИМИСТ. И версионность тут нужна, чтобы понимать, были ли изменения и если «да», то будет выброшено исключение. Дополнительный контроль. 
 
Суть пессимистичной блокировки: к одним и тем же данным возможны частые запросы и поэтому используется блокирующий подход. ПЕССИМИСТ. 
  
Перечислим их в порядке увеличения надежности (от самого ненадежного и быстрого, до самого надежного и медленного): 
 
+ NONE — без блокировки (по умолчанию)
+ OPTIMISTIC (устаревший READ, оставшийся от JPA 1) — оптимистическая блокировка. OPTIMISTIC_FORCE_INCREMENT (устаревший WRITE, оставшийся от JPA 1) — оптимистическая блокировка с принудительным увеличением поля версионности. 
+ PESSIMISTIC_READ — пессимистичная блокировка на чтение. 
+ PESSIMISTIC_WRITE — пессимистичная блокировка на запись (и чтение). 
+ PESSIMISTIC_FORCE_INCREMENT — пессимистичная блокировка на запись (и чтение) с принудительным увеличением поля версионности.

---------
У JPA есть шесть режимов блокировок (lock modes), перечислим их в порядке увеличения надежности (от самого ненадежного  и быстрого, до самого надежного и медленного):

+ NONE — без блокировки.
+ OPTIMISTIC (или  синоним  READ,  оставшийся  от  JPA  1)  — оптимистическая блокировка.
+ OPTIMISTIC_FORCE_INCREMENT (или синоним WRITE, оставшийся от JPA 1) —  оптимистическая  блокировка  с  принудительным  увеличением  поля версионности.
+ PESSIMISTIC_READ — пессимистичная блокировка на чтение.
+ PESSIMISTIC_WRITE — пессимистичная блокировка на запись (и чтение).
+ PESSIMISTIC_FORCE_INCREMENT — пессимистичная блокировка на запись (и чтение) с принудительным увеличением поля версионности.

Оптимистичное блокирование

Оптимистичный  подход  предполагает,  что  параллельно  выполняющиеся транзакции редко обращаются к одним и тем же данным и позволяет им спокойно и свободно выполнять любые чтения и обновления данных. Но при окончании транзакции производится проверка, изменились ли данные в ходе выполнения данной транзакции и,  если  да,  транзакция  обрывается  и  выбрасывается  исключение.

Оптимистичное блокирование  в  JPA  реализовано  путём  внедрения  в  сущность  специального  поля версии:
```java
@Entity
public class Company extends AbstractIdentifiableObject {

    @Version
    private long version;

    @Getter
    @Setter
    private String name;

    @Getter
    @Setter
    @ManyToMany(mappedBy = \"workingPlaces\")
    private Collection<Person> workers;
}
```
Поле, аннотирование @Version, может быть целочисленным или временнЫм.

При завершении транзакции, если сущность была оптимистично заблокирована, будет проверено, не изменилось ли значение @Version кем-либо ещё, после того как данные были  прочитаны,  и,  если  изменилось,  будет  выкинуто  OptimisticLockException. 

Использование этого поля позволяет отказаться от блокировок на уровне базы данных и сделать всё на уровне JPA, улучшая уровень конкурентности.

JPA поддерживает два типа оптимистичной блокировки:
+ LockModeType.OPTIMISTIC  —  блокировка  на  чтение,  которая  работает,  как описано  выше:  если  при  завершении  транзакции  кто-то  извне  изменит  поле @Version,  то  транзакция  автоматически  будет  откачена  и  будет  выброшено OptimisticLockException.
+ LockModeType.OPTIMISTIC_FORCE_INCREMENT  —  блокировка  на  запись. Ведёт себя как и блокировка на чтение, но при этом увеличивает значение поля @Version.

Обе блокировки ставятся путём вызова метода lock() у EntityManager, в который передаётся сущность, требующая блокировки и уровень блокировки:
```java
EntityManager em = entityManagerFactory.createEntityManager();

em.lock(company1, LockModeType.OPTIMISTIC);

em.lock(company2, LockModeType.OPTIMISTIC_FORCE_INCREMENT);
```
Блокировка будет автоматически снята при завершении транзакции, снять её до этого вручную невозможно.

Пессимистичное блокирование

Пессимистичный  подход  напротив,  ориентирован  на  транзакции,  которые постоянно  или  достаточно  часто  конкурируют  за  одни  и  те  же  данные  и  поэтому блокирует  доступ  к  данным  превентивно,  в  тот  момент  когда  читает  их.  Другие транзакции останавливаются, когда пытаются обратиться к заблокированным данным и  ждут  снятия  блокировки  (или  кидают  исключение). 

Пессимистичное  блокирование выполняется на уровне базы и поэтому не требует вмешательств в код сущности. Так же,  как  и  в  случае  с  оптимистичным  блокированием,  поддерживаются  блокировки чтения и записи:
+ LockModeType.PESSIMISTIC_READ — данные блокируются в момент чтения и это  гарантирует,  что  никто  в  ходе  выполнения  транзакции  не  сможет  их изменить. Остальные транзакции, тем не менее, смогут параллельно читать эти данные.  Использование  этой  блокировки  может  вызывать  долгое  ожидание блокировки или даже выкидывание PessimisticLockException.
+ LockModeType.PESSIMISTIC_WRITE — данные блокируются в момент записи и никто с момента захвата блокировки не может в них писать и не может их читать до  окончания  транзакции,  владеющей  блокировкой.  Использование  этой блокировки может вызывать долгое ожидание блокировки.
  
Кроме  того,  для  сущностей  с  полем,  аннотированным  @Version,  существует третий вариант пессимистичной блокировки:
+ LockModeType.PESSIMISTIC_FORCE_INCREMENT  —  ведёт  себя  как  LockModeType.PESSIMISTIC_WRITE,  но  в  конце  транзакции  увеличивает значение поля @Version, даже если фактически сущность не изменилась.
 
Накладываются  пессимистичные  блокировки  так  же  как  и  оптимистичные, вызовом метода lock():
```java
em.lock(company1, LockModeType.PESSIMISTIC_READ);

em.lock(company2, LockModeType.PESSIMISTIC_WRITE);

em.lock(company3, LockModeType.PESSIMISTIC_FORCE_INCREMENT);
```
Снимаются они тоже автоматически, по завершению транзакции.

Следующие  публичные  методы  EntityManager-а  могут  использоваться  для наложения блокировок:
```java
void lock(Object entity, LockModeType lockMode)

void lock(Object entity, LockModeType lockMode, Map<String, Object>  properties)

<T> T find(Class<T> entityClass, Object primaryKey, LockModeType lockMode)

<T> T find(Class<T> entityClass, Object primaryKey, LockModeType

lockMode, Map<String, Object> properties)

void refresh(Object entity, LockModeType lockMode)

void refresh(Object entity, LockModeType lockMode, Map<String, Object> properties)
```
Помимо  вышеуказанных  методов,  в  Query  API  также  есть  методы  для определения блокировок.

------------

**ПОДРОБНЕЕ (по урокам Матвиенко)**

Вспоминаем тему «транзакции и блокировки» из SQL модуля =) 
 
Решение конфликтов транзакций на уровне Java кода (оптимистические блокировки). 
 
Оптимистичный подход предполагает, что параллельно выполняющиеся транзакции редко обращаются к одним и тем же данным и позволяет им спокойно и свободно выполнять любые чтения и обновления данных.  

Но при окончании транзакции производится проверка, изменились ли данные в ходе выполнения данной транзакции и, если да, транзакция обрывается и выбрасывается исключение. Оптимистичное блокирование в JPA реализовано путём внедрения в сущность специального поля версии. 

Поле, аннотирование @Version, может быть целочисленным или временным.  

При завершении транзакции, если сущность была оптимистично заблокирована, будет проверено, не изменилось ли значение @Version кем-либо ещё, после того как данные были прочитаны, и, если изменилось, будет выкинуто OptimisticLockException.  

Использование этого поля позволяет отказаться от блокировок на уровне базы данных и сделать всё на уровне JPA, улучшая уровень конкурентности. 

<img width="1156" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/61b84008-1835-415a-9453-acca4257135c">

ЗА КУЛИСАМИ (для тех, кто хочет разобраться, НО на собеседовании не углубляемся, а то закопают))): 

Теоретически в проперти файле в Hibernate можно устанавливать уровень изолированности транзакций, но на практике не стоит повышать уровень, который используется по умолчанию в СУБД проекта (по умолчанию уровень 2: read committed).

<img width="1096" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/898fa97d-83cb-4b38-87fa-e38a6436f4a6">

Есть лучший вариант решения проблемы параллельного выполнения транзакций, а именно оптимистические и пессимистические блокировки. 
 
Первые решаются с помощью Java кода (выполнение необходимых SQL запросов, решающих конфликты транзакций на уровне приложения), а вторые с помощью СУБД (более жёсткий вариант).  
 
В любом случае это будет лучше, чем самый высокий уровень изолированности (8 в проперти, см. скрин выше), а именно Serializable т.к. он выполняет транзакции практически последовательно, «убивая» производительность. Но выход есть! 

<img width="1096" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/6519a2e1-54d2-4bfc-9836-fde3de3edb8d">

<img width="862" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/26ad5cca-90f0-4cb7-a143-b090d0d2bbbe">

Сначала в классе Entity добавляем аннотацию @OptimisticLocking и @Version:

<img width="1050" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/bb7df764-3a64-4970-950e-16fcb810f0e2">

Если используем VERSION, то необходимо указать поле, которое будет указывать на версию строчки таблицы. То есть у каждой строчки таблицы будет колонка, в которой будет указана текущая версия строки и при изменении строки, версия будет изменяться. 
 
Теперь если внутри транзакции произойдут изменения (сумму платежа увеличили на 10), то Hibernate в запросе добавит не только условие WHERE, но и VERSION. 

<img width="1194" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/5341ea69-8d6c-44cc-bb8a-267fe4551787">

То есть будет установлена предыдущая версия (ноль) + инкремент (0+1=1).  

Если версия вернула то же самое число, то CRUD операций => изменений не было.

А если номер версии не совпал (операции в строчке с id -шником были), то будет выброшено исключение OptimisticLockException. Можно его ловить в try-catch и логгировать: «номер версии забронирован». 
 
Прежде чем транзакция выполнит обновление, она снова проверяет свойство версии. Если за это время значение изменилось, создается исключение OptimisticLockException. В противном случае транзакция фиксирует обновление и увеличивает значение свойства версии. 
 
Таким образом решается проблема Last Commit Wins, получаем First Commit Wins. В БД увидим изменённое число в колонке version.  

<img width="1211" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/15abd106-d449-4de4-bc7a-37221a4131ea">

Так работает оптимистическая блокировка. По умолчанию имеем OPTIMISTIC и номер версии изменится только тогда, когда будет выполнена одна из операций). 
 
А вариант FORCE_INKREMENT в любом случае инкментирует версию.

<img width="1211" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/78de9107-57c0-47c0-a383-bbb0c6307c2d">

Стратегии ALL и DIRTY (обе эти стратегии не используют поле version). 

<img width="1176" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/3586f4f8-4f9e-4dbc-a24a-2df721f600b8">

Суть ALL в том, что в WHERE нужно указать ВСЕ поля, которые есть в классе. Операция update теперь ДИНАМИЧЕСКАЯ по условию (добавляем соответствующую аннотацию). Под капотом Hibernate парсит аннотации @Table, @Column и т.д. и создаёт CRUD операции для каждой из сущностей. Чтобы каждый раз это не делать, проще один раз распарсить и закэшировать (т.к. они одни и те же данные). А дальше динамически отслеживать условия. 
 
Какая разница между ALL и DIRTY?  
 
DIRTY смотрит лишь «грязный контекст» и в WHERE добавляет только те поля, которые изменились. На практике DIRTY не рекомендуют использовать (есть подводные камни?). 
 
Лучше использовать OPTIMISTIC с версионностью! 
 
Решение конфликтов транзакций на уровне СУБД (пессимистические блокировки). 
 
Пессимистичный подход напротив, ориентирован на транзакции, которые постоянно или достаточно часто КОНКУРИРУЮТ за одни и те же данные и поэтому блокирует доступ к данным превентивно, в тот момент, когда читает их.  
Другие транзакции останавливаются, когда пытаются обратиться к заблокированным данным и ждут снятия блокировки (или кидают исключение).  
 
Пессимистичное блокирование выполняется на уровне базы и поэтому не требует вмешательств в код сущности. Так же, как и в случае с оптимистичным блокированием, поддерживаются блокировки чтения и записи. 

<img width="1207" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/570e5d95-7713-49ae-af68-5a09a2b9112a">

ЗА КУЛИСАМИ 
 
Не поднимая уровень изолированности транзакций в проперти (не ухудшая производительность), решаем проблему. 

<img width="1151" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/b91c5693-e8de-4161-bfaa-3cf455a67812">

<img width="437" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/b67b78b7-d74e-499a-bb78-df824127ba71">

READ: берём запись, изменяем её и пока идёт транзакция, берём ту же самую запись в другой транзакции и изменяем её.

Приложение подвиснет, т.к. первая сессия будет ждать пока блокировка не снимется другой транзакцией. И так будет ждать, пока не случится timeout. 
 
В консоли можно увидеть for share. Блокируются только те строки, которые Hibernate выбрал в SELECT (обращайтесь в документацию той СУБД, которая используется у вас). 

<img width="1131" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/a5fde93d-32ec-43e8-9927-25dc3523d26f">

PESSIMISTIC_WRITE: если изменим тип на WRITE, то в консоли увидим for update (а не for share). Он еще более строгий, чем for share. 
 
PESSIMISTIC_FORCE_INCREMENT – это обычная пессимистическая блокировка, но дополнительно нужна еще и версионность (а форс инкремент, значит в любом случае версия изменяется). 
 
<img width="1117" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/d7f997b8-1719-4019-961b-d0c612c3ad88">
 
Чтобы решить проблему с зависаниями нужно выставлять timeout -ы. Hint указывает, на сколько мс будет задержана блокировка.  
 
Это нужно, чтобы не останавливать транзакцию для всего приложения в целом. 

<img width="1115" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/a1e8d914-9606-426e-9525-abd40329dc44">

[к оглавлению](#hibernate)

## Что такое JPQL/HQL и чем он отличается от SQL? 
 
JPQL (Java Persistence query language) это язык запросов, практически такой же как  SQL, однако вместо имен и колонок таблиц базы данных, он использует имена классов Entity и их атрибуты. В качестве параметров запросов так же используются типы данных атрибутов Entity, а не полей баз данных.  

В отличии от SQL в JPQL есть автоматический полиморфизм (см. следующий вопрос). 

Также в JPQL используется функции, которых нет в SQL: такие как KEY (ключ Map’ы), VALUE (значение Map’ы), TREAT (для приведения суперкласса к его объекту-наследнику, downcasting), ENTRY и т.п. 

----------

Hibernate Query Language (HQL) и Java Persistence Query Language (JPQL) - оба являются объектно-ориентированными языками запросов, схожими по природе с SQL. JPQL - это подмножество HQL. JPQL-запрос всегда является допустимым HQL- запросом, однако обратное неверно.

**Java Persistence query language (JPQL)**

Это язык запросов, практически такой же как SQL, однако, вместо имен и колонок таблиц базы данных, он использует имена классов Entity и их атрибуты. В качестве параметров запросов также используются типы данных атрибутов Entity, а не полей баз данных. В отличии от SQL в JPQL есть автоматический полиморфизм. Также в JPQL используются  функции,  которых  нет  в  SQL:  такие  как  KEY  (ключ  Map'ы),  VALUE (значение  Map’ы),  TREAT  (для  приведения  суперкласса  к  его  объекту- наследнику, downcasting), ENTRY и т.п. 

**Полиморфные запросы**

В отличии от SQL в запросах JPQL есть автоматический полиморфизм, то есть каждый запрос к Entity возвращает не только объекты этого Entity, но также объекты всех его классов-потомков, независимо от стратегии наследования (например, запрос select * from Animal, вернет не только объекты Animal, но и объекты классов Cat и Dog, которые  унаследованы  от  Animal).  Чтобы  исключить  такое  поведение  используется функция  TYPE  в  where  условии  (например  select  *  from  Animal  a  where  TYPE(a)  IN (Animal, Cat) уже не вернет объекты класса Dog).

В  JPA  запрос  представлен  в  виде  javax.persistence.Query  или javax.persistence.TypedQuery,  полученных  из  EntityManager.  Для  создания  Query  или TypedQuery  необходимо  использовать  метод  EntityManager#createQuery.  Для именованных запросов необходим метод EntityManager#createNamedQuery. 

Запросы, как обычные, так и именованные, формируются из EntityManager: 
```java
Query query = entityManager.createQuery(

    "select p " +
    "from Person p " +
    "where p.name like :name"
);

TypedQuery<Person> typedQuery = entityManager.createQuery(

    "select p " +
    "from Person p " +
    "where p.name like :name", Person.class
);

@NamedQuery(
    name = "get_person_by_name",
    query = "select p from Person p where name = :name"
)

Query query = entityManager.createNamedQuery( "get_person_by_name" );

TypedQuery<Person> typedQuery = entityManager.createNamedQuery(

    "get_person_by_name", Person.class
);
```
**Hibernate Query Language (HQL)**

В  Hibernate  HQL-запрос  представлен  org.hibernate.query.Query,  полученный  из Session.  Если  HQL  является  именованным  запросом,  то  будет  использоваться Session#getNamedQuery,  в  противном  случае  требуется  Session#createQuery.  HQL пердоставляет дополнительные возможности по сравнению с JPQL.
```java
org.hibernate.query.Query query = session.createQuery(

    "select p " +
    "from Person p " +
    "where p.name like :name"
);

org.hibernate.query.Query query = session.getNamedQuery( "get_person_by_name" );
```

[к оглавлению](#hibernate)

## Что означает полиморфизм (polymorphism) в запросах JPQL (Java Persistence query language) и как его «выключить»? 

В отличии от SQL в запросах JPQL есть автоматический полиморфизм, то есть каждый запрос к Entity возвращает не только объекты этого Entity, но также объекты всех его классов-потомков, независимо от стратегии наследования (например, запрос select * from Animal, вернет не только объекты Animal, но и объекты классов Cat и Dog, которые унаследованы от Animal).  

Чтобы исключить такое поведение используется функция TYPE в where условии (например select * from Animal a where TYPE(a) IN (Animal, Cat) уже не вернет объекты класса Dog). 

[к оглавлению](#hibernate)

## Что такое Criteria API и для чего он используется? 
 
Criteria API это тоже язык запросов, аналогичным JPQL (Java Persistence query language), однако запросы основаны на методах и объектах, то есть запросы выглядят так: 
 
<img width="1159" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/1a76e166-fa5c-4ccd-9e4d-bb03cc9a2d28">
 
Преимущество использования языка Criteria – это динамические запросы, написанные на Java. Это, пожалуй, единственное преимущество. В остальном трудно читаемый код. Чаще используется HQL, JPQL – интуитивно понятный (т.к. похож на SQL).

----------
Criteria API - это набор классов и методов, доступных в Java Persistence API (JPA), которые позволяют создавать типобезопасные запросы к базе данных без явного написания SQL-запросов.

Criteria API предоставляет альтернативный подход к созданию запросов к базе данных вместо использования языка запросов, такого как JPQL (Java Persistence Query Language) или SQL. Он позволяет строить запросы динамически на основе параметров или условий, что делает его особенно полезным при создании гибких и сложных запросов.

Основные компоненты Criteria API включают:

1. CriteriaBuilder: Этот интерфейс позволяет создавать критерии запроса и выражения для фильтрации, сортировки и т. д.

2. CriteriaQuery: Этот интерфейс представляет собой запрос, который может быть выполнен для получения результатов из базы данных.

3. Root: Этот интерфейс представляет корневую сущность в запросе. Он используется для указания основного типа сущности, связи с другими сущностями и определения фильтров.

4. Predicate: Этот интерфейс представляет собой условие или предикат, используемый для фильтрации результатов запроса.

Использование Criteria API позволяет выражать запросы к базе данных в виде типобезопасных Java-конструкций, что обеспечивает компиляционную проверку и предлагает более надежный и гибкий способ создания запросов на основе кода. Он также позволяет создавать запросы, не зависящие от конкретной базы данных, что облегчает переносимость приложения между различными СУБД.

В целом, Criteria API предоставляет программисту большую степень контроля над созданием запросов, и он может быть особенно полезен при разработке сложных запросов с динамическими условиями или при построении абстракции для работы с данными.

---------------
Начиная  с  версии  5.0  собственный  Hibernate  Criteria  API  признан устаревшим  и  не  развивается.  Вместо  него  рекомендуется  использовать  JPA Criteria API.

Начиная  с  версии  5.2  Hibernate  Criteria  API  объявлен  deprecated  и  не рекомендуется к использованию.

Hibernate Criteria API
Это тоже язык запросов, аналогичный JPQL (Java Persistence query language), однако запросы основаны на методах и объектах. Hibernate Criteria API является более объектно-ориентированным  для  запросов,  которые  получают  результат  из  базы данных. Для операций update, delete или других DDL манипуляций использовать Criteria API нельзя. Критерии используются только для выборки из базы данных в более объектно-ориентированном стиле. Используется для динамических запросов. Запросы выглядят так:
```java
session.createCriteria(Person.class)
  .setMaxResults(10)
  .list()
  .forEach(System.out::println);
```
Запрос выше полностью аналогичен запросу HQL \"from Person\". С Criteria также работают и все те вещи, которые работают и с Query: пейджинг, таймауты и т.д.

Разумеется, в Criteria запросах можно и нужно накладывать условия, по которым объекты будут отбираться:
```java
session.createCriteria(Person.class)
  .add(Restrictions.eq(\"lastName\", \"Testoff\"))
  .list()
  .forEach(System.out::println);
```
**JPA Criteria API**

Criteria API - это актуальный API, используемый для определения запросов для сущностей.  Это  альтернативный  способ  определения  JPQL-запроса.  Эти  запросы типобезопасны, переносимы и легко меняются путем изменения синтаксиса.

Основные преимущества JPA Criteria API:
+ ошибки могут быть обнаружены во время компиляции;
+ позволяет  динамически  формировать  запросы  на  этапе  выполнения приложения.

Запросы на основе строк JPQL и запросы на основе критериев JPA одинаковы по производительности и эффективности. 

Для простых статических запросов предпочтительнее использовать строковые запросы JPQL (например, в виде именованных запросов). Для динамических запросов, которые  создаются  во  время  выполнения  -  JPA  Criteria  API  может  быть предпочтительней.  Например,  построение  динамического  запроса  на  основе  полей, которые  пользователь  заполняет  в  рантайме  в  форме,  которая  содержит  много необязательных полей. Ожидается, что построение этого запроса будет более ясным и понятным при использовании JPA Criteria API, поскольку устраняет необходимость в создании запроса с использованием многих операций конкатенации строк. 

Пример использования JPA Criteria API:
```java
EntityManager em = entityManagerFactory.createEntityManager();

em.getTransaction().begin();

CriteriaBuilder cb = em.getCriteriaBuilder();

CriteriaQuery<Person> personCriteria = cb.createQuery(Person.class);

Root<Person> personRoot = personCriteria.from(Person.class);

personCriteria.select(personRoot);

em.createQuery(personCriteria)
  .getResultList()
  .forEach(System.out::println);
```
**Алгоритм:**
+ создаём  EntityManager, 
+ открываем  транзакцию  и  создаём CriteriaBuilder,  который  будет  строить  объекты  запросов. 
+ С  помощью  CriteriaBuilder создаём  CriteriaQuery,  который  параметризуется  типом,  который  этот  запрос возвращает.
+ Затем создаём корневой объект, от которого производится обход дерева свойств при накладывании ограничений или указании, что выбирать.
+ Последним шагом говорится, что же мы хотим выбрать
+ и, наконец, запрос отправляется в EntityManager, где  и  выполняется  как  обычно.  Построенный  выше  весьма  многословный  пример эквивалентен JPQL запросу «from Person».

Все шаги, перечисленные выше, являются обязательными для создания запроса с помощью Criteria API. Важно понимать, что корневой объект указывает JPQL, откуда будут браться данные, а CriteriaQuery указывает тип возвращаемых данных. И типы Root  и CriteriaQuery  могут отличаться:
```java
CriteriaQuery<Passport> passportCriteria = cb.createQuery(Passport.class);

Root<Person> personPassportRoot = passportCriteria.from(Person.class);

passportCriteria.select(personPassportRoot.get(\"passport\"));

em.createQuery(passportCriteria)
  .getResultList()
  .forEach(System.out::println);
```
Этот  запрос  аналогичен  JPQL  запросу  «select  passport  from  Person»  и показывает,  что  класс,  из  которого  запрашиваются  данные  и  класс,  который  вернёт запрос, могут быть разными.

**Metamodel и типобезопасность.**

Все примеры выше решают проблему с программным созданием запросов, но всё ещё бессильны перед изменениями сущностей. В самом деле, изменив в сущности Person поле workingPlaces на jobs - развалится этот запрос:
```java
CriteriaQuery<Person> personWorkCriteria = cb.createQuery(Person.class);

Root<Person> personWorkRoot = personWorkCriteria.from(Person.class);

Join<Person, Company> company = personWorkRoot.join(\"workingPlaces\");

personWorkCriteria.select(personWorkRoot);

personWorkCriteria.where(cb.equal(company.get(\"name\"), \"Acme Ltd\"));

em.createQuery(personWorkCriteria)
  .getResultList()
  .forEach(System.out::println);
```
И мы не узнаем, что он развалится, пока не попробуем его исполнить.

Metamodel решает эту проблему, создавая специальные описательные классы, которые используются в Criteria API вместо имён полей. Сам Metamodel класс выглядит примерно вот так:
```java
@StaticMetamodel(Company.class)
public abstract class Company_ extends AbstractIdentifiableObject_ {

  public static volatile SingularAttribute<Company, String> name;

  public static volatile CollectionAttribute<Company, Person> workers;

}
```
В Metamodel классе описываются, какие поля присутствуют в сущности, какого они  типа,  коллекция  это  или  нет  и  т.д.  Для  каждой  сущности  создаётся  свой  класс Metаmodel.

Создаются  классы  Metamodel  разумеется  не  вручную.  То  есть  можно  их  и вручную создать, но тогда пропадает автоматичность проверки и теряется смысл всей этой затеи.

Обычно же классы Metamodel генерируются на этапе компиляции тем или иным методом. Конкретная реализация генерации зависит от конкретной реализации JPA и может меняться.

[к оглавлению](#hibernate)

## В чем разница в требованиях к Entity в Hibernate, от требований к Entity, указанных в спецификации JPA? 

1)Конструктор без аргументов в Hibernate НЕ обязан быть public или protected, рекомендуется чтобы он был хотя бы package видимости, однако это только рекомендация, если настройки безопасности Java позволяют доступ к приватным полям, то он может быть приватным. 
 
2)JPA категорически требует не использовать final классы, Hibernate лишь рекомендует не использовать такие классы чтобы он мог создавать прокси для ленивой загрузки, однако позволяет либо выключить прокси Proxy(lazy=false), либо использовать в качестве прокси интерфейс, содержащий все методы маппинга для данного класса (аннотацией Proxy(proxyClass = интерфейс.class). 

[к оглавлению](#hibernate)

## Расскажите про проблему N+1 Select и путях ее решения. 
 
КОРОТКО:  

Проблема более не актуальна, она решена самим Hibernate (выше 6 версии =) шутка 
 
ПОДРОБНЕЕ:  

<img width="1130" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/a9a7f381-fdc2-4c9d-a3c0-54d528426c9f">

Проблема N+1 связана с производительностью. Если делаем множественный запрос (пользователь, платёж, компания), то Hibernate делает дополнительный SELECT запрос. 

<img width="1221" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/45a4174f-a2ed-4a4b-bfa3-50dcbe1024e0">

**Правило: использовать везде, где можно, ленивую загрузку.**
 
Например, если поставить на трёх классах EAGER загрузку, то выскочит  MultipleBagFetchException, т.к. нельзя одним запросом получать сразу несколько ассоциаций, если это коллекция (Bag – прокси для коллекций), которая не упорядочена, т.е. не поддерживает сортировку. Поэтому Hibernate не может их смаппить (не понимает, какие строки относятся к каким таблицам).

<img width="714" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/e75475de-cb2f-40aa-a07f-39b9e91e0f54">

<img width="471" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/e5d010b4-1ab0-426c-81db-57d6e2dc82c9">

Eсли поставим Set (нет порядка), то Hibernate выполнит Left Outer Join и получим декартово произведение записей на три сущности).

Получаем кучу дублирующей информации, которая не нужна и никак не отсортирована.

Кроме того, нет возможности использовать LIMIT, OFFSET и агрегирующие функции.

**Пути решения проблемы N+1**

https://www.youtube.com/watch?v=XH9KMY4jMSQ

<img width="1170" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/95631ffc-cca4-4fbd-ab8a-e39e241e5d1f">

<img width="1149" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/07ee22ee-8664-4c76-bd10-9c1ea9ca8d9f">

<img width="948" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/01d00dcc-36df-483c-8624-33e275fd3aa2">

**JOIN FETCH**

И при FetchType.EAGER и при FetchType.LAZY поможет JPQL-запрос с JOIN FETCH. Опцию «FETCH» можно использовать в JOIN (INNER JOIN или LEFT JOIN) для выборки связанных объектов в одном запросе вместо дополнительных запросов для каждого доступа к ленивым полям объекта. 

<img width="1017" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/2189973d-bc5f-4c55-8fc0-20cf1081d021">

Использование LEFT JOIN FETCH аналогично JOIN FETCH, только будут загружены все сущности из таблицы PostComment, даже те, у которых нет связанной сущности Post (в нашем случае пример не логичный, но понятный). 

**EntityGraph**

В случаях, когда нужно получить по-настоящему много данных, и используется JPQL запрос, то лучше всего использовать EntityGraph. 

<img width="1154" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/dd0748b9-0a07-4f86-b59f-fe5ff7e9b4c2">

**@Fetch(FetchMode.SUBSELECT)**

Это Аннотация Hibernate, в JPA её нет. Можно использовать только с коллекциями.  

Будет сделан один SQL запрос для получения корневых сущностей и, если в контексте персистентности будет обращение к ленивым полям-коллекциям, то выполнится еще один запрос для получения связанных коллекций: 

<img width="1211" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/8a68f906-0ee4-4c07-9adb-c5f1e067d2ab">

HibernateSpecificMapping, SqlResultSetMapping 

Для нативных запросов рекомендуется использовать именно их. 

**Batch Fetching**

Это аннотация Hibernate, в JPA её нет. Указывается над классом сущности или над полем коллекции с ленивой загрузкой.  

<img width="671" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/9c37bdaf-3a95-42b1-93d9-07116e89d263">

Будет сделан один sql-запрос для получения корневых сущностей и, если в контексте персистентности будет обращение к ленивым полям-коллекциям, то выполнится еще один запрос для получения связанных коллекций.  

Например, в персистентный контекст загружено 12 сущностей Customer, у которых по одному полю-коллекции orders, но так как это @OneToMany, то у них ленивая загрузка по умолчанию и они не загружены в контекст персистентности из БД.  

При первом обращении к какому-нибудь полю orders, нам бы хотелось, чтобы для всех 12 сущностей Customer были загружены их 12 коллекций Order, по одной для каждой.  

Но так как @BatchSize(size=5), то Hibernate сделает 3 запроса: в первом и втором получит по пять коллекций, а в третьем получит две коллекции. Если знать примерное количество коллекций, которые будут использоваться в любом месте приложения, то можно использовать @BatchSize и указать нужное количество.  

Также аннотация @BatchSize может быть указана у класса.  

Рассмотрим пример, где есть сущность Order, у которой есть поле типа Product (не коллекция). Выгрузили в контекст персистентности 27 объектов Order. При обращении к полям Product у объектов Order будет инициализировано до 10 ленивых прокси сущностей Product одновременно: 

<img width="887" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/a2c6dff6-a347-466e-b19f-77add8cbe05c">

Хотя использовать @BatchSize лучше, чем столкнуться с проблемой запроса N+1, в большинстве случаев гораздо лучшей альтернативой является использование DTO (Data Transfer Object) или JOIN FETCH, поскольку они позволяют получать необходимые данные одним запросом

[к оглавлению](#hibernate)

## Что такое EntityGraph? Как и для чего их использовать?

https://youtu.be/b2a4rVR5hiQ?t=311  
 
https://www.baeldung.com/jpa-entity-graph  
 
Справка: Граф – нелинейная структура, состоящая из конечного множества вершин, соединенных между собой ребрами. Порядок соединения может быть любым. Кол-во вершин определяет порядок графа, а кол-во ребер – его размер. 

Основная цель JPA Entity Graph состоит в том, чтобы улучшить производительность во время выполнения при загрузке связанных ассоциаций и основных полей сущности. 

JPA 2.1 представила функцию Entity Graph как более сложный метод работы с нагрузкой на производительность. 

Это позволяет определить шаблон, сгруппировав связанные поля сохраняемости, которые мы хотим получить, и позволяет нам выбрать тип графика во время выполнения. 

<img width="759" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/ae75bf7d-1789-4ca1-a0a5-5d8bb2a0e9e3">

КАК изменить настройки fetch стратегии любых атрибутов Entity для отдельных запросов (query) или методов поиска (find), если у Enity есть атрибут с fetchType = LAZY, но для конкретного запроса его требуется сделать EAGER или наоборот? Для этого существует EntityGraph API, используется он так:  
 
С помощью аннотации NamedEntityGraph для Entity, создаются именованные EntityGraph объекты, которые содержат список атрибутов, у которых нужно поменять fetchType на EAGER, а потом данное имя указывается в hits запросов или метода find(). 
 
В результате fetchType атрибутов Entity меняется, но только для этого запроса.  
 
Существует две стандартных property для указания EntityGraph в hit: 
 
•javax.persistence.fetchgraph — все атрибуты перечисленные в EntityGraph меняют fetchType на EAGER, все остальные на LAZY 
 
•javax.persistence.loadgraph — все атрибуты перечисленные в EntityGraph меняют fetchType на EAGER, все остальные сохраняют свой fetchType (то есть если у атрибута, не указанного в EntityGraph, fetchType был EAGER, то он и останется EAGER). 
 
С помощью NamedSubgraph можно также изменить fetchType вложенных объектов Entity.

<img width="1121" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/3cb9b8c2-2236-4dfa-b435-705ff03fb84b">

---------
EntityGraph - это инструмент в объектно-реляционных отображениях (ORM), который позволяет управлять загрузкой сущностей и связанных с ними данных в базе данных. Он является частью Java Persistence API (JPA), который является стандартом для работы с базами данных в Java.

EntityGraph позволяет определить, какие атрибуты сущностей должны быть загружены из базы данных при выполнении запросов. Он предоставляет возможность указать жадное (eager) или ленивое (lazy) загрузка атрибутов, а также задать глубину загрузки для связанных сущностей.

При использовании EntityGraph можно снизить количество запросов к базе данных, эффективно загружая только необходимые данные. Это позволяет повысить производительность приложения, особенно когда имеется большое количество связанных данных.

EntityGraph также удобен для управления загрузкой связанных коллекций, таких как списки или множества. Он позволяет указать, какая часть коллекции должна быть загружена, и таким образом избежать избыточной загрузки данных.

Использование EntityGraph требует определения аннотаций на уровне кода для указания, какие атрибуты и связи должны быть загружены. Это позволяет более гибко управлять загрузкой данных и предотвращать возможные проблемы связанные с ленивой или жадной загрузкой данных.

В целом, EntityGraph является мощным инструментом, позволяющим оптимизировать запросы к базе данных и эффективно загружать только необходимые данные. Это особенно важно при работе с большими объемами данных и связанными структурами данных.

[к оглавлению](#hibernate)

## Можно ли в JDBC реализовать кэш? 
 
Нет, т.к. JDBC пишет запросы сразу в БД и другой функции у него нет. 

[к оглавлению](#hibernate)

## Какие интерфейсы, классы есть в JDBC? 
 
Интерфейсы JDBC API содержит два основных типа интерфейсов:  
+ первый – для разработчиков приложений 
+ второй (более низкого уровня) – для разработчиков драйверов.  
 
Соединение с базой данных описывается классом, реализующим интерфейс java.sql 

<img width="958" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/917b0c27-fe36-458f-a5b4-79b2705106c3">

---------
JDBC (Java Database Connectivity) - это стандартный интерфейс программирования на языке Java для взаимодействия с реляционными базами данных. Он предоставляет API для выполнения SQL-запросов и манипулирования данными в базах данных.

В JDBC определено множество интерфейсов и классов. Вот некоторые из них:

1. Connection (соединение): Этот интерфейс представляет соединение с базой данных. Он предоставляет методы для создания и выполнения запросов, управления транзакциями и получения метаданных о базе данных.

2. Statement (заявление): Этот интерфейс используется для выполнения статических SQL-запросов без параметров. Он предоставляет методы для выполнения запросов и получения результатов.

3. PreparedStatement (подготовленное заявление): Этот интерфейс представляет заранее скомпилированный SQL-запрос с параметрами. Он позволяет улучшить производительность при многократном выполнении запросов с разными параметрами.

4. CallableStatement (вызываемое заявление): Этот интерфейс используется для вызова хранимых процедур базы данных. Он позволяет передавать параметры в процедуру и получать результаты ее выполнения.

5. ResultSet (набор результатов): Этот интерфейс представляет собой набор результатов, полученных из базы данных после выполнения запроса. Он предоставляет методы для итерации по результатам и доступа к значениям полей.

Кроме вышеперечисленных интерфейсов, JDBC также предоставляет классы, такие как DriverManager, DataSource и RowSet, которые упрощают управление подключениями, обеспечивают пулы соединений и предоставляют более гибкий способ работы с результатами запросов.

Важно отметить, что JDBC является только интерфейсом, и каждая реляционная база данных имеет свою реализацию драйвера JDBC, которую необходимо использовать для взаимодействия с соответствующей базой данных. Например, для работы с базой данных MySQL требуется использовать драйвер JDBC для MySQL, а для работы с базой данных Oracle - драйвер JDBC для Oracle. Различные драйверы могут предоставлять дополнительные классы и функциональность, специфичные для конкретной базы данных.

[к оглавлению](#hibernate)

## Если установить стратегию генерации ключа AUTO, то какую из типов стратеги Hibernate САМ никогда не выберет и почему? 
 
Hibernate для работы с Entity нужно знать их id -шник. А чтобы id узнать, нужно обратиться (сходить) в базу. А Hibernate ленивый, он «не хочет» лишний раз ходить в БД, поэтому IDENTITY он никогда не выберет. 

-----------
Стратегия "identity" использовала генерацию ключей, поддерживаемую некоторыми базами данных, такими как MySQL или SQL Server, где значения первичных ключей генерируются автоматически базой данных при вставке новой записи. Однако, при использовании стратегии "identity" Hibernate должен выполнить SQL-запрос для получения сгенерированного значения первичного ключа после вставки объекта. Это делало процесс сохранения объектов менее эффективным и приводило к лишним обращениям к базе данных для получения значений первичных ключей.

[к оглавлению](#hibernate)
