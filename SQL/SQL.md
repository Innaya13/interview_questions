

# SQL

+ [Что такое данные, информация, база данных? Что «под капотом» БД?](#что-такое-данные-информация-база-данных-что-под-капотом-бд)
+ [Что такое SQL?](#что-такое-sql)
+ [Что такое Query?](#что-такое-query)
+ [Какие бывают связи таблиц SQL?](#какие-бывают-связи-таблиц-sql)
+ [Что такое DDL? Какие операции в него входят? Рассказать про них.](#что-такое-ddl-какие-операции-в-него-входят-рассказать-про-них)
+ [Что такое DML? Какие операции в него входят? Рассказать про них.](#что-такое-dml-какие-операции-в-него-входят-рассказать-про-них)
+ [Что такое TCL? Какие операции в него входят? Рассказать про них.](#что-такое-tcl-какие-операции-в-него-входят-рассказать-про-них)
+ [Что такое DCL? Какие операции в него входят? Рассказать про них.](#что-такое-dcl-какие-операции-в-него-входят-рассказать-про-них)
+ [Нюансы работы с в SQL. Как проверить поле на NULL?](#нюансы-работы-с-null-в-sql-как-проверить-поле-на-null)
+ [Виды Join’ов (виды связывания таблиц).](#виды-joinов-виды-связывания-таблиц)
+ [Что лучше использовать join или подзапросы? Почему?](#что-лучше-использовать-join-или-подзапросы-почему)
+ [Что делает UNION?](#что-делает-union)
+ [Чем WHERE отличается от HAVING?](#чем-where-отличается-от-having)
+ [Что такое GROUP BY?](#что-такое-group-by)
+ [Что такое ORDER BY?](#что-такое-order-by)
+ [Что такое DISTINCT?](#что-такое-distinct)
+ [Что такое LIMIT?](#что-такое-limit)
+ [Что такое EXISTS?](#что-такое-exists)
+ [Расскажите про операторы IN, BETWEEN, LIKE.](#расскажите-про-операторы-in-between-like)
+ [Что делает оператор MERGE? Какие у него есть ограничения?](#что-делает-оператор-merge-какие-у-него-есть-ограничения)
+ [Какие агрегатные/агрегирующие функции вы знаете?](#какие-агрегатные-агрегирующие-функции-вы-знаете)
+ [Что такое ограничения (constraints)? Какие вы знаете?](#что-такое-ограничения-constraints-какие-вы-знаете)
+ [Что такое суррогатные ключи?](#что-такое-суррогатные-ключи)
+ [Теория множеств](#теория-множеств)
+ [Какой вид структуры данных (какое дерево) используется при работе с базами данных?](#какой-вид-структуры-данных-какое-дерево-используется-при-работе-с-базами-данных)
+ [Как оценить сложность выполняемого запроса?](#как-оценить-сложность-выполняемого-запроса)
+ [Как узнать, сколько места занимает таблица в памяти?](#как-узнать-сколько-места-занимает-таблица-в-памяти)
+ [Методы сканирования таблиц](#методы-сканирования-таблиц)
+ [Что такое индексы? Какие они бывают?](#что-такое-индексы-какие-они-бывают)
+ [Как и зачем создавать индекс?](#как-и-зачем-создавать-индекс)
+ [Что такое селективность?](#что-такое-селективность)
+ [Анализ выполнения запросов (если есть проблемы с производительностью)](#анализ-выполнения-запросов-если-есть-проблемы-с-производительностью)
+ [Чем TRUNCATE отличается от DELETE?](#чем-truncate-отличается-от-delete)
+ [Что такое хранимые процедуры? Для чего они нужны?](#что-такое-хранимые-процедуры-для-чего-они-нужны)
+ [Что такое представления (VIEW)? Для чего они нужны?](#что-такое-представления-view-для-чего-они-нужны)
+ [Что такое временные таблицы? Для чего они нужны?](#что-такое-временные-таблицы-для-чего-они-нужны)
+ [Что такое транзакции? Расскажите про принципы ACID.](#что-такое-транзакции-расскажите-про-принципы-acid)
+ [Расскажите про уровни изолированности транзакций.](#расскажите-про-уровни-изолированности-транзакций)
+ [Что такое нормализация и денормализация? Расскажите про 3 нормальные формы?](#что-такое-нормализация-и-денормализация-расскажите-про-3-нормальные-формы)
+ [Что такое TIMESTAMP?](#что-такое-timestamp)
+ [Расскажи про шардирование баз данных](#расскажи-про-шардирование-баз-данных)
+ [Как сделать запрос из двух баз?](#как-сделать-запрос-из-двух-баз)
+ [Что такое триггер?](#что-такое-триггер)
+ [Что такое sql-injection (SQL инъекции)?](#что-такое-sql-injection-sql-инъекции)
+ [Как выбрать между Statement, PreparedStatement и CallableStatement?](#как-выбрать-между-statement-preparedstatement-и-callablestatement)
+ [Какие классы вовлечены в соединение с базой данных?](#какие-классы-вовлечены-в-соединение-с-базой-данных)
+ [Что можно делать с классом Connection?](#что-можно-делать-с-классом-connection)
+ [Какая разница между @ElementCollection, @OneToMany и @ManyToMany?](#какая-разница-между-elementcollection-onetomany-и-manytomany)
+ [SQL или NoSQL — вот в чём вопрос](#sql-или-nosql--вот-в-чём-вопрос)
+ [SQL live coding на собеседовании](#sql-live-coding-на-собеседовании)

## Что такое данные, информация, база данных? Что «под капотом» БД?

Данные - это совокупность сведений, зафиксированных на определенном носителе в форме, пригодной для постоянного хранения, передачи и обработки. Преобразование и обработка данных позволяет получить информацию.

Информация - это результат преобразования и анализа данных. Отличие информации от данных состоит в том, что данные - это фиксированные сведения о событиях и явлениях, которые хранятся на определенных носителях, а информация появляется в результате обработки данных при решении конкретных задач. Например, в базах данных хранятся различные данные, а по определенному запросу система управления базой данных выдает требуемую информацию.

База данных (БД) - это совокупность связанных данных, которые хранятся в упорядоченном формате, чтобы обеспечить легкий доступ, управление и обновление данных. БД может включать одну или несколько таблиц, каждая из которых содержит поля, связанные с данными.

Данные – это информация в формализованном виде, т.е. пригодном для интерпретации, обработки, передачи. Информация – это структурированные данные.  
 
База данных — это набор данных, хранящиеся в структурированном виде. 

"Под капотом" базы данных находятся различные компоненты, включая систему управления базами данных (СУБД), языки запросов, модели данных и технологии обработки данных. СУБД - это программное обеспечение, которое управляет доступом к данным, управляет транзакциями и обеспечивает безопасность и целостность данных. Языки запросов используются для доступа к данным в БД, в то время как модели данных определяют фактическую структуру данных, которая хранится в БД. Технологии обработки данных, такие как индексы, оптимизаторы запросов и кэш-память, позволяют повысить производительность и эффективность работы с данными в БД.

Система управления базами данных СУБД — это совокупность языковых и программных средств, которая осуществляет доступ к данным, позволяет их создавать, менять и удалять, обеспечивает безопасность данных. 

<img width="1124" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/70c917f1-c9c8-47ef-b2c0-70b233b2871f">

Семь из десяти самых популярных СУБД — реляционные (связанные, relation/связь) Это Oracle, MySQL, Microsoft SQL Server, PostgreSQL, IBM Db2, Microsoft Access, SQLite.  
 
Есть также: MongoDB – документ- ориентированная СУБД; Redis - хранилище по типу «ключ-значение»; Elasticsearch - поисковой движок.

<img width="1129" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/ffed3074-7fb8-414d-9a55-9f8bf49b7f43">

[к оглавлению](#sql)

## Что такое SQL? 

<img width="704" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/237d3b8b-cad6-44fb-9db8-93aa78afa938">

SQL, также известный как «язык структурированных запросов», — это язык программирования, используемый для управления данными в системах управления реляционными базами данных».

Язык программирования структурированных запросов Structured Query Language, SQL. Внешние программы формируют запрос к СУБД на языке SQL.

SQL (Structured Query Language) - это язык программирования, который используется для работы с реляционными базами данных. SQL позволяет создавать базы данных, таблицы и индексы, а также выполнять различные операции с данными в базе данных, например, добавление, удаление, изменение, выборку и сортировку данных.

SQL является стандартным языком для работы с реляционными базами данных, и его можно использовать со многими СУБД (системами управления базами данных), такими как MySQL, Oracle, Microsoft SQL Server, PostgreSQL и многими другими. SQL является важным инструментом для работы с данными и широко используется во многих индустриях, включая бизнес, финансы, здравоохранение и другие.

SQL — это язык структурированных запросов (Structured Query Language), позволяющий хранить, манипулировать и извлекать данные из реляционных баз данных (далее — РБД, БД).

<img width="1152" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/67420fbf-e7b6-43f2-9784-3d0e404fc1cd">

<img width="1107" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/57332fab-7eb2-49c2-b05e-9fbeaee4f03c">

<img width="1187" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/263203ac-b657-49e9-bf7d-050d34a79986">

<img width="1110" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/fe3c7245-241a-4ce1-b148-9eafecff6a92">

[к оглавлению](#sql)

## Что такое Query? 

Запрос (Query) - это запрос на получение определенных данных из базы данных или другого источника данных.

Это может быть поиск информации по ключевому слову или фразе, запрос фильтрации данных и сортировки, запрос на добавление, изменение или удаление информации в базе данных и т.д.

Запросы используются в различных системах, в том числе в поисковых системах, социальных сетях, веб-страницах и мобильных приложениях. Они играют важную роль в предоставлении пользователю нужной информации, так как позволяют точно определить, какие данные нужны и каким образом их следует обработать.

----------------
(HQL запрос всегда начинается с получения объекта Query из Session вызовом метода createQuery(), в который передаётся текст запроса.)

Интерфейс Query представляет собой объект для выполнения запросов к базе данных.

Объект Query можно создать (в JPA/Hibernate) используя метод:

Session.createQuery() - для создания запросов на основе JPQL (HQL);

Session.createNativeQuery() - для создания запросов на основе SQL.

------------------
Это запрос. 
 
Java Persistence Query Language, JPQL — платформенно-независимый объектноориентированный язык запросов, являющийся частью спецификации JPA или Java Persistence API. JPQL используется для написания запросов к сущностям, хранящимся в реляционной базе данных. 
 
Как передать в объект Query параметры?  
HQL (Hibernate Query Language) запрос всегда начинается с получения объекта Query из Session вызовом метода createQuery(), в который передаётся текст запроса. 

[к оглавлению](#sql)

## Какие бывают связи таблиц SQL?

<img width="1119" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/5e82cf16-f6f2-4d5d-a882-9833bcf13a35">

Существуют различные типы связей таблиц в SQL:

Один-к-одному (One-to-One) - каждая запись в одной таблице соответствует только одной записи в другой таблице. Например, у каждого человека может быть только один паспорт.

Один-ко-многим (One-to-Many) - каждая запись в одной таблице может соответствовать нескольким записям в другой таблице. Например, у каждого клиента может быть несколько заказов.

Многие-ко-многим (Many-to-Many) - множество записей в одной таблице может соответствовать множеству записей в другой таблице. Для реализации такой связи необходима третья таблица, которая хранит отношение между двумя таблицами. Например, у каждого студента может быть несколько курсов, и каждый курс может быть выбран несколькими студентами.

Все эти типы связей используются для объединения данных из разных таблиц в SQL и представлены с помощью ключевых полей, которые связывают строки в таблицах. Управление связью таблиц осуществляется с помощью команд DDL (Data Definition Language) и DML (Data Manipulation Language) на языке SQL.

[к оглавлению](#sql)

## Что такое DDL? Какие операции в него входят? Рассказать про них.

Какие существуют операторы SQL?

Операторы определения данных (Data Definition Language, DDL):
+ CREATE создает объект БД (базу, таблицу, представление, пользователя и т. д.), CREATE DATABASE Test
+ ALTER изменяет объект (ALTER TABLE - изменить структуру таблицы)
+ DROP удаляет объект;
+ Проконтролировать создание базы данных можно с помощью оператора SHOW DATABASES, SHOW TABLES кроме пользовательских таблиц отображает также и служебные таблицы.
+ DESCRIBE table_name – показывает таблицу
+ DELETE FROM <table_name> - Удаление всех данных из таблицы

Проверка на уже существующие базы данных:
+ CREATE DATABASE IF NOT EXIST имя_базы_данных;
+ Перед созданием таблицы необходимо выбрать базу данных, в которую таблица будет записана. Это делается с помощью оператора USE: USE имя_базы_данных.

Для того, чтобы посмотреть описание созданной таблицы можно воспользоваться оператором DESCRIBE: 
+ DESCRIBE Users;

----------
Data Definition Language, DDL – создание структуры базы данных и ее объектов.  Это краткое название языка определения данных, который имеет дело со схемами БД и описаниями того, как данные должны храниться в базе данных. 

<img width="951" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/5756dff5-b929-4218-9970-b71b9743b94d">

Оператор TRUNCATE относится к языку DDL (Data Definition Language - язык определения данных), потому что он изменяет определение таблицы, а не ее данные. 

Когда вы выполняете оператор TRUNCATE, он удаляет все строки из таблицы с помощью операции DROP/CREATE TABLE, что приводит к сбросу определения таблицы до исходных настроек, включая первичные ключи, ограничения, индексы и другие настройки таблицы. Таким образом, оператор TRUNCATE не изменяет данные таблицы, а изменяет ее структуру.

Значительное отличие между операторами DDL и DML заключается в том, что DDL служит для определения структуры базы данных, то есть создания, изменения или удаления объектов базы данных, таких как таблицы, представления, индексы, хранимые процедуры и функции. С другой стороны, DML включает в себя операции для манипулирования данными, например, добавление, изменение или удаление строк в таблице, выборка данных и т.д.

В итоге, оператор TRUNCATE является командой модификации таблицы, но поскольку он выполняет изменения в определении таблицы, а не изменяет данные таблицы, он относится к языку DDL, а не DML.

---------------
DDL - это сокращение от Data Definition Language (язык определения данных). Он представляет собой набор команд, использующихся для создания, изменения и удаления объектов базы данных, таких как таблицы, индексы, представления и т.д.

Вот несколько основных операций, которые могут быть выполнены с помощью DDL:

+ CREATE: Эта операция используется для создания новых объектов в базе данных, таких как таблицы, индексы, представления и т.д. Синтаксис обычно выглядит вот так:
```
CREATE объект (название, структура, параметры)
```
Например:
```
CREATE TABLE employees (id INT PRIMARY KEY, name VARCHAR(50), salary INT); // Это создает таблицу employees с тремя столбцами: id (типа INT), name (типа VARCHAR, максимальной длиной 50 символов) и salary (типа INT).
```
+ ALTER: Эта операция используется для изменения структуры существующих объектов в базе данных, например, для добавления или удаления столбцов таблицы. Синтаксис обычно выглядит вот так:
```
ALTER объект (название) параметры;
```
Например:
```
ALTER TABLE employees ADD email VARCHAR(255); // Это добавляет столбец email к таблице employees.
```
+ DROP: Эта операция используется для удаления объектов из базы данных. Синтаксис обычно выглядит вот так:
```
DROP объект (название);
```
Например:
```
DROP TABLE employees; // Это удаляет таблицу employees из базы данных.
```
+ TRUNCATE: Эта операция также используется для удаления данных из таблицы, но она удаляет все строки из таблицы, но сохраняет саму таблицу. Синтаксис обычно выглядит вот так:
```
TRUNCATE TABLE (название);
```
Например:
```
TRUNCATE TABLE employees; // Это удаляет все строки из таблицы employees, но оставляет саму таблицу в базе данных.
```
+ RENAME: Эта операция используется для переименования объектов в базе данных, таких как таблицы, индексы, представления и т.д. Синтаксис обычно выглядит вот так:
```
RENAME объект (старое название) TO (новое название);
```
Например:
```
RENAME TABLE employees TO staff; // Это переименовывает таблицу employees в staff.
```
[к оглавлению](#sql)

## Что такое DML? Какие операции в него входят? Рассказать про них.

Операторы манипуляции данными (Data Manipulation Language, DML):

SELECT выбирает данные, удовлетворяющие заданным условиям,
```
SELECT [DISTINCT | ALL] поля_таблиц 

FROM список_таблиц 

[WHERE условия_на_ограничения_строк]

[GROUP BY условия_группировки]

[HAVING условия_на_ограничения_строк_после_группировки по агрегатным функциям]

[ORDER BY порядок_сортировки [ASC | DESC]]

[LIMIT ограничение_количества_записей]
```
SQL-псевдонимы: SELECT good_type_id AS id FROM GoodTypes;

Порядок выполнения инструкций (зависит от СУБД):

FROM -> WHERE -> GROUP BY -> HAVING -> SELECT -> DISTINCT -> ORDER BY

В предложении WHERE недоступны псевдонимы столбцов, определяемых в предложении SELECT, потому что, согласно списку, оно выполняется до SELECT WHERE условия_на_ограничения_строк [логический_оператор другое_условия_на_ограничения_строк]

- IS [NOT] NULL — позволяет узнать равно ли проверяемое значение NULL

- [NOT] BETWEEN min AND max

- [NOT] IN — позволяет узнать входит ли проверяемое значение столбца в список определённыхзначений WHERE status IN ('father', 'mother');

- [NOT] LIKE шаблон [ESCAPE символ] — позволяет узнать соответствует ли строка определённому шаблону

Трафаретные символы:
+ never%  Сопоставляется любым строкам, начинающимся на «never».
+ %ing  Сопоставляется любым строкам, заканчивающимся на «ing».
+ _ing Сопоставляется строкам, имеющим длину 4 символа, при этом 3 последних обязательно должны быть «ing». Например, слова «sing» и «wing».
+ ESCAPE-символ используется для экранирования трафаретных символов WHERE progress LIKE '3!%' ESCAPE '!';

Если бы мы не экранировали трафаретный символ, то в выборку попало бы всё, что начинается на 3.

Логические операторы: NOT,  OR (общее значение выражения истинно, если хотя бы одно из них истинно), AND, XOR (общее значение выражения истинно, если один и только один аргумент является истинным)
```
WHERE plane = 'Boeing' AND NOT town_from = 'London';

INSERT добавляет новые данные
Общая структура запроса с оператором INSERT

INSERT INTO имя_таблицы [(поле_таблицы, ...)]

VALUES (значение_поля_таблицы, ...)
```

UPDATE изменяет существующие данные
```
UPDATE FamilyMembers

SET member_name = "Andie Anthony"     что делаем

WHERE member_name = "Andie Quincey"   куда делаем

UPDATE Payments

SET unit_price = unit_price * 2
```
DELETE удаляет данные;
```
DELETE Reservations, Rooms FROM Reservations 

JOIN Rooms ON  Reservations.room_id = Rooms.id 

WHERE Rooms.has_kitchen = false;
```
-----------

<img width="971" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/46bdb2b5-0fd5-43b7-af34-cccd48192f1f">

<img width="954" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/4513fece-107b-42a9-9d6f-6b64b435cdaa">

------------
DML означает "Data Manipulation Language" - язык манипулирования данными. Этот язык используется для добавления, изменения и удаления данных в базе данных. В DML входят следующие операции:

INSERT - операция вставки новых данных в таблицу базы данных. При этом указываются необходимые значения для каждого столбца таблицы.

UPDATE - операция обновления данных в таблице. При этом указывается имя таблицы и значения для обновления.

DELETE - операция удаления данных из таблицы. При этом указывается имя таблицы и условия удаления.

SELECT - операция выборки данных из таблицы. При этом указывается имя таблицы и столбцы, которые необходимо выбрать из таблицы. Также могут применяться условия выборки, с помощью которых можно выбрать только определенные данные из таблицы.

MERGE - операция объединения данных из двух таблиц в одну. При этом указываются две таблицы и условия сопоставления данных из них для объединения.

UPSERT - это комбинированная операция INSERT и UPDATE. Она позволяет вставлять новые данные, если они не существуют в таблице, и обновлять существующие данные, если они уже есть.

CALL - операция вызова хранимой процедуры или функции. При этом указывается имя процедуры или функции и ее параметры.

Все эти операции используются для манипулирования данными в базах данных и позволяют выполнять различные операции, необходимые для работы с данными.

[к оглавлению](#sql)

## Что такое TCL? Какие операции в него входят? Рассказать про них.

TCL (Transaction Control Language) - это часть стандартного языка SQL, используемого для управления транзакциями в базах данных.

Основные операции TCL включают:

COMMIT - команда, которая подтверждает транзакцию и сохраняет все изменения, внесенные в базу данных в рамках этой транзакции. Команда COMMIT гарантирует, что транзакция полностью завершена и изменения станут постоянными.

ROLLBACK - команда, которая отменяет все изменения, внесенные в базу данных в рамках текущей транзакции, и возвращает базу данных к состоянию до начала транзакции. Команда ROLLBACK позволяет откатить транзакцию в случае возникновения ошибок или других проблем.

SAVEPOINT - команда, которая создает точку сохранения в рамках текущей транзакции. Это позволяет откатывать изменения только до этой точки сохранения, а не до начала транзакции. Это может быть полезно, если вы хотите откатить только часть изменений, а не всю транзакцию.

Например, можно создать точку сохранения перед выполнением сложного запроса, чтобы иметь возможность откатиться к этой точке, если запрос вызывает ошибки.

RELEASE - команда, которая удаляет точку сохранения, созданную с помощью команды SAVEPOINT. После выполнения команды RELEASE нельзя будет выполнить команду ROLLBACK до точки сохранения.

BEGIN - команда, которая начинает новую транзакцию. Обычно BEGIN используется неявно, когда выполняется первый оператор изменения данных (INSERT, UPDATE или DELETE) в рамках сессии.

SET TRANSACTION Применяется для установки параметров доступа к данным в текущей транзакции указать, что транзакция предназначена только для чтения, то мы должны использовать следующий запрос:
```
SET TRANSACTION READ ONLY;
```
В целом, TCL команды являются важным инструментом для управления транзакциями в базах данных, позволяя контролировать изменения в базе данных и обеспечивая целостность данных даже в случае возникновения ошибок.

Команды управление транзакциями используются только для DML команд: INSERT, UPDATE, DELETE.

TRUNCATE не используется когда в таблице есть внешние ключи надо использовать делит

<img width="979" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/9fbe642b-e648-46f7-af60-1be0b8484312">

[к оглавлению](#sql)

## Что такое DCL? Какие операции в него входят? Рассказать про них.

Операторы определения доступа к данным (Data Control Language, DCL):

+ GRANT предоставляет пользователю (группе) разрешения на определенные операции собъектом,
+ REVOKE отзывает ранее выданные разрешения,
+ DENY задает запрет, имеющий приоритет над разрешением;

```
Предоставление права чтения таблицы students пользователю alex.

GRANT SELECT ON students TO alex;
```
```
Запрет права выборки из таблицы orders пользователя alex.

DENY SELECT ON orders TO alex;
```
```
Отменить запрет.

REVOKE SELECT ON total FROM piter;
```

-------------
DCL (Data Control Language) - это набор команд в SQL, которые применяются для управления правами доступа и защитой данных в базах данных. Команды DCL выдаются только администратором базы данных или пользователями, у которых есть соответствующие привилегии.

В DCL входят следующие операции:

GRANT: Команда GRANT предоставляет пользователям определенные права доступа к объектам базы данных. Она используется для предоставления прав пользователям на выполнение конкретных операций, таких как SELECT, INSERT, DELETE и UPDATE. Например:
```
GRANT SELECT, INSERT ON employees TO john;
Эта команда предоставляет пользователю john права на выполнение операций SELECT и INSERT на таблице employees.
```
REVOKE: Команда REVOKE отменяет или отзывает права доступа, предоставленные командой GRANT. Например:
```
REVOKE SELECT ON employees FROM john;
Эта команда отменяет у пользователя john право на выполнение операции SELECT на таблице employees.
```
DENY: Команда DENY отказывает в доступе к объектам базы данных. Она используется для запрета на выполнение операций, которые были предоставлены командой GRANT. Например:
```
DENY DELETE ON employees TO john;
Эта команда запрещает пользователю john выполнение операции DELETE на таблице employees.
```
AUDIT: Команда AUDIT позволяет отслеживать действия пользователей в базе данных. Она используется для записи информации о выполненных операциях и изменениях в базе данных. Например:
```
AUDIT SELECT ON employees BY john;
Эта команда записывает информацию о том, когда и как пользователь john выполняет операцию SELECT на таблице employees.
```
ALTER USER: Команда ALTER USER используется для изменения параметров пользователя в базе данных. Например, можно изменить пароль, установить ограничения на использование базы данных, изменить роль пользователя и т.д. Например:
```
ALTER USER john PASSWORD 'new_password';
Эта команда изменяет пароль пользователя john на "new_password".
```
Каждая из этих операций в DCL позволяет управлять правами доступа пользователей к базе данных и осуществлять контроль над безопасностью данных.

<img width="963" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/f5585150-90e6-4fd6-af46-f1140fa650f2">

<img width="955" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/36b6f88e-12c8-42a5-8167-13ee0a437f15">

[к оглавлению](#sql)

## Нюансы работы с NULL в SQL. Как проверить поле на NULL?

NULL - специальное значение (псевдозначение), которое может быть записано в поле таблицы базы данных. NULL соответствует понятию «пустое поле», то есть «поле, не содержащее никакого значения». Введено для того, чтобы различать в полях БД пустые значения и отсутствующие значения. 

NULL означает отсутствие, неизвестность информации. Значение NULL не является значением в полном смысле слова: по определению оно означает отсутствие значения и не принадлежит ни одному типу данных. Поэтому NULL не равно ни логическому значению FALSE, ни пустой строке, ни 0. При сравнении NULL с любым значением будет получен результат NULL, а не FALSE и не 0. Более того, NULL не равно NULL!

команды: IS NULL, IS NOT NULL

<img width="926" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/9ee23d63-6bcf-4dce-a358-71638ec89798">

<=> (эквивалентность, аналогичный оператору равенства, с одним исключением: в отличии от оператора равенства, оператор эквивалентности вернёт ИСТИНУ при сравнении NULL <=> NULL);

IS [NOT] NULL — позволяет узнать равно ли проверяемое значение NULL.

Для примера выведем всех членов семьи, у которых статус  в семье не равен NULL:

<img width="543" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/c46a03c4-2470-48e4-a21d-3975ff6f9089">

Выражение NULL != NULL не будет истинным, ведь нельзя однозначно сравнить одну неизвестность с другой. Кстати, ложным это выражение тоже не будет, потому что при 
вычислении условий Oracle не ограничивается состояниями ИСТИНА и ЛОЖЬ. Из-за наличия элемента неопределённости в виде NULLа существует ещё одно состояние — НЕИЗВЕСТНО.

Попробуем выбрать все записи, которые входят в набор (1, 2, NULL):

<img width="677" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/e16fa4da-4427-4a12-81bb-9d73743086af">

Как видим, строка с NULLом не выбралась. Произошло это из-за того, что вычисление предиката "A"=TO_NUMBER(NULL) вернуло состояние НЕИЗВЕСТНО. Для того, чтобы включить NULLы в результат запроса, придётся указать это явно:

<img width="842" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/a17750d0-6608-4a7f-8ddb-2944d097f9cc">

При использовании функции EXISTS в SQL запросе, поля со значением NULL не будут обнаружены.

Функция EXISTS используется для проверки, существуют ли строки в подзапросе. Она возвращает значение TRUE, если подзапрос возвращает хотя бы одну строку, и FALSE, если подзапрос не возвращает строк.

[к оглавлению](#sql)

## Виды Joinов (виды связывания таблиц)

https://sql-academy.org/ru/guide/multi-table-request-join

Что такое JOIN?
JOIN - оператор языка SQL, который является реализацией операции соединения реляционной алгебры. Предназначен для обеспечения выборки данных из двух таблиц и включения этих данных в один результирующий набор.

Особенностями операции соединения являются следующее:
+ в схему таблицы-результата входят столбцы обеих исходных таблиц (таблиц-операндов), то есть схема результата является «сцеплением» схем операндов;
+ каждая строка таблицы-результата является «сцеплением» строки из одной таблицы-операнда со строкой второй таблицы-операнда;
+ при необходимости соединения не двух, а нескольких таблиц, операция соединения применяется несколько раз (последовательно).
```
SELECT
  field_name [,... n]
FROM
  Table1
  {INNER | {LEFT | RIGHT | FULL} OUTER | CROSS } JOIN
  Table2
    {ON <condition> | USING (field_name [,... n])}
```
Какие существуют типы JOIN?

(INNER) JOIN Результатом объединения таблиц являются записи, общие для левой и правой таблиц. Порядок таблиц для оператора не важен, поскольку оператор является симметричным.

LEFT (OUTER) JOIN Производит выбор всех записей первой таблицы и соответствующих им записей второй таблицы. Если записи во второй таблице не найдены, то вместо них подставляется пустой результат (NULL). Порядок таблиц для оператора важен, поскольку оператор не является симметричным.

RIGHT (OUTER) JOIN (LEFT JOIN с операндами, расставленными в обратном порядке). Порядок таблиц для оператора важен, поскольку оператор не является симметричным.

FULL (OUTER) JOIN Результатом объединения таблиц являются все записи, которые присутствуют в таблицах. Порядок таблиц для оператора не важен, поскольку оператор является симметричным.

CROSS JOIN (декартово произведение) При выборе каждая строка одной таблицы объединяется с каждой строкой второй таблицы, давая тем самым все возможные сочетания строк двух таблиц. Порядок таблиц для оператора не важен, поскольку оператор является симметричным.

<img width="556" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/e14cbfbe-bca1-483b-9e6d-039d89e52bff">

Что лучше использовать JOIN или подзапросы?

Обычно лучше использовать JOIN, поскольку в большинстве случаев он более понятен и лучше оптимизируется СУБД (но 100% этого гарантировать нельзя). Так же JOIN имеет заметное преимущество над подзапросами в случае, когда список выбора SELECT содержит столбцы более чем из одной таблицы.

Подзапросы лучше использовать в случаях, когда нужно вычислять агрегатные значения и использовать их для сравнений во внешних запросах.

-------------
Часто приходится делать выборку из нескольких таблиц, каким-то образом объединяя их. Общая структура многотабличного запроса:

<img width="711" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/ec1b2e28-6284-465a-b2ac-f4881b3280c2">

В большинстве случаев условием соединения является равенство столбцов таблиц (таблица_1.поле = таблица_2.поле), однако точно так же можно использовать и другие операторы сравнения. Соединение бывает внутренним INNER или внешним OUTER. При этом внешнее соединение делится на левое (LEFT), правое (RIGHT) и полное (FULL). 
 
**INNER JOIN**

<img width="692" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/160ec9f5-4ebd-466c-b09c-1f7846b6d8ab">

По умолчанию, если не указаны какие-либо параметры, JOIN выполняется как INNER JOIN, то есть как внутреннее (перекрёстное) соединение таблиц. 

Например, объединим таблицы покупок Payments и членов семьи FamilyMembers таким образом, чтобы дополнить каждую покупку данными о том, кто её совершил. 
 
Для того, чтобы решить поставленную задачу выполним запрос, который объединяет поля строки из одной таблицы с полями другой, если выполняется условие, что покупатель товара family_member совпадает с идентификатором члена семьи member_id: 

<img width="656" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/19993b6f-814a-48bd-ba65-b668699b9864">

<img width="1213" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/9d3c9580-7d56-4d1d-bbb4-fe9f5aa9d61f">

Для внутреннего соединения таблиц также можно использовать оператор WHERE. 

Например, вышеприведённый запрос, написанный с помощью INNER JOIN, будет выглядеть так:

<img width="465" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/f54e1194-bd0c-4069-a8b5-5ca554192339">

<img width="1202" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/c91bb6d7-6057-4fe0-a5b8-9adc84b647c1">

**OUTER JOIN**
 
Внешнее соединение может быть трёх типов: левое (LEFT), правое (RIGHT) и полное (FULL). По умолчанию оно является полным. 
 
Главным отличием внешнего соединения от внутреннего является то, что оно обязательно возвращает все строки одной (LEFT, RIGHT) или двух таблиц (FULL). 
 
**Внешнее левое соединение (LEFT OUTER JOIN)**

<img width="697" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/b3ead567-b7f2-4373-9e6a-64ec994e90cb">
 
Соединение, которое возвращает все значения из левой таблицы, соединённые с соответствующими значениями из правой таблицы если они удовлетворяют условию соединения, или заменяет их на NULL в обратном случае. 

Для примера получим из базы данных расписание звонков объединённых с соответствующими занятиями в расписании занятий:

<img width="640" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/5a4f4ee3-08ae-4484-b688-508a8cd89579">

<img width="1203" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/e2417147-f6f5-4183-bb36-320aa2e5edc3">

**Внешнее правое соединение (RIGHT OUTER JOIN)**

<img width="698" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/b032ae90-3bfa-44bf-b5a0-8736a0011d86">
 
Соединение, которое возвращает все значения из правой таблицы, соединённые с соответствующими значениями из левой таблицы если они удовлетворяют условию соединения, или заменяет их на NULL в обратном случае.

<img width="1180" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/18bfd3ca-ae5b-4ecb-9cc1-1181e5b802ad">

Выборка формируется по уникальным книгам. Слева в результирующий набор попала Энциклопедия без автора. Аналогичную выборку получим при использовании Full Join.  А справа, т.к. используем RIGHT JOIN, то книга без автора в выборку не попадает. 

**Внешнее полное соединение (FULL OUTER JOIN)**

<img width="721" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/a29dc943-b485-4f47-baac-0936c9bc8313">
 
Соединение, которое выполняет внутреннее соединение записей и дополняет их левым внешним соединением и правым внешним соединением. 

Алгоритм работы полного соединения: 
+ Формируется таблица на основе внутреннего соединения (INNER JOIN). 
+ В таблицу добавляются значения не вошедшие в результат формирования из левой таблицы (LEFT OUTER JOIN). 
+ В таблицу добавляются значения не вошедшие в результат формирования из правой таблицы (RIGHT OUTER JOIN). 
 
Соединение FULL JOIN реализовано НЕ во всех СУБД. Например, в MySQL оно отсутствует, однако его можно очень просто эмулировать. 

Базовые запросы для разных вариантов объединения таблиц (запрос Join и схема): 

<img width="1220" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/830522b4-b4ff-4e8a-a3e9-b5d1a91bceb9">

<img width="1218" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/dedf0f86-e7c8-4492-9278-fb8369386f31">

[к оглавлению](#sql)

## Что лучше использовать join или подзапросы? Почему?

Обычно лучше использовать JOIN, поскольку в большинстве случаев он более понятен и лучше оптимизируется СУБД (но 100% этого гарантировать нельзя). Так же JOIN имеет заметное преимущество над подзапросами в случае, когда список выбора SELECT содержит столбцы более чем из одной таблицы.

Подзапросы лучше использовать в случаях, когда нужно вычислять агрегатные значения и использовать их для сравнений во внешних запросах.

Пример подзапроса (вложенный запрос + математическая операция): 

<img width="1055" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/f7cdc609-ba8f-4358-b28a-3a56b982e28c">

Alias (псевдоним) — это имя, назначенное источнику данных в запросе при использовании выражения в качестве источника данных или для упрощения ввода и прочтения инструкции SQL.  

Это м.б. полезно, если имя источника данных слишком длинное или его трудно вводить.

<img width="1216" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/18ec87aa-efd0-4e36-9d1a-6e87cd27453b">

Какой метод использовать, join или подзапросы, зависит от конкретной ситуации и, в частности, от объема данных и структуры таблиц.

Join предпочтительнее использовать в случаях, когда нужно объединить данные из двух и более таблиц, используя общие столбцы. Join часто работает быстрее, так как позволяет выполнить один запрос к базе данных, вместо нескольких запросов, как в случае с использованием подзапросов. Кроме того, join легче читать, понимать и отлаживать, чем запросы с подзапросами.

Однако, в некоторых сценариях может быть предпочтительнее использовать подзапросы. Например, если нужно выполнить запрос на выборку данных из подмножества записей таблицы, которые соответствуют определенному условию, то лучше использовать подзапросы. Также подзапросы могут быть полезны в случаях, когда один из запросов зависит от результатов другого запроса.

В целом, выбор между join и подзапросами зависит от специфики задачи и изучения производительности каждого метода в конкретной ситуации. Лучше всего проводить тестирование и выбирать тот метод, который наиболее эффективно решает задачу и работает быстро для конкретной базы данных.

[к оглавлению](#sql)

## Что делает UNION?

Объединяет запросы в одну таблицу
```
SELECT поля_таблиц FROM список_таблиц ...

UNION [ALL] 

SELECT поля_таблиц FROM список_таблиц ... ;
```
UNION по умолчанию убирает повторения в результирующей таблице. Для отображения с повторением есть необязательный параметр ALL.

Не путайте операции объединения запросов с операциями объединения таблиц. Для этого служит оператор JOIN.

Не путайте операции объединения запросов с подзапросами. Подзапросы выполняются для связанных таблиц.

Объединение таблиц оператором UNION выполняется для таблиц никак не связанных, но со схожей структурой.
```
SELECT DISTINCT Goods.good_name AS name FROM Goods

UNION

SELECT DISTINCT FamilyMembers.member_name AS name FROM FamilyMembers;
```
Скидывает все значения в один столбец (сначала первая таблица, потом вторая)

Для того, чтобы UNION корректно сработал нужно: чтобы результирующие таблицы каждого из SQL запросов имели одинаковое число столбцов, с одним и тем же типом данных и в той же самой последовательности.

-----------------

В языке SQL ключевое слово UNION применяется для объединения результатов двух SQL-запросов в единую таблицу, состоящую из схожих записей.  
 
Оба запроса должны возвращать одинаковое число столбцов и совместимые типы данных в соответствующих столбцах.  
 
UNION ALL выборка будет включать дубликаты. 

Необходимо отметить, что UNION сам по себе не гарантирует порядок записей. Записи из второго запроса могут оказаться в начале, в конце или вообще перемешаться с записями из первого запроса.  

В случаях, когда требуется определенный порядок, необходимо использовать ORDER BY. 

<img width="1233" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/b2a3f752-f5c6-479b-ab01-711e5312e67c">

---------
Оператор UNION используется в SQL для объединения результатов двух или более запросов в единый набор результатов. Как правило, эти запросы имеют одинаковую структуру и возвращают одинаковый набор столбцов.

Синтаксис оператора UNION выглядит следующим образом:
```
SELECT column_name(s) FROM table1
UNION
SELECT column_name(s) FROM table2;
```
Оператор UNION удаляет дублирующиеся строки из результирующего набора, что позволяет объединять данные из нескольких таблиц или результаты нескольких запросов в единую таблицу или набор результатов. При этом, столбцы в результирующей таблице будут соответствовать столбцам в исходных таблицах.

Например, такой SQL запрос:
```
SELECT company_name, city FROM customers
UNION
SELECT company_name, city FROM suppliers;
```
вернет уникальный набор строк, где каждая строка содержит имя компании и город из таблицы customers и suppliers.

[к оглавлению](#sql)

## Чем WHERE отличается от HAVING? 

https://www.youtube.com/watch?v=FRy88_ICu9g

Если нужно применить условие к столбцу, который является результатом группировки, то используем HAVING, в остальных случаях обычно используем WHERE, т.е. сначала фильтруем таблицу по какому-то условию (WHERE), а потом её группируем(GROUP BY). Так происходит потому что WHERE выполняется до GROUP BY, соответственно поля, которые появляются после GROUP BY не видны для WHERE.

(ответа про то что используются в разных частях запроса - недостаточно

Отличие HAVING от WHERE:

+ WHERE — сначала выбираются записи по условию, а затем могут быть сгруппированы, отсортированы и т.д. Это ограничивающее выражение. Оно выполняется до того, как будет получен результат операции.
+ HAVING — сначала группируются записи, а затем выбираются по условию, при этом, в отличие от WHERE, в нём можно использовать значения агрегатных функций;
+ Выражения WHERE используются вместе с операциями SELECT, UPDATE, DELETE, в то время как HAVING только с SELECT и предложением GROUP BY. То есть, использовать WHERE в запросах с агрегатными функциями нельзя, для этого и был введен HAVING.

-------------
Условный оператор WHERE применяют в ситуациях, когда требуется сделать выборку по определенному условию  (часто используется).  

<img width="648" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/fd127434-83f4-4346-8fb2-8146a83c1b24">

Для этого в операторе SELECT существует параметр WHERE, после которого следует условие для ограничения строк. Если запись удовлетворяет этому условию, то попадает в результат, иначе отбрасывается. 
 
Выведем все полёты, которые были совершены на самолёте «Boeing», но, при этом, вылет был не из Лондона: 

<img width="642" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/03457b3c-5701-4e57-8b50-7e2d43b03664">

Оператор HAVING используется для фильтрации строк по значениям агрегатных функций.  
 
Общая структура запроса:

<img width="637" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/c874afbb-e871-436a-9311-d8f573833731">

**Отличие HAVING от WHERE**
 
WHERE = ВЫБОРКА + ГРУППИРОВКА, то есть сначала выбираются записи по условию, а затем могут быть сгруппированы, отсортированы и т.д. 
 
HAVING = ГРУППИРОВКА + ВЫБОРКА, т.е. сначала группируются записи, а затем выбираются по условию, при этом, в отличие от WHERE, в нём можно использовать значения агрегатных функций. 
 
Пример использования:  выведем общую сумму, потраченную на покупки, для каждого члена семьи, где общая  сумма покупки меньше, чем 5000 рублей: 

<img width="555" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/7f2888d5-9aaa-47ab-9c15-886890ae7bb7">

---------
Для чего используется оператор HAVING?

HAVING используется для фильтрации результата GROUP BY по заданным логическим условиям.

В чем различие между операторами HAVING и WHERE?

HAVING используется как WHERE, но в другой части SQL-выражения и, соответственно, на другой стадии формирования ответа.


[к оглавлению](#sql)

## Что такое GROUP BY?   
 
Иногда требуется узнать информацию не о самих объектах, а об определенных группах, которые они образуют. Для этого используется оператор GROUP BY и агрегатные функции. 

Общая структура запроса:

<img width="774" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/cde0eefd-e276-485f-8678-de09303c5a07">

Пример использования: выведем общую сумму, потраченную на покупки, для каждого члена семьи, где общая сумма покупки менее 5000 руб.:

<img width="782" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/1489d125-47df-4a45-b55e-da99df54f11f">

При выполнении запроса происходит группировка по полю family_member и суммирование общей суммы, потраченной на покупки каждым из членов семьи.

<img width="1171" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/4c214c02-0984-4ddc-b7ab-1db6cbbd5374">

-------------
GROUP BY — это оператор в SQL (Structured Query Language), языке запросов к базам данных, который позволяет группировать данные и вычислять агрегированные функции по набору сгруппированных строк. Когда необходимо выполнять расчеты на группах строк, а не на отдельных записях, применяется GROUP BY.

Оператор GROUP BY используется вместе с агрегатными функциями, такими как COUNT (подсчет записей), SUM (сумма значений), AVG (среднее значение), MAX (максимальное значение) и MIN (минимальное значение) для получения сведений об одной или нескольких групп записей.

Пример использования GROUP BY:

Допустим, у вас есть таблица "sales" со следующими столбцами: id, product_id, sale_date и sales_amount. Если вы хотите узнать общий объем продаж для каждого продукта, вы можете использовать следующий запрос:
```
SELECT product_id, SUM(sales_amount) as total_sales
FROM sales
GROUP BY product_id;
```
В этом случае, будет выведена информация о сумме продаж (total_sales) для каждого уникального product_id, сгруппированных по product_id.

> Почему нельзя использовать только group by, без sum в данном случае?
>
> Если вы используете только оператор GROUP BY без функции агрегирования SUM(), то запрос вернет строки, группируя данные по столбцу "product_id", но не будет производить вычисления общего объема продаж.
>
> Это связано с тем, что оператор GROUP BY просто группирует строки по указанному столбцу, но не выполняет агрегационные функции над другими столбцами. Он используется для создания отдельных групп по значениям выбранного столбца.
>
> В вашем случае, без функции агрегирования SUM(), результат будет содержать только уникальные значения столбца "product_id", без объединения или суммирования значений столбца "sales_amount". Вы не получите общего объема продаж для каждого продукта.
>
> Итак, чтобы получить общий объем продаж для каждого продукта, вам необходима функция агрегирования SUM(), которая суммирует значения столбца "sales_amount" в каждой группе, сформированной с помощью оператора GROUP BY.

-------
В общем случае, GROUP BY оператор в SQL выполняется для группировки строк в результирующем наборе по значению одного или нескольких столбцов.

Таким образом, GROUP BY может быть выполнен только по одному столбцу или по нескольким столбцам вместе. В случае, когда используется более одного столбца, запрос сгруппирует строки по уникальным комбинациям значений этих столбцов.

Пример использования оператора GROUP BY с несколькими столбцами:

SELECT col1, col2, COUNT(*)
FROM my_table
GROUP BY col1, col2;

В этом примере запроса, строки группируются по уникальным комбинациям значений col1 и col2, и производится подсчет количества строк для каждой комбинации значений.

[к оглавлению](#sql)

## Что такое ORDER BY?

При выполнении SELECT запроса, строки по умолчанию возвращаются в неопределенном порядке.  
 
Фактический порядок строк в этом случае зависит от плана соединения и сканирования, а также от порядка расположения данных на диске, поэтому полагаться на него нельзя.  Для упорядочивания записей используется конструкция ORDER BY. 
 
Общая структура запроса ORDER BY

<img width="610" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/37b3257f-9658-4613-afd5-c81126a30689">

В этой структуре запроса необязательные параметры указаны в квадратных скобках: 

<img width="882" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/49bf6fd2-f02c-4d22-b6e8-ddb7d76118f6">
<img width="372" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/daf7f4bc-f792-4335-9f2d-801d6b3e0627">

DESCending переводится, как: нисходящий, убывающий, падающий. ASCending переводится, как: восходящий, поднимающийся возрастающий.  

**Сортировка по нескольким столбцам**

Для сортировки результатов по двум или более столбцам их следует указывать через запятую.

<img width="651" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/27dac495-858b-4e7f-b494-c5e324237d2e">

Данные будут сортироваться по первому столбцу, но, в случае если попадаются несколько записей с совпадающими значениями в первом столбце, то они сортируются по второму столбцу. Количество столбцов, по которым можно отсортировать, не ограничено. 

Правило сортировки применяется только к тому столбцу, за которым оно следует

<img width="497" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/46541074-d7cb-483b-a120-dbf62778905b">

<img width="1078" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/ee1715bf-f0cf-4cb0-8a0b-73bc22e80583">

[к оглавлению](#sql)

## Что такое DISTINCT?

Оператор SQL DISTINCT используется для указания на то, что следует работать только с уникальными значениями столбца.

Может использоваться с агрегатными функциями
```
SELECT COUNT(DISTINCT Singer) 

AS CountOfSingers

FROM Artists
```

DISTINCT используется для исключения повторяющихся строк из результата. 
 
Иногда возникают ситуации, в которых нужно получить только уникальные записи. Для этого вы можете использовать DISTINCT.  
 
Например, выведем список городов без  повторений, в которые летали самолеты:

<img width="467" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/b2943371-d051-4910-9df3-b06a41ffa753">
 
Справа применяем ключевое слово DISTINCT, получаем выборку по уникальным именам. 

<img width="1052" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/681a6af4-d50f-4f0e-95ac-5db7af6649bd">

[к оглавлению](#sql)

## Что такое LIMIT?
```
SELECT поля_выборки

FROM список_таблиц

LIMIT [количество_пропущенных_записей,] количество_записей_для_вывода;
```
когда необходимо сделать отступ от начала таблицы, предназначена конструкция OFFSET FETCH

Для того, чтобы вывести строки с 3 по 5, нужно использовать такой запрос:
```
SELECT * FROM Company LIMIT 2, 3;
```

-----------------
Устанавливаем ограничение на максимальное количество записей, которые хотим получить в результирующем наборе. Например, вывести 
уникальные имена, но не более двух:

<img width="467" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/c4ee8db6-6b2f-4acd-91c3-0ee7ed7ca921">
 
Вывести все уникальные фамилии из списка. Пропустить две (OFFSET 2), оставить в результате две записи (LIMIT 2). Первые две уникальные записи: Пушкин и Дюма пропущены, Чехов и Толстой остаются. 

<img width="1024" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/40e6695e-d81b-4c0d-8186-b9db083f45ba">

**Важно!**

Когда мы делаем выборку SELECT FROM, то порядок НЕ гарантирован и может меняться в зависимости от вставки или индекса. Поэтому сначала нужно сделать сортировку 
(например, по идентификатору), а потом добавлять ограничение LIMIT и OFFSET. 
 
Для сортировки используем ORDER BY (см. выше). 

-----
Да, конструкции "LIMIT 2,3" и "LIMIT 3 OFFSET 2" в SQL эквивалентны и будут давать одинаковый результат на отсортированной таблице.

Обе конструкции используются для ограничения числа записей, которые будут возвращены в запросе. Обе конструкции начинают со смещения, который определяет, с какой записи начинать возвращать результаты, а также указывают количество записей, которое нужно пропустить.

[к оглавлению](#sql)

## Что такое EXISTS?

EXISTS - это оператор SQL, который используется для проверки наличия строк, удовлетворяющих определенным условиям в таблице. Синтаксис оператора EXISTS выглядит следующим образом:

```
SELECT column_name(s)
FROM table_name
WHERE EXISTS (subquery);
```

Подзапрос, переданный оператору EXISTS, возвращает набор строк. Если набор строк не пустой (т.е. есть хотя бы одна строка), то оператор EXISTS возвращает значение TRUE. В противном случае он возвращает значение FALSE. 

Когда подзапрос возвращает NULL, оператор EXISTS также возвращает NULL. Это происходит потому, что SQL определяет NULL для результатов выражений, которые возвращают ноль строк. Если подзапрос возвращает NULL, значит, мы не можем установить, была ли найдена какая-либо строка, удовлетворяющая условиям, поэтому результатом будет NULL.

--------------
EXISTS - это оператор условия в языке SQL (Structured Query Language), который используется для проверки наличия строк в таблице, соответствующих заданному условию.

Синтаксис оператора EXISTS:
```
SELECT column1, column2, ...
FROM table_name
WHERE EXISTS (SELECT column1 FROM table_name WHERE condition);
```
Где:

+ column1, column2, ... - список выбранных столбцов в исходной таблице;
+ table_name - имя таблицы, в которой нужно производить поиск;
+ condition - условие, которое нужно проверить для наличия строк в таблице.

Оператор EXISTS вернет значение TRUE, если подзапрос вернет хотя бы одну строку. Использование этого оператора может быть полезным, если вы хотите проверить, есть ли в таблице хотя бы одна строка, которая соответствует определенному условию, и выполнить соответствующие действия на основе результата.

[к оглавлению](#sql)

## Расскажите про операторы IN, BETWEEN, LIKE. 
 
Ключевое слово LIKE используем, когда нужно сделать выборку по полю (тут по имени). Можем указать любое поле и даже только одну букву

<img width="342" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/096bd3c0-ecb5-4c9b-a062-47aba84867d1">

LIKE чувствителен к регистру (‘alex’ в выборку не попадёт). 

<img width="1023" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/dfc7bfde-eb40-41c9-a2b6-a78d90b389a5">

Если в результирующий набор должны попасть данные в заданном диапазоне (например, зарплата сотрудников), то используем ключевое слово BETWEEN (удобен также для дат).

<img width="1026" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/34f5b9b9-5610-4258-aaa9-c1bb39954f24">

Если в выборку должны попасть результаты с конкретными данными, то используем IN:

<img width="1017" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/74d1c877-0bb0-42e9-8e45-b9339cb0468c">

-----
Для чего используются операторы IN, BETWEEN, LIKE?

IN - определяет набор значений.
```
SELECT * FROM Persons WHERE name IN ('Ivan','Petr','Pavel');
```
BETWEEN определяет диапазон значений. В отличие от IN, BETWEEN чувствителен к порядку, и первое значение в предложении должно быть первым по алфавитному или числовому порядку.
```
SELECT * FROM Persons WHERE age BETWEEN 20 AND 25;
```
LIKE применим только к полям типа CHAR или VARCHAR, с которыми он используется чтобы находить подстроки. В качестве условия используются символы шаблонизации (wildkards) - специальные символы, которые могут соответствовать чему-нибудь:
+ _ замещает любой одиночный символ. Например, 'b_t' будет соответствовать словам 'bat' или 'bit', но не будет соответствовать 'brat'.
+ % замещает последовательность любого числа символов. Например '%p%t' будет соответствовать словам 'put', 'posit', или 'opt', но не 'spite'.
```
SELECT * FROM UNIVERSITY WHERE NAME LIKE '%o';
```
Да, оператор LIKE может быть использован для сравнения значений полей с типом данных TEXT в большинстве реляционных баз данных.

Оператор LIKE используется для выполнения сравнения по шаблону с использованием символов замены. Например, можно использовать оператор LIKE для поиска записей, содержащих заданный текст или соответствующие образцы символов. Например:

```
SELECT * FROM myTable WHERE myField LIKE '%example%';
```

Этот запрос выберет все записи из таблицы `myTable`, где поле `myField` содержит строку "example". Символ `%` используется в качестве символа замены, чтобы указать, что вместо него может быть любая последовательность символов.

Важно знать, что оператор LIKE не обязательно является самым эффективным способом выполнения поиска в больших таблицах, поэтому в таких случаях может быть необходимо использовать более сложные методы, например, полнотекстовый поиск.

ESCAPE-символ используется для экранирования трафаретных символов. Например, вы хотите получить идентификаторы задач, прогресс которых равен 3%:
```
SELECT job_id FROM Jobs

WHERE progress LIKE '3!%' ESCAPE '!';
```
[к оглавлению](#sql)

## Что делает оператор MERGE? Какие у него есть ограничения?

https://www.youtube.com/watch?v=3hNbQjX738I

MERGE позволяет осуществить слияние данных одной таблицы с данными другой таблицы.

При слиянии таблиц проверяется условие, и если оно истинно, то выполняется UPDATE, а если нет - INSERT. При этом изменять поля таблицы в секции UPDATE, по которым идет связывание двух таблиц, нельзя.

Является командой DML.

<img width="543" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/a0732780-7eef-4f1f-bdfd-f9bea6357a51">

<img width="1034" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/ea7e0416-77db-49c1-94a6-c9a9531c5be8">

Для удаления записей в результате операции объединения (merge) в SQL можно использовать ключевое слово DELETE.

Пример использования операции DELETE в операции объединения для удаления записей из таблицы target_table:

```
MERGE INTO target_table AS t
USING source_table AS s 
      ON (t.join_column = s.join_column)
WHEN MATCHED THEN 
      UPDATE SET t.col1 = s.col1, t.col2 = s.col2 
WHEN NOT MATCHED BY SOURCE THEN
      DELETE
WHEN NOT MATCHED THEN 
      INSERT (join_column, col1, col2) 
      VALUES (s.join_column, s.col1, s.col2);
```

Этот пример удалит записи из target_table, которые не имеют соответствия в source_table.

------------
Некоторые ограничения оператора MERGE могут варьироваться в зависимости от используемой системы управления базами данных (СУБД), но существует ряд общих ограничений:

+ Совместимость СУБД: Оператор MERGE не поддерживается во всех СУБД. Например, MySQL и SQLite не поддерживают MERGE, а SQL Server, Oracle и PostgreSQL его поддерживают. В MySQL используется аналогичный оператор ON DUPLICATE KEY UPDATE для реализации подобной функциональности.

+ Определение соединения: В операторе MERGE должно быть четко указано условие соединения (ON) между исходной и целевой таблицами. Его нельзя опустить или использовать некорректные условия.

+ Редукция условий: Оператор MERGE не всегда упрощает структуру SQL запроса и результат такого запроса может быть сложно понять и отслеживать.

+ Возможность блокировок и гонок: Оператор MERGE может привести к блокировкам таблиц или возникновению гонок в некоторых многопоточных сценариях изменения данных. Важно аккуратно использовать транзакции и подходящие параметры изоляции транзакций для предотвращения таких ситуаций.

+ Правила обработки исключений: В MERGE необходимо определять правила обработки исключений (WHEN MATCHED, WHEN NOT MATCHED), которые определяют, какие действия должны быть предприняты в зависимости от результата соединения.

+ Невозможность выполнения одного действия несколько раз: В некоторых реализациях MERGE одно действие (INSERT, UPDATE, DELETE) может быть выполнено только один раз для каждой строки из исходной таблицы, что может накладывать дополнительные ограничения на структуру запроса.

+ Чувствительность к ошибкам: Если MERGE реализован неверно, возможны ошибки изменения данных, такие как создание дубликатов, случайное удаление или изменение данных.

Ограничения оператора MERGE могут варьироваться между различными СУБД, поэтому, прежде чем использовать MERGE, убедитесь, что ознакомились с документацией и особенностями своей СУБД.

[к оглавлению](#sql)

## Какие агрегатные/ агрегирующие функции вы знаете?

Агрегатная функция – это функция, которая выполняет вычисление на наборе значений и возвращает одиночное значение.

В SQL существует несколько встроенных агрегатных функций, таких как:

1. Сумма (SUM) - вычисляет сумму всех значений в колонке
2. Среднее (AVG) - вычисляет среднее значение всех значений в колонке
3. Минимум (MIN) - находит наименьшее значение в колонке
4. Максимум (MAX) - находит наибольшее значение в колонке
5. Количество (COUNT) - находит количество значений в колонке

Например, чтобы найти сумму всех значений в колонке "price" в таблице "products", мы можем использовать следующий запрос:

SELECT SUM(price) FROM products;

Аналогично, чтобы найти количество записей в таблице "products", мы можем использовать следующий запрос:

SELECT COUNT(*) FROM products;

Обратите внимание, что агрегатные функции могут использоваться с оператором GROUP BY, который позволяет вычислять значения по группам (например, группировать данные по значениям в другой колонке).

Агрегатные функции - это функции, которые выполняются на основе группировки записей в таблице по определенным критериям. Они используются в сочетании с командой GROUP BY для выполнения расчетов на основе указанных групп данных.

-------------

Агрегатная функция вычисляет единственное значение (получаем ОДНУ строку), обрабатывая множество строк.  Агрегатные функции (иногда называют агрегирующие) есть во всех СУБД. 
 
Агрегатные функции, вычисляющие по столбцу для набора строк:  
+ sum (сумму)
+ avg (среднее)
+ max (максимум)
+ min (минимум)  
+ count (количество), есть также вариант со звёздочкой: SELECT count(*) FROM employees;
+ concat (конкатенация, например, объединение имени и фамилии в одном столбце) 

Не агрегатные математические функции (их много) – применяют действие ко всем значениям в столбце: 
+ upper/lower (перевод в верхний/нижний регистр)
+ now (текущая дата и т.д.) 

<img width="1049" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/a182bc83-13c9-4203-8b18-677d4f4d5f9f">

В чем разница между COUNT(*) и COUNT({column})?

COUNT (*) подсчитывает количество записей в таблице, не игнорируя значение NULL, поскольку эта функция оперирует записями, а не столбцами.

COUNT ({column}) подсчитывает количество значений в {column}. При подсчете количества значений столбца эта форма функции COUNT не принимает во внимание значение NULL.

**Важно понимать, как соотносятся агрегатные функции и SQL-предложения WHERE и HAVING.**
 
Основное отличие WHERE от HAVING заключается в том, что WHERE сначала выбирает строки, а затем группирует их и вычисляет агрегатные функции (таким образом, она отбирает строки для вычисления агрегатов), тогда как HAVING  отбирает строки групп после группировки и вычисления агрегатных функций. Следовательно… 
 
WHERE НЕ должно содержать агрегатных функций; не имеет смысла использовать агрегатные функции для определения строк для вычисления агрегатных функций. 

**HAVING всегда СОДЕРЖИТ агрегатные функции!** 
 
Строго говоря, вы можете написать предложение HAVING, не используя агрегаты, но это редко бывает полезно. То же самое условие может работать более эффективно на стадии WHERE.) 

<img width="1047" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/c6c550e5-e11d-43f2-b046-04f89e130aab">

[к оглавлению](#sql)

## Что такое ограничения (constraints)? Какие вы знаете? 

Ограничения SQL — это правила, применяемые к столбцам данных таблицы.  
 
Они используются, чтобы ограничить типы данных, которые могут храниться в таблице. Ограничения могут применяться либо на уровне столбцов, либо на уровне таблицы. Это обеспечивает точность и надежность данных в базе.

<img width="508" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/a785f170-b225-4678-a08f-32dde54145fc">

NOT NULL – возможность вставки пустых значений в колонку таблицы.

CHECK – ограничение на диапазон значений (год для даты, например) 

UNIQUE – значение в этой колонкe должно быть уникальным. 
 
PRIMARY KEY (pkey) колонка содержит уникальное NOT NULL значение (часто это ID). Может быть только одним в таблице! В отличие от UNIQUE, например (ограничение для столбца, но не для таблицы).  
 
FOREIGN KEY (fkey) защищает от действий, которые могут нарушить связи между таблицами. FOREIGN KEY в одной таблице указывает на PRIMARY KEY в другой. Поэтому данное ограничение нацелено на то, чтобы не было записей FOREIGN KEY, которым не отвечают записи PRIMARY KEY. 

<img width="802" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/582773d4-fa70-40e3-8694-17429dd61d5d">

Есть также неявные ограничения, например по количеству символов для VARCHAR (аналог строки, последовательность символов в одинарных кавычках). Указывается в круглых скобках. Один символ char = 1 байт памяти, соответственно 128 – это и количество символов, и количество памяти. 

<img width="1013" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/533dd4e9-aa91-4c18-a66a-5b7a7689a24e">

При попытке «обойти ограничение» (указан год, меньше, чем 1995), вылетает ошибка:

<img width="1025" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/2fab8f52-30f7-47b3-90f4-dd7021e1f040">

---------
Какие ограничения на целостность данных существуют в SQL?
+ PRIMARY KEY - набор полей (1 или более), значения которых образуют уникальную комбинацию и используются для однозначной идентификации записи в таблице. Для таблицы может быть создано только одно такое ограничение. Данное ограничение используется для обеспечения целостности сущности, которая описана таблицей.
+ CHECK используется для ограничения множества значений, которые могут быть помещены в данный столбец. Это ограничение используется для обеспечения целостности предметной области, которую описывают таблицы в базе.
+ UNIQUE обеспечивает отсутствие дубликатов в столбце или наборе столбцов.
+ FOREIGN KEY защищает от действий, которые могут нарушить связи между таблицами. FOREIGN KEY в одной таблице указывает на PRIMARY KEY в другой. Поэтому данное ограничение нацелено на то, чтобы не было записей FOREIGN KEY, которым не отвечают записи PRIMARY KEY.

Какие отличия между ограничениями PRIMARY и UNIQUE?

По умолчанию ограничение PRIMARY создает кластерный индекс на столбце, а UNIQUE - некластерный. Другим отличием является то, что PRIMARY не разрешает NULL записей, в то время как UNIQUE разрешает одну (а в некоторых СУБД несколько) NULL запись.

Может ли значение в столбце, на который наложено ограничение FOREIGN KEY, равняться NULL?

Может, если на данный столбец не наложено ограничение NOT NULL.

------
Про размер VARCHAR в Postgresql

<img width="504" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/29d9b7eb-167e-4922-ab5e-c6d302c09eec">

[к оглавлению](#sql)

## Что такое суррогатные ключи?

Суррогатный ключ — понятие теории реляционных баз данных. Это дополнительное служебное поле, добавленное к уже имеющимся информационным полям таблицы, единственное предназначение которого — служить первичным ключом Primary Key. 

<img width="547" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/60b9efeb-e6c2-4b7d-bb32-7b3b6692e338">

Дайте определение терминам «простой», «составной» (composite), «потенциальный» (candidate) и «альтернативный» (alternate) ключ. 

Простой ключ состоит из одного атрибута (поля). Составной - из двух и более. 

Потенциальный ключ - простой или составной ключ, который уникально идентифицирует каждую запись набора данных. При этом потенциальный ключ должен обладать критерием неизбыточности: при удалении любого из полей набор полей перестает уникально идентифицировать запись. 

Из множества всех потенциальных ключей набора данных выбирают первичный ключ, все остальные ключи называют альтернативными. 

Что такое «первичный ключ» (primary key)? Каковы критерии его выбора? 

Первичный ключ (primary key) в реляционной модели данных один из потенциальных ключей отношения, выбранный в качестве основного ключа (ключа по умолчанию). Если в отношении имеется единственный потенциальный ключ, он является и первичным ключом. Если потенциальных ключей несколько, один из них выбирается в качестве первичного, а другие называют «альтернативными». 

В качестве первичного обычно выбирается тот из потенциальных ключей, который наиболее удобен. Поэтому в качестве первичного ключа, как правило, выбирают тот, который имеет наименьший размер (физического хранения) и/или включает наименьшее количество атрибутов. Другой критерий выбора первичного ключа — сохранение его уникальности со временем. Поэтому в качестве первичного ключа стараются выбирать такой потенциальный ключ, который с наибольшей вероятностью никогда не утратит уникальность. 

Что такое «внешний ключ» (foreign key)? 

Внешний ключ (foreign key) — подмножество атрибутов некоторого отношения A, значения которых должны совпадать со значениями некоторого потенциального ключа некоторого отношения B. Виды отношений таблиц и моделирование процессов UML. 

<img width="1157" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/90a2335d-fcf4-4561-99f2-36b89074b1df">

Как посмотреть графическое отображение БД в Идее или DBeaver? Выбираем таблицы (или БД), кликаем правой кнопкой мышки и в выпадающем списке выбираем Diagrams.

<img width="1151" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/66151567-337a-479e-bd7a-b0a1e8b97db4">

--------------
Суррогатный ключ (Surrogate Key) в SQL - это искусственный ключ, который используется в качестве уникального идентификатора для записей в таблице. В отличие от естественных ключей, которые состоят из существующих атрибутов записей, суррогатные ключи создаются программно и не зависят от характеристик записей.

Суррогатные ключи могут быть автоинкрементными числами, глобальными уникальными идентификаторами (GUID) или другими значениями, которые генерируются при вставке записей в таблицу. Их использование может быть особенно полезным в ситуациях, когда вы не можете использовать естественные ключи, например, когда записи не имеют уникальных атрибутов или эти атрибуты могут изменяться.

Использование суррогатных ключей упрощает работу с таблицами, так как они не зависят от конкретных атрибутов записей и гарантируют уникальность идентификации. Однако, при применении суррогатных ключей может возникнуть проблема синхронизации данных, если записи в таблице объединяются с данными в другой таблице на основе естественных ключей.

[к оглавлению](#sql)

## Теория множеств 

Ограничения для операций со множествами:
+ 	кол-во полей/столбцов в строках должны совпадать
+ 	тип данных в колонках должны совпадать 

<img width="377" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/1aecc5ce-c902-4248-83c9-378ed37f645a">

<img width="1171" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/bf6a265a-5f4c-4562-b798-4d27107b1d87">

<img width="1192" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/337a25ad-7b08-43ef-b15b-41ddd8ed9dd2">

-----------------
Теория множеств описывает отношения между множествами элементов. В SQL множества используются для описания таблицы данных и их отношений. Рассмотрим основные операции теории множеств и их применение в SQL.

+ Объединение (Union)
Операция объединения объединяет два множества элементов в одно. В SQL операция объединения используется для объединения двух таблиц данных с одинаковыми столбцами. Например, если у нас есть две таблицы с именами "table1" и "table2", и мы хотим объединить их, мы можем использовать следующий запрос:
```
SELECT * FROM table1
UNION
SELECT * FROM table2;
```
+ Пересечение (Intersection)
Операция пересечения возвращает элементы, которые принадлежат обоим множествам. В SQL операция пересечения используется для поиска общих строк в двух таблицах данных. Например:
```
SELECT * FROM table1
INTERSECT
SELECT * FROM table2;
```
+ Разность (Difference)
Операция разности возвращает элементы, которые принадлежат к одному множеству, но не принадлежат к другому множеству. В SQL операция разности используется для поиска записей, которые есть в одной таблице, но нет в другой. Например:
```
SELECT * FROM table1
EXCEPT
SELECT * FROM table2;
```
+ Декартово произведение (Cartesian product)
Операция декартово произведения возвращает все возможные комбинации элементов из двух множеств. В SQL операция декартова произведения используется для получения комбинаций данных из двух таблиц. Например:
```
SELECT * FROM table1, table2;
```
Важно помнить, что использование декартовых произведений может создавать большие таблицы данных, что может привести к проблемам производительности. Поэтому, перед использованием операции декартового произведения следует тщательно оценить возможные последствия.

[к оглавлению](#sql)

## Какой вид структуры данных (какое дерево) используется при работе с базами данных? 

Как под капотом SQL организован поиск и извлечение нужных данных? 

Таблица – это файл на жёстком диске, где в бинарном виде представлены данные, отражённые в таблицах. Индексы помогают обеспечивать формирование быстрой выборки данных из БД (один индекс = один файл). 

<img width="546" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/a843df62-9794-4eaf-a97d-3ae8072b89d4">

Структура данных B-Tree используется по умолчанию для быстрого поиска данных по уровням (не путать с бинарным деревом). 

https://habr.com/ru/post/114154/  

Семейство B-Tree индексов — это наиболее часто используемый тип данных (индексов), организованных как сбалансированное дерево, упорядоченных ключей и созданы для эффективной работы с дисковой памятью. Они поддерживаются практически всеми СУБД как реляционными, так не реляционными, и практически для всех типов данных. 

<img width="1159" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/83976658-9d24-428c-a828-42146d577261">

> Справка: Деревья представляют собой структуры данных, в которых реализованы операции над динамическими множествами. Из таких операций хотелось бы выделить — поиск элемента, поиск минимального (максимального) элемента, вставка, удаление, переход к родителю, переход к ребенку.  
> Таким образом, дерево может использоваться и как обыкновенный словарь, и как очередь с приоритетами. 
> Основные операции в деревьях выполняются за время, пропорциональное его высоте. Сбалансированные деревья минимизируют свою высоту (к примеру, высота бинарного сбалансированного дерева с n узлами равна log n).

Разделяют уровни B-дерева:  
+ корневой узел (м.б. из нескольких сегментов) + ссылки на узлы промежуточного ур. 
+ промежуточные узлы (количество узлов +1 к кол-ву сегментов корневого) + ссылки  
+ узлы-листья (ссылки на следующий уровень отсутствуют) 

Поиск индекса начинается от корневого узла. Меньшее значение сегмента всегда левее. Ищем, например, 29. Сравниваем попарно значения, начиная с левого корневого сегмента. Значение сегмента меньше? Тогда идем вправо на этом же уровне. Значение больше? Тогда переходим на уровень ниже и продолжаем двигаться слева направо по сегментам узла и т.д. 

<img width="1146" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/fc3a9e43-3da3-4856-99f8-e21df2270c62">

Найдя нужный индекс (29), переходим к нужному файлу по ссылке (1 индекс = 1 файл). 
Операция поиска выполняется за время O(t logt n), где t – минимальная степень. Важно здесь, что дисковых операций мы совершаем всего лишь O(logt n)! 

Ссылка может быть представлена смещением количества байт от начала файла таблицы, чтобы найти искомую строчку (запись в таблице индекса). Индекс (29), являющийся представлением таблицы, называется кластерным индексом. 

<img width="1180" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/eee7f0ff-4a9d-4e4c-9ccf-d7f34416544e">

Почему так? Количество элементов в одном узле хранятся в одном сегменте на жёстком диске (см. рис.) и нужно обеспечить более-менее равномерное распределение памяти, а также наименьшее возможное количество обращений к памяти диска для оптимальной работы с БД. 

<img width="419" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/9b12248c-704b-49e8-9a75-9113e262adbf">

За один раз компьютер считывает в оперативную память все данные из одного сегмента на жёстком диске.

[к оглавлению](#sql)

## Как оценить сложность выполняемого запроса? 

Стоимостной оптимизатор делает расчёт на основании двух показателей: 
+ page_cost, измеряется в единицах стоимости 1.0 – сколько страниц нужно считать для выполнения одного запроса (input-output).  
+ сpu_cost – как много операций сделал процессор для выполнения запроса. 

Например, прошлись по строчке, считали информацию одной записи в таблице. Стоимость будет 0,01. 

В PostgreSQL есть специальная таблица pg_class, которая хранит статистические данные, на основании которых базируется работа стоимостного оптимизатора. 

<img width="336" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/de914daa-13c7-40e0-9687-33adc60ea966">

https://habr.com/ru/articles/465975/

----------------
https://qaa-engineer.ru/sql-dlya-opredeleniya-slozhnosti-zaprosov-i-ocherednosti-v-ih-vypolnenii/

Одним из способов определения сложности запроса является его временная оценка. Для этого используется функция EXPLAIN. Данная функция помогает оценить время выполнения запроса на основании параметров, таких как количество строк, количество строк в таблице, количество индексов и т.д.

Например, мы хотим выбрать данные из таблицы, содержащей 10 000 строк. К запросу применены условия, ограничивающие количество строк в выборке 1000. Запрос будет иметь следующий вид:

SELECT * FROM table_name WHERE column_1 = ‘value_1’ AND column_2 = ‘value_2’ LIMIT 1000;

Для оценки времени выполнения запроса мы используем функцию EXPLAIN:

EXPLAIN SELECT * FROM table_name WHERE column_1 = ‘value_1’ AND column_2 = ‘value_2’ LIMIT 1000;

В результате выполнения данного запроса мы получим список параметров, которые помогут нам оценить время выполнения запроса. Например:

+ id – порядковый номер записи.
+ select_type – тип запроса (SIMPLE).
+ table – имя таблицы.
+ partitions – количество разбиений таблицы.
+ type – тип запроса (range).
+ possible_keys – ключи, которые могут быть использованы.
+ key – использованный ключ.
+ key_len – длина использованного ключа.
+ ref – используемые индексы.
+ rows – количество строк, которые будут возвращены запросом.
+ Extra – дополнительная информация.

[к оглавлению](#sql)

## Как узнать, сколько места занимает таблица в памяти? 

В приведённом примере таблица имеет 6 полей. Для целочисленных типов данных в поле берём фиксированное значение (8 байт для BIGINT). Символьные типы определяем через запрос:

<img width="588" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/2c671d60-e7e5-49d5-8ef4-e181e917d2be">

Потом суммируем все поля одной записи и получаем результат одной строки таблицы в байтах. Умножив на кол-во записей в таблице, можно оценить весь объём данных. 

Full Scan – это очень дорогая операция (перебор всех строк и полей). Индексы позволяют уменьшить стоимость запросов.

В SQL, размер занимаемой памяти для целочисленных типов данных зависит от конкретного типа и используемой платформы/сервера базы данных. Однако, обычно в SQL применяются следующие целочисленные типы и соответствующие им приблизительные значения размера:

1. SMALLINT: занимает 2 байта;
2. INT (INTEGER): занимает 4 байта;
3. BIGINT: занимает 8 байт.

Также стоит заметить, что некоторые серверы/платформы могут иметь расширенные версии этих типов, которые могут занимать больше памяти, например, INT8, INT16 и т.д.

В любом случае, при разработке базы данных стоит обратить внимание на эти размеры и планировать использование целочисленных типов данных в зависимости от объема данных, которые будут храниться в базе.

TIMESTAMP - это пространство имен (namespace) или тип данных, используемый в различных языках программирования, для представления момента времени в виде числа, которое обычно хранится в виде 64-битного целого числа.

Так как число 64-битное, то TIMESTAMP занимает 8 байт оперативной памяти. Однако, следует учитывать, что дополнительная память может требоваться для хранения переменной, в которой хранится значение TIMESTAMP, а также для любых дополнительных операций над ней.  

----------------
Определить точный размер таблицы в памяти SQL без зависимости от используемой СУБД может быть сложной задачей, так как каждая СУБД имеет свои собственные методы хранения данных и управления памятью. Однако вы можете оценить примерный размер таблицы с помощью следующих общих подходов:

1. **Используйте функции СУБД**: Некоторые СУБД предоставляют функции для оценки размера таблицы. Например, в MySQL/MariaDB, можно использовать `SHOW TABLE STATUS`, а в PostgreSQL - `pg_size_pretty(pg_total_relation_size('название_схемы.название_таблицы'))`. Однако это будет приблизительной информацией и не всегда будет точным значением.

2. **Примените средний размер записи**: Вы можете оценить средний размер записи в таблице, учитывая типы данных столбцов и их длину, и умножить его на количество записей в таблице. Это будет только приближенной оценкой.

3. **Используйте статистику**: Некоторые СУБД собирают статистику о размере таблицы, которую вы можете использовать для оценки. Например, в SQL Server вы можете использовать команду `sp_spaceused`, чтобы получить статистику по размеру таблицы.

4. **Используйте сторонние инструменты**: Существуют сторонние инструменты и приложения, которые могут помочь вам оценить размер таблицы в памяти, такие как SQL Server Management Studio (SSMS), MySQL Workbench и другие.

5. **Мониторинг производительности**: Используйте инструменты мониторинга производительности для отслеживания использования ресурсов базы данных, такие как Prometheus, Grafana или другие инструменты, которые могут предоставить информацию о размере таблицы.

Имейте в виду, что размер таблицы может меняться со временем из-за добавления, обновления и удаления данных. Поэтому любая оценка будет приближенной и должна использоваться только для общего представления о размере таблицы в конкретный момент времени.

------------
Чтобы узнать, сколько места занимает таблица в памяти, можно использовать команду SQL EXEC sp_spaceused, которая возвращает информацию о используемом пространстве в базе данных.

Например, если необходимо узнать размер таблицы с именем "my_table," можно использовать следующий запрос:
```
EXEC sp_spaceused 'my_table';
```
Этот запрос вернет результат в виде таблицы, которая будет содержать информацию о размере таблицы в байтах, количестве зарезервированного места, количестве использованного места и количестве свободного места.

Дополнительно, можно использовать запросы, такие как SELECT DATALENGTH(*) FROM my_table чтобы узнать размер конкретных столбцов таблицы.

[к оглавлению](#sql)

## Методы сканирования таблиц: 

<img width="1225" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/3fbb2d9b-ff0e-4a7f-8cd2-7a3adee5cde0">

https://habr.com/ru/companies/postgrespro/articles/578196/

В базах данных существуют различные методы сканирования таблиц, которые используются для извлечения данных во время выполнения запросов. Вот некоторые из основных методов сканирования таблиц:

1. **Table Scan (полное сканирование таблицы)**:
   - **Описание**: Этот метод сканирования означает, что база данных просматривает каждую строку в таблице, чтобы найти соответствующие записи.
   - **Использование**: Обычно используется, когда нет индексов, которые можно было бы использовать для ускорения запроса, или когда большинство строк в таблице соответствуют условиям запроса.
   - **Эффективность**: Медленный, особенно на больших таблицах, так как требует просмотра каждой строки.

2. **Index Scan (сканирование индекса)**:
   - **Описание**: База данных использует индекс для поиска соответствующих записей в таблице. Это может быть сканирование B-дерева или другого типа индекса.
   - **Использование**: Когда есть подходящий индекс для запроса, что позволяет быстро найти нужные строки.
   - **Эффективность**: Обычно быстрее, чем полное сканирование таблицы, особенно на больших таблицах.

3. **Clustered Index Scan (сканирование кластеризованного индекса)**:
   - **Описание**: Этот тип сканирования используется, когда запрос требует данных из всех или большинства столбцов таблицы.
   - **Использование**: Когда необходимо получить все данные из таблицы и когда кластеризованный индекс сортирован по нужному полю.
   - **Эффективность**: Обычно эффективен для запросов, требующих большое количество данных из таблицы.

4. **Covering Index Scan (покрывающее сканирование индекса)**:
   - **Описание**: Этот метод используется, когда индекс содержит все данные, необходимые для удовлетворения запроса, и база данных может избежать обращения к самой таблице.
   - **Использование**: Когда индекс включает все столбцы, используемые в запросе.
   - **Эффективность**: Очень эффективен, так как избегает обращения к самой таблице.

5. **Bitmap Index Scan**:
   - **Описание**: Этот метод используется в базах данных, поддерживающих bitmap индексы. Он может быть эффективным для некоторых типов запросов, особенно для операций слияния и подсчета.
   - **Использование**: В случаях, когда bitmap индексы могут существенно улучшить производительность запроса.
   - **Эффективность**: В зависимости от типа запроса и данных, может быть очень эффективным.

Каждый из этих методов имеет свои применения и эффективность в зависимости от структуры данных, типов запросов и индексации. Оптимальный выбор метода сканирования зависит от конкретного контекста и требований к выполнению запроса.

[к оглавлению](#sql)

## Что такое индексы? Какие они бывают?

Индексы в SQL - это структуры данных, используемые для ускорения операций поиска и сортировки записей в таблицах базы данных. Индексы позволяют быстрее находить нужные записи, что делает работу с базами данных гораздо быстрее и эффективнее. 

Существует несколько видов индексов в SQL:

1. Первичный ключ (Primary Key) - это индекс, который уникально идентифицирует каждую запись в таблице. Обычно этот индекс создается на столбце, который является уникальным идентификатором для каждой записи.

2. Внешний ключ (Foreign Key) - это связь между двумя таблицами по какому-то столбцу. При этом индекс создается на столбце этой связи.

3. Уникальный индекс (Unique Index) - это индекс, позволяющий убедиться в уникальности значений в столбце таблицы. Он гарантирует, что в этом столбце каждое значение будет уникальным.

4. Кластерный индекс (Clustered Index) - это индекс, который определяет порядок физического расположения записей в таблице. Обычно создается на столбце таблицы, по которому часто происходит сортировка и поиск данных.

5. Некластерный индекс (Non-Clustered Index) - это индекс, который содержит ссылки на физические адреса строк таблицы. Он ускоряет операции поиска данных, не изменяя физического порядка строк в таблице.

Выбор индекса для таблицы должен зависеть от ее структуры, размера, которые в свою очередь определяют типы запросов, которые будут выполняться на этой таблице с наибольшей частотой.

Индекс (index) — объект базы данных, создаваемый с целью повышения производительности выборки данных.

Наборы данных могут иметь большое количество записей, которые хранятся в произвольном порядке, и их поиск по заданному критерию путем последовательного просмотра набора данных запись за записью может занимать много времени. Индекс формируется из значений одного или нескольких полей и указателей на соответствующие записи набора данных, - таким образом, достигается значительный прирост скорости выборки из этих данных.

Преимущества
+ ускорение поиска и сортировки по определенному полю или набору полей.
+ обеспечение уникальности данных.

Недостатки
+ требование дополнительного места на диске и в оперативной памяти и чем больше/длиннее ключ, тем больше размер индекса.
+ замедление операций вставки, обновления и удаления записей, поскольку при этом приходится обновлять сами индексы.

Индексы предпочтительней для:
+ Поля-счетчика, чтобы в том числе избежать и повторения значений в этом поле;
+ Поля, по которому проводится сортировка данных;
+ Полей, по которым часто проводится соединение наборов данных. Поскольку в этом случае данные располагаются в порядке возрастания индекса и соединение происходит значительно быстрее;
+ Поля, которое объявлено первичным ключом (primary key);
+ Поля, в котором данные выбираются из некоторого диапазона. В этом случае как только будет найдена первая запись с нужным значением, все последующие значения будут расположены рядом.

Использование индексов нецелесообразно для:
+ Полей, которые редко используются в запросах;
+ Полей, которые содержат всего два или три значения, например: мужской, женский пол или значения «да», «нет».

Какие типы индексов существуют?
+ По порядку сортировки
  + упорядоченные — индексы, в которых элементы упорядочены;
    + возрастающие;
    + убывающие;
  + неупорядоченные — индексы, в которых элементы неупорядочены.
+ По источнику данных
  + индексы по представлению (view);
  + индексы по выражениям.
+ По воздействию на источник данных
  + кластерный индекс - при определении в наборе данных физическое расположение данных перестраивается в соответствии со структурой индекса. Логическая структура набора данных в этом случае представляет собой скорее словарь, чем индекс. Данные в словаре физически упорядочены, например по алфавиту. Кластерные индексы могут дать существенное увеличение производительности поиска данных даже по сравнению с обычными индексами. Увеличение производительности особенно заметно при работе с последовательными данными.
  + некластерный индекс — наиболее типичные представители семейства индексов. В отличие от кластерных, они не перестраивают физическую структуру набора данных, а лишь организуют ссылки на соответствующие записи. Для идентификации нужной записи в наборе данных некластерный индекс организует специальные указатели, включающие в себя: информацию об идентификационном номере файла, в котором хранится запись; идентификационный номер страницы соответствующих данных; номер искомой записи на соответствующей странице; содержимое столбца.
+ По структуре
  + B*-деревья;
  + B+-деревья;
  + B-деревья;
  + Хэши.
+ По количественному составу
  + простой индекс (индекс с одним ключом) — строится по одному полю;
  + составной (многоключевой, композитный) индекс — строится по нескольким полям при этом важен порядок их следования;
  + индекс с включенными столбцами — некластеризованный индекс, дополнительно содержащий кроме ключевых столбцов еще и неключевые;
  + главный индекс (индекс по первичному ключу) — это тот индексный ключ, под управлением которого в данный момент находится набор данных. Набор данных не может быть отсортирован по нескольким индексным ключам одновременно. Хотя, если один и тот же набор данных открыт одновременно в нескольких рабочих областях, то у каждой копии набора данных может быть назначен свой главный индекс.
+ По характеристике содержимого
  + уникальный индекс состоит из множества уникальных значений поля;
  + плотный индекс (NoSQL) — индекс, при котором, каждом документе в индексируемой коллекции соответствует запись в индексе, даже если в документе нет индексируемого поля.
  + разреженный индекс (NoSQL) — тот, в котором представлены только те документы, для которых индексируемый ключ имеет какое-то определённое значение (существует).
  + пространственный индекс — оптимизирован для описания географического местоположения. Представляет из себя многоключевой индекс состоящий из широты и долготы.
  + составной пространственный индекс — индекс, включающий в себя кроме широты и долготы ещё какие-либо мета-данные (например теги). Но географические координаты должны стоять на первом месте.
  + полнотекстовый (инвертированный) индекс — словарь, в котором перечислены все слова и указано, в каких местах они встречаются. При наличии такого индекса достаточно осуществить поиск нужных слов в нём и тогда сразу же будет получен список документов, в которых они встречаются.
  + хэш-индекс предполагает хранение не самих значений, а их хэшей, благодаря чему уменьшается размер (а, соответственно, и увеличивается скорость их обработки) индексов из больших полей. Таким образом, при запросах с использованием хэш-индексов, сравниваться будут не искомое со значения поля, а хэш от искомого значения с хэшами полей. Из-за нелинейнойсти хэш-функций данный индекс нельзя сортировать по значению, что приводит к невозможности использования в сравнениях больше/меньше и «is null». Кроме того, так как хэши не уникальны, то для совпадающих хэшей применяются методы разрешения коллизий.
  + битовый индекс (bitmap index) — метод битовых индексов заключается в создании отдельных битовых карт (последовательностей 0 и 1) для каждого возможного значения столбца, где каждому биту соответствует запись с индексируемым значением, а его значение равное 1 означает, что запись, соответствующая позиции бита содержит индексируемое значение для данного столбца или свойства.
  + обратный индекс (reverse index) — B-tree индекс, но с реверсированным ключом, используемый в основном для монотонно возрастающих значений (например, автоинкрементный идентификатор) в OLTP системах с целью снятия конкуренции за последний листовой блок индекса, т.к. благодаря переворачиванию значения две соседние записи индекса попадают в разные блоки индекса. Он не может использоваться для диапазонного поиска.
  + функциональный индекс, индекс по вычисляемому полю (function-based index) — индекс, ключи которого хранят результат пользовательских функций. Функциональные индексы часто строятся для полей, значения которых проходят предварительную обработку перед сравнением в команде SQL. Например, при сравнении строковых данных без учета регистра символов часто используется функция UPPER. Кроме того, функциональный индекс может помочь реализовать любой другой отсутствующий тип индексов данной СУБД.
  + первичный индекс — уникальный индекс по полю первичного ключа.
  + вторичный индекс — индекс по другим полям (кроме поля первичного ключа).
  + XML-индекс — вырезанное материализованное представление больших двоичных XML-объектов (BLOB) в столбце с типом данных xml.
+ По механизму обновления
  + полностью перестраиваемый — при добавлении элемента заново перестраивается весь индекс.
  + пополняемый (балансируемый) — при добавлении элементов индекс перестраивается частично (например одна из ветви) и периодически балансируется.
+ По покрытию индексируемого содержимого
  + полностью покрывающий (полный) индекс — покрывает всё содержимое индексируемого объекта.
  + частичный индекс (partial index) — это индекс, построенный на части набора данных, удовлетворяющей определенному условию самого индекса. Данный индекс создан для уменьшения размера индекса.
  + инкрементный (delta) индекс — индексируется малая часть данных(дельта), как правило, по истечении определенного времени. Используется при интенсивной записи. Например, полный индекс перестраивается раз в сутки, а дельта-индекс строится каждый час. По сути это частичный индекс по временной метке.
  + индекс реального времени (real-time index) — особый вид инкрементного индекса, характеризующийся высокой скоростью построения. Предназначен для часто меняющихся данных.
+ Индексы в кластерных системах
  + глобальный индекс — индекс по всему содержимому всех сегментов БД (shard).
  + сегментный индекс — глобальный индекс по полю-сегментируемому ключу (shard key). Используется для быстрого определения сегмента, на котором хранятся данные в процессе маршрутизации запроса в кластере БД.
  + локальный индекс — индекс по содержимому только одного сегмента БД.

В чем отличие между кластерными и некластерными индексами?

Некластерные индексы - данные физически расположены в произвольном порядке, но логически упорядочены согласно индексу. Такой тип индексов подходит для часто изменяемого набора данных.
При кластерном индексировании данные физически упорядочены, что серьезно повышает скорость выборок данных (но только в случае последовательного доступа к данным). Для  одного набора данных может быть создан только один кластерный индекс.

Имеет ли смысл индексировать данные, имеющие небольшое количество возможных значений?

Примерное правило, которым можно руководствоваться при создании индекса - если объем информации (в байтах) НЕ удовлетворяющей условию выборки меньше, чем размер индекса (в байтах) по данному условию выборки, то в общем случае оптимизация приведет к замедлению выборки.

Когда полное сканирование набора данных выгоднее доступа по индексу?

Полное сканирование производится многоблочным чтением. Сканирование по индексу - одноблочным. Также, при доступе по индексу сначала идет сканирование самого индекса, а затем чтение блоков из набора данных. Число блоков, которые надо при этом прочитать из набора зависит от фактора кластеризации. Если суммарная стоимость всех необходимых одноблочных чтений больше стоимости полного сканирования многоблочным чтением, то полное сканирование выгоднее и оно выбирается оптимизатором.
Таким образом, полное сканирование выбирается при слабой селективности предикатов зароса и/или слабой кластеризации данных, либо в случае очень маленьких наборов данных.

Как создать индекс?

Индекс можно создать либо с помощью выражения CREATE INDEX:
```
CREATE INDEX index_name ON table_name (column_name)
```
либо указав ограничение целостности в виде уникального UNIQUE или первичного PRIMARY ключа в операторе создания таблицы CREATE TABLE.

------------
Индексы – это специальные структуры в базах данных, которые позволяют ускорить поиск и сортировку по определённому полю или набору полей в таблице, а также 
обеспечивают уникальность данных.      

Подробно и доступно тут → https://youtu.be/lAWQNcAEiKw?t=932 

<img width="992" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/259c3bc0-762e-4726-8afa-c01b91d06952">

Когда мы создаём первичный ключ (чаще всего это уникальный идентификатор id), то автоматически формируется индекс. 

Совокупность этих данных/индексов – это и есть структура B-Tree (по умолчанию), которая создаёт отдельный файл, где находятся все ключи.

<img width="481" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/14cc7142-5919-485e-a23c-aba34fa342a6">

<img width="871" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/c39e7c3f-f5ab-4a30-a9b9-ea4ab4003d7c">

Индексы бывают кластерные и не кластерные (еще называют кластеризованные и нет). 
 
Если по ссылке с индекса лежит отдельная таблица (отдельный файл), то такой индекс называется кластерным. 
 
Кластерный индекс хранит реальные строки/записи данных в листьях индекса. Важной характеристикой кластерного индекса является то, что все значения отсортированы в определенном порядке либо возрастания, либо убывания. Таким образом, таблица или представление может иметь только один кластерный индекс. В дополнение следует отметить, что данные в таблице хранятся в отсортированном виде только в случае, если у этой таблицы создан кластерный индекс. Таблица, не имеющая кластерного индекса, называется кучей. 
 
Не кластерный индекс, созданный для такой таблицы, содержит только указатели ссылки) на записи таблицы (а не саму таблицу). 

<img width="931" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/48b8f800-8035-4724-ac34-6ccb4d7190da">

[к оглавлению](#sql)

## Как и зачем создавать индекс? 
 
Для того, чтобы добавить индекс, необходимо использовать команду CREATE INDEX, что позволит указать имя индекса и определить таблицу и колонку или индекс колонки и определить, используется ли индекс по возрастанию или по убыванию.  
 
Создание некластеризованного индекса в таблице или представлении: 
 
<img width="481" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/3bc8e02c-5316-4137-86a7-222b8de02a07">

Создание кластеризованного индекса в таблице и использование имени, состоящего из трех элементов, для таблицы: 
 
<img width="682" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/e6c7bce8-a359-415c-8237-c8ec3cdf4704">
 
Создание некластеризованного индекса с ограничением уникальности и указание порядка сортировки: 
 
<img width="1072" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/b24ea0e0-0584-4d3b-96aa-b51aac23bf46">
 
Индексы – это решение многих проблем с производительностью, но слишком много индексов на таблицах будет влиять на производительность операторов INSERT, UPDATE и DELETE. Это связано с обновлением индексов, когда вы добавляете (INSERT), изменяете (UPDATE) или удаляете (DELETE) данные. 
 
Зачем создавать индекс? 
 
Оптимизация! Кратное улучшение времени поиска за счёт применения индекса: 

<img width="1023" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/ad04e8f6-1eb0-482b-b492-fa9ee2511f64">

[к оглавлению](#sql)

## Что такое селективность? 
 
Селективность – это отношение количества уникальных элементов к кол-ву записей, т.е. строчек в таблице. В примере ниже селективность плохая, меньше 20%. Оптимально – 1. 
 
Селективность влияет на скорость поиска, поэтому необходимо определять порядок индексов.  
 
Важно также понимать, что DML функции (обновление, изменение, удаление данных) обновляет также все индексы, поэтому быть внимательным при создании индексов. 

<img width="1085" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/ecaac851-9175-4198-88ee-bf700fa21515">

Селективность в SQL - это мера того, насколько уникальными являются значения столбца или набора столбцов в таблице. Более высокая селективность означает, что значения столбца или набора столбцов будут более уникальными, что является полезным при выполнении запросов на выборку данных.

Базы данных используют индексы для ускорения выполнения запросов на выборку данных. Индекс является отсортированным списком значений столбца или набора столбцов и связанных с ними ссылок на строки таблицы. Когда вы выполняете запрос на выборку данных, он использует индекс для поиска соответствующих строк в таблице. Чем более уникальными являются значения столбца или набора столбцов, тем эффективнее индекс может быть использован для выполнения запроса.

Например, предположим, что у вас есть таблица с полями "ID", "Имя" и "Адрес". Поле "ID" - это уникальный идентификатор для каждой строки, что делает его очень селективным. Вы можете создать индекс на этом поле, и запросы на выборку данных, которые фильтруют строки по "ID", будут выполнены очень быстро. С другой стороны, поле "Имя" может иметь множество повторяющихся значений, что делает его менее селективным. Индекс на этом поле будет менее эффективным и использование его может замедлить выполнение запросов.

Чтобы определить селективность столбца или набора столбцов, можно использовать формулу "уникальные значения / общее количество значений". Если это значение близко к 1, то столбец или набор столбцов считается очень селективным, а если оно близко к 0, то столбец или набор столбцов считается менее селективным.

Учитывая селективность столбцов при проектировании таблицы и создании индексов, можно улучшить производительность запросов на выборку данных.

[к оглавлению](#sql)

## Анализ выполнения запросов (если есть проблемы с производительностью)

<img width="902" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/0c63708d-61d7-477d-9fd9-111c0b295892">

Запрос explain analyze показывает план выполнения запроса: что ожидали и что получили. Можно это использовать, чтобы проанализировать, каким образом выполняется запрос + получить статистические данные.

<img width="892" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/b6f33266-b2d6-4b6f-8b12-a1528ba3b54d">

Например, проанализируем, как происходит связывание Join с помощью планового выполнения запросов? 

ТРИ варианта связывания таблиц (и как это устроено): nested loop, hash join, merge join. 
+ Nested Loop работает на маленькой выборке. Считывает одну таблицу, чтобы обратиться по индексу второй.  
+ Hash Join работает на больших выборках. Считывает обе таблицы полностью, а потом на основе второй таблицы создаёт хэш-таблицу (операция считывания которой происходит за константное время О(1) – очень быстро.  
+ Merge Join работает на основании отсортированных ключей. Сканирует обе таблицы, сортирует, а затем быстро сравнивает элементы попарно. 

Способ связывания выбирает планировщик на основании статистических и кэшированных данных (после предыдущих запросов). 

<img width="852" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/7c4e4325-98d2-4711-bac5-0939aa8882a6">

Здесь Nested Loop занимался связыванием двух таблиц (снизу-вверх: в первой поиск по индексу p_key, во второй использовался full scan, время выполнения соответствующее). 

Nested Loop используется, когда записей не очень много, а тут есть ограничение limit.  

Как устроено? Идёт обычным циклом по просканированной таблице test_2, а дальше Index Condition связывает индекс из таблицы test_2 с индексом первой таблицы (id=t.test_1_id); loops=100 – это значит, что 100 раз выполняли это действие по 1 строке за указанные время и стоимость для одной записи: <img width="355" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/294f5ca6-3592-4c52-8141-2334978d5575">

<img width="863" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/68b14934-9643-4c04-84e4-b19b4929972e">

Тут используется Hash Join. Он также состоит из двух частей. Сканирует первую таблицу, а на основании просканированной второй таблицы создаёт хэш-таблицу. 

Сначала происходит full scan одной таблицы, но в случае второй мы уже используем не индекс. Элемент Hash полностью просканировал таблицу и на основании полного считывания информации создал структуру данных Hash Table (хэш таблицу). Поиск по ней происходит за константное время О(1). Можно увидеть, сколько бакетов создано. 

Batches: 2, а значение >1 означает, что оперативной памяти не хватило и часть инфо была сохранена на диск. То, что попало в Memory заняло около 3 мб. 

Hash Condition (синяя заливка строки) показывает, что данные довольно быстро получены. Условия связывания указаны в скобках. 

<img width="1180" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/8f0ce152-7a4d-4bf9-ae03-2e0cb62eb960">

Также быстрый вариант Merge Join. Состоит из трёх основных частей, использует отсортированную последовательность. 

Для сканирования таблицы test_1 использовали индекс p_key. Для таблицы test_2 сначала использовали full scan, далее отсортировали по ключу test_1_id 

Указан метод сортировки и количество выделенной памяти около 3 мб. Далее Merge Join обходит обычным циклом обе отсортированных последовательности (как если бы циклом for мы обходили два отсортированных массива и попарно сравнивали значения). 

[к оглавлению](#sql)

## Чем TRUNCATE отличается от DELETE? 
 
DELETE - оператор DML, удаляет записи из таблицы, которые удовлетворяют критерию WHERE при этом задействуются триггеры, ограничения и т.д. РОЛЛБЕК 

TRUNCATE - DDL оператор, удаляет таблицу и создает ее заново. Причем если на эту таблицу есть ссылки FOREIGN KEY или таблица используется в репликации, то пересоздать такую таблицу не получится). 

Delete в целом не предназначена для полной очистки таблицы - генерит редо, поддерживает индексы, то есть работает медленно.

Truncate наоборот предназначен именно для быстрой очистки ВСЕЙ таблицы или партиции - освобождает занятые экстенты.

Операция TRUNCATE не записывает в журнал событий удаление отдельных строк. Вследствие чего не может активировать триггеры.

После операции TRUNCATE для некоторых СУБД (например, Oracle) следует неявная операция COMMIT. Поэтому удаленные в таблице записи нельзя восстановитьоперацией ROLLBACK. Но существуют и СУБД, в которых операция TRUNCATE можетучаствовать в транзакциях, например, PostgreSQL и Microsoft SQL Server.

Операция DELETE блокирует каждую строку, а TRUNCATE — всю таблицу.

Операция TRUNCATE не возвращает какого-то осмысленного значения (обычно возвращает 0) в отличие от DELETE, которая возвращает число удаленных строк.

Операция TRUNCATE в некоторых СУБД (например, MySQL или Microsoft SQL Server), сбрасывает значение счетчиков (для полей с AUTOINCREMENT / IDENTITY).

В PostgreSQL для сброса счётчиков необходимо указывать модификатор RESTART IDENTITY.

Операция TRUNCATE в некоторых СУБД (например, MySQL, PostgreSQL или Microsoft SQL Server) запрещена для таблиц, содержащих внешние ключи других таблиц. В PostgreSQL существует, однако, модификатор CASCADE, который разрешает TRUNCATE в этой ситуации – данные из зависимых таблиц удаляются в той же транзакции.

В SQLite операция как таковая отсутствует, но есть оптимизация операции DELETE, которая «значительно ускоряет её работу, если отсутствует аргумент WHERE».

-----------------
TRUNCATE и DELETE - это две разные операции, хотя и выполняют схожую функцию - удаление данных из таблицы в базе данных.

Основные отличия между ними:

DELETE - команда DML (Data Manipulation Language), тогда как TRUNCATE - команда DDL (Data Definition Language).

DELETE позволяет удалить только часть данных или все данные из таблицы, при этом удаляемые строки сохраняются в логе транзакций и могут быть восстановлены, если это необходимо.

TRUNCATE же удаляет все строки из таблицы за один раз и делает это гораздо быстрее, так как не сохраняет данные в логе транзакций, что может ускорить работу при большом объеме данных.

В отличие от DELETE, TRUNCATE не использует WHERE условие и не может удалить отдельные строки из таблицы. Он удаляет все строки из таблицы, при этом сбрасывает Identity (если есть) и возвращает табличную переменную в пустое состояние.

TRUNCATE не вызывает триггеры и не имеет возможности вернуть удаленные данные, в отличие от DELETE, который может вызывать триггеры и может быть отменен с использованием отката транзакции.

Общее свойство: обе операции используются для удаления данных из таблицы, но использование каждой из них зависит от того, что нам нужно сделать с данными, которые мы хотим удалить. Если нужно удалить все строки из таблицы и сбросить identity значения, TRUNCATE - более быстрый и предпочтительный выбор. Если необходимо удалить только некоторые строки или если нужно сохранять данные в журнале транзакций для возможного восстановления, тогда следует использовать DELETE.

[к оглавлению](#sql)

## Что такое хранимые процедуры? Для чего они нужны? 

Хранимые процедуры - это предопределенный набор инструкций, которые выполняются на сервере базы данных и вызываются из клиентского приложения. Они могут принимать параметры и возвращать результаты, что позволяет использовать их для выполнения различных задач, связанных с базой данных.

Хранимые процедуры используются для упрощения и оптимизации доступа к данным в базе данных. Они могут быть использованы для выполнения сложных операций на стороне сервера, необходимых для обработки запросов к базе данных. Также они могут использоваться для обеспечения целостности данных, ограничения доступа к определенным данным и реализации бизнес-логики на стороне сервера.

Преимущества хранимых процедур включают повышение производительности, снижение издержек на сетевое взаимодействие между клиентом и сервером, увеличение безопасности и защиты от SQL-инъекций.

Таким образом, хранимые процедуры позволяют оптимизировать работу базы данных, облегчить разработку клиентского приложения и повысить безопасность взаимодействия с базой данных.

--------- 
Хранимые процедуры позволяют повысить производительность, расширяют возможности программирования и поддерживают функции безопасности данных. В большинстве СУБД при первом запуске хранимой процедуры она компилируется (выполняется синтаксический анализ и генерируется план доступа к данным) и в дальнейшем её обработка осуществляется быстрее. 

Хранимая процедура — объект базы данных, представляющий собой набор SQLинструкций, который хранится на сервере. Хранимые процедуры очень похожи на обыкновенные процедуры языков высокого уровня, у них могут быть входные и выходные параметры и локальные переменные, в них могут производиться числовые вычисления и операции над символьными данными, результаты которых могут присваиваться переменным и параметрам. В хранимых процедурах могут выполняться стандартные операции с базами данных (как DDL, так и DML). Кроме того, в хранимых процедурах возможны циклы и ветвления, то есть в них могут использоваться инструкции управления процессом исполнения. 

Хранимые процедуры позволяют повысить производительность, расширяют возможности программирования и поддерживают функции безопасности данных. В большинстве СУБД при первом запуске хранимой процедуры она компилируется (выполняется синтаксический анализ и генерируется план доступа к данным) и в дальнейшем её обработка осуществляется быстрее. 

-----------
Хранимая процедура в SQL — это предопределенный блок кода, который хранится на сервере базы данных и может вызываться из другого кода, включая другие SQL-запросы, приложения или хранимые процедуры.

Пример хранимой процедуры в MySQL:
```
CREATE PROCEDURE `update_employee_salary`(IN emp_id INT, IN salary DECIMAL(10,2))
BEGIN
UPDATE employee SET salary = salary WHERE id = emp_id;
END
```
Здесь создается хранимая процедура с именем update_employee_salary, которая принимает два параметра: emp_id и salary. В теле процедуры используется SQL-запрос UPDATE, который обновляет зарплату работника в таблице employee, идентифицируемого по полю id равному emp_id.

Хранимые процедуры могут использоваться для решения различных задач, таких как:

+ Улучшения производительности: хранимая процедура может выполнять сложные операции непосредственно на сервере базы данных, что может ускорить обработку данных и сократить количество передаваемой информации между сервером и клиентом.
+ Повторного использования кода: хранимая процедура может быть вызвана из разных частей приложения или базы данных, что снижает необходимость дублировать код.
+ Облегчения обслуживания кода: хранимая процедура может быть изменена только один раз, и изменения будут отражены во всех местах, где она используется.

----------
Хранимая процедура (stored procedure) в SQL - это предварительно скомпилированная и сохраненная на сервере базы данных последовательность команд SQL. В отличие от обычных запросов к базе данных, которые передаются клиентскому приложению и выполняются на стороне клиента, хранимые процедуры выполняются на стороне сервера базы данных и могут вызываться из различных клиентских приложений.

Некоторые недостатки хранимых процедур включают:

+ Сложность создания и обновления: Хранимые процедуры требуют специальных знаний для их создания и поддержки, и может потребоваться дополнительное время на тестирование и развертывание.
+ Ограниченная переносимость: Хранимые процедуры могут содержать код, который зависит от конкретной базы данных или сервера, что делает их менее переносимыми между различными системами управления базами данных.
+ Увеличение нагрузки на сервер: Хранимые процедуры могут потребовать большого объема ресурсов на сервере базы данных, что может привести к снижению производительности и увеличению нагрузки на систему.
+ Ограниченная гибкость: Хранимые процедуры не всегда могут быть легко изменены или адаптированы для новых требований, так как они требуют перекомпиляции и обновления на сервере базы данных.
+ Безопасность: Хранимые процедуры могут представлять угрозу безопасности, если не реализованы должным образом. Например, хранимые процедуры могут использоваться для выполнения SQL-инъекций или других видов атак на базу данных.

[к оглавлению](#sql)

## Что такое представления (VIEW)? Для чего они нужны?

Представление, View – виртуальная таблица, представляющая данные одной или более таблиц альтернативным образом. Зачем? Чтобы делать выборки (операция SELECT). 

В действительности представление – всего лишь результат выполнения оператора SELECT, который хранится в структуре памяти, напоминающей SQL таблицу. Они работают в запросах и операторах DML точно также как и основные таблицы, но не содержат никаких собственных данных.  

Представления значительно расширяют возможности управления данными. Это способ дать публичный доступ к некоторой (но не всей) информации в таблице. 

Как создать VIEW? К команде SQL добавить одну строку и появится папка views, где будут храниться типичные запросы. 

<img width="1185" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/5d985350-8277-4d01-a9d1-2a6c995e49a2">

Что такое Materialized view и чем отличается от просто View?

Материализованное представление — физический объект базы данных, содержащий результат выполнения запроса. Только для чтения!  

Материализованные представления позволяют многократно ускорить выполнение запросов, обращающихся к большому количеству записей, позволяя за секунды выполнять запросы к терабайтам данных. 

<img width="1097" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/9a654884-0dcd-4dd2-bc89-b44f86cacb7a">

Полезны, если нам нужно запретить пользователю доступ к некоторым атрибутам таблицы и разрешить доступ к другим атрибутам.

Например, сотрудник может искать имя, адрес, должность, возраст и другие факторы в таблице сотрудников, но он не должен иметь права просматривать или получать доступ к зарплате других сотрудников.

<img width="535" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/811d9310-6193-42b8-b16b-edb263255058">

<img width="1194" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/2d4d75c2-5afa-420f-a80e-07cd6ac750b0">

<img width="1190" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/b64ac9c4-3fd5-4221-8a21-5ced6eea96b3">

--------------
Представление (VIEW) в SQL - это виртуальная таблица, результат запроса которой сохраняется в базе данных и может быть использован при выполнении других запросов. Представление является результатом выполнения запроса SELECT, но не хранит данные физически, поэтому каждый раз, когда к нему обращаются, результат запроса пересчитывается.

Представления позволяют абстрагироваться от сложности исходных данных и скрыть детали реализации запроса. Это упрощает составление запросов и позволяет сделать базу данных более понятной и удобной для использования.

Например, представление может использоваться для комбинирования данных из нескольких таблиц в одной виртуальной таблице, для предоставления доступа к части данных таблицы и для ограничения доступа к конфиденциальным данным. Также представления могут использоваться, чтобы изменить формат хранения данных в базе данных, чтобы они соответствовали требованиям конечного пользователя.

[к оглавлению](#sql)

## Что такое временные таблицы? Для чего они нужны?

Временная таблица – это объект базы данных, который хранится и управляется системой базы данных на временной основе. Они могут быть локальными или глобальными.  

Используется для сохранения результатов вызова хранимой процедуры, уменьшение числа строк при соединениях, агрегирование данных из различных источников или как замена курсоров и параметризованных представлений. 

> Курсор (cursor) в SQL - это механизм, который позволяет программисту обработать результирующий набор строк в таблице по одной строке за раз. 
>
> Курсор используется для считывания строк из таблицы и выполнения операций с этими строками, например, обновления, удаления или вставки. Курсор может быть использован в хранимых процедурах и триггерах в SQL для обработки строк результатов запроса, особенно если эти строки требуется обработать по отдельности.
>
> Работа с курсором включает в себя открытие курсора, чтение данных строк по одной итерации за раз и закрытие курсора после окончания обработки строк. С помощью курсора программист может обеспечить более гибкую обработку данных, чем с помощью обычного запроса, и выполнить дополнительные проверки и манипуляции с данными при необходимости.

Срок жизни временной таблицы – сеанс с БД

----------
Временные таблицы (temporary tables) в SQL - это таблицы, которые создаются для использования во время выполнения запроса и автоматически удаляются после завершения сессии или сеанса работы. Они могут быть созданы в памяти или в дисковом пространстве, в зависимости от того, как настроен сервер.

Они используются для различных задач, в том числе:

Хранение временных данных для последующего использования в запросах и процедурах, например, когда необходимо выполнить несколько этапов запроса с использованием записей из предыдущего этапа.

Для оптимизации производительности запросов. Временные таблицы позволяют уменьшить объем занимаемой памяти и ускорить выполнение запросов, особенно когда речь идет о объемных таблицах.

Для разделения данных между пользователем и приложением. Временные таблицы могут быть использованы для хранения данных, которые необходимы только во время выполнения сеанса пользователя. Это позволяет разделить данные между пользователями и уменьшить вероятность конфликта между ними.

Кроме того, временные таблицы могут использоваться для выполнения запросов, которые нельзя выполнить с помощью обычных таблиц. Например, они могут быть использованы для выполнения запроса на выборку данных из нескольких таблиц или для использования временных данных, созданных в процессе выполнения других запросов.

-----------

Временные таблицы (temporary tables) в SQL - это таблицы, которые создаются во время выполнения запроса и использования в нем для временного хранения результатов вычислений и промежуточных данных в пределах сессии или транзакции. Они существуют только во время выполнения запроса и автоматически удаляются после того, как запрос выполнен или соединение к базе данных закрыто.

Временные таблицы могут быть полезны в таких случаях:

- когда нужно выполнить более чем один запрос к базе данных и использовать промежуточные результаты предыдущего запроса для выполнения следующего.
- когда необходимо создать временную таблицу для выполнения сложных потоковых запросов.
- когда нужно сохранить промежуточный результат запроса для использования в другом запросе.

Временные таблицы могут быть созданы в SQL при помощи ключевого слова `CREATE TEMPORARY TABLE`, за которым следует определение таблицы с такими же элементами, как и при создании обычной таблицы: столбцы, индексы и определение ограничений. Как правило, временные таблицы создаются только на время выполнения запроса и не сохраняются в базе данных. 

Пример создания временной таблицы в MySQL:

```
CREATE TEMPORARY TABLE temp_table (
id INT PRIMARY KEY,
name VARCHAR(20),
age INT
);
```

После создания временной таблицы, ее можно использовать для хранения промежуточных результатов запроса, так же как и для выполнения типичных операций SQL, таких как SELECT, INSERT, UPDATE и DELETE. Например, можно выполнить запрос на добавление данных в временную таблицу:

```
INSERT INTO temp_table VALUES (1, 'John', 25), (2, 'Kate', 30), (3, 'Alex', 35);
```

И затем использовать эти данные в другом запросе:

```
SELECT * FROM temp_table WHERE age > 28;
```

После выполнения запроса, временная таблица будет автоматически удалена.

Временная таблица в SQL удаляется автоматически при завершении сессии пользователя, создавшего эту таблицу. Это означает, что когда пользователь закрывает своё соединение с базой данных, временная таблица пропадает.

Срок жизни временной таблицы можно установить при её создании. Некоторые базы данных позволяют устанавливать время автоматического удаления временной таблицы, используя параметр TEMPORARY. Для MySQL, например, можно использовать следующий синтаксис:

```
CREATE TEMPORARY TABLE temp_table_name (column1 datatype1, column2 datatype2, ...) ON COMMIT DELETE ROWS;
```

В этом случае, таблица будет удалена автоматически после выполнения команды COMMIT или после завершения сессии пользователя, в зависимости от настроек базы данных.

Если параметр ON COMMIT DELETE ROWS не указан, то временная таблица будет удалена только при завершении сессии пользователя. 

В любом случае, если вы хотите убедиться, что временная таблица будет удалена вовремя, не забывайте закрывать своё соединение с базой данных.

------------------
Временная таблица (temporary table) и представление (VIEW) - это два разных концепта, хотя оба могут использоваться для сохранения и представления информации в базах данных.

Временная таблица создается временно в памяти или на диске в процессе выполнения запроса и используется для хранения результатов промежуточных вычислений или промежуточных данных, которые могут быть использованы в более поздних запросах в рамках одной сессии или сеанса работы. Временная таблица действует как обычная таблица, но после завершения сеанса ее данные автоматически удаляются.

Представление (VIEW) является виртуальной таблицей, которая определяется запросом SELECT и представляет результат выполнения этого запроса в виде таблицы. Представление не хранит данные физически, а предоставляет только виртуальный доступ к данным, хранящимся в других таблицах. Представления можно использовать в качестве обычных таблиц в запросах SELECT, INSERT, UPDATE и DELETE.

Таким образом, основное отличие между временной таблицей и представлением заключается в том, что временная таблица является физическим объектом, который хранит данные в памяти или на диске, в то время как представление является виртуальным объектом, который предоставляет доступ к данным в других таблицах. Представление может быть использовано в запросах как обычная таблица, а временная таблица может использоваться для сохранения результатов вычислений и промежуточных данных.

[к оглавлению](#sql)

## Что такое транзакции? Расскажите про принципы ACID.

Транзакция - это единица работы с базой данных, которая может включать в себя одну или несколько операций чтения и записи данных. Примером транзакции может служить операция перевода денег между счетами в банке: изменение балансов на двух счетах должно быть выполнено атомарно, т.е. либо все изменения успешно выполнены, либо ни одна операция не выполнена.

Принципы ACID - это основные свойства, которые гарантируют целостность и надежность транзакционных операций в базах данных. Каждая буква в аббревиатуре ACID означает определенный принцип:

1. Атомарность (Atomicity) - гарантия того, что транзакция является неделимой и либо будет выполнена успешно целиком, либо вообще не будет выполнена. Если в процессе выполнения транзакции произойдет ошибка, то все изменения, которые были внесены до этого момента, будут отменены.

2. Согласованность (Consistency) - гарантия, что выполнение транзакции не нарушит целостность данных в базе. Транзакция не может нарушить ограничения целостности базы данных, такие как связи между таблицами и ограничения на допустимые значения полей.Если совсем простыми словами, то Consistency (ACID) обеспечивает гарантию, что в базе не будут нарушены ограничения (constraints). Например, не сможете затолкать в одну таблицу две записи с одним значением первичного ключа.
3. Изолированность (Isolation) - гарантия того, что транзакция выполняется независимо от других транзакций, работающих одновременно. Транзакции выполняются в изолированных средах, чтобы многопоточность и параллелизм не могли повлиять на результат выполнения.

4. Устойчивость (Durability) - гарантия того, что результаты выполнения транзакции будут сохранены навсегда, даже в случае аварийного завершения работы системы. Результаты должны сохраняться в постоянном хранилище, таком как жесткий диск, и не могут быть потеряны из-за сбоев в системе.

--------------
Транзакция – это единица работы в рамках соединения с базой данных.  
 
Имеет ДВА состояния: 
+ Выполняется полностью – commit 
+ Откатывается полностью – rollback  
 
ACID – это набор свойств, которыми должна обладать каждая транзакция БД. 

<img width="1121" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/c6ad5228-b88c-4415-88f4-8c46ce8779b2">

<img width="1170" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/b0dfac98-f627-4cef-8e43-f68627c8f7d0">

Lost Update – при одновременном изменении одного блока данных разными транзакциями теряются все изменения, кроме последнего; 

<img width="1181" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/1a6abf4b-e4fd-4936-9700-e3e29e717789">

<img width="1169" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/0cdae080-3b84-472e-9c89-8f85a8460f40">

<img width="1185" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/331346a5-70aa-4f69-ba07-52d58e4e9fbc">

<img width="922" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/ecd5c4c9-e41b-4a98-b7c3-c76e0beb8e6b">

----------
Транзакция - это воздействие на базу данных, переводящее её из одного целостного состояния в другое и выражаемое в изменении данных, хранящихся в базе данных.

Это N (N≥1) запросов к БД, которые выполнятся успешно все вместе или не выполнятся вовсе.

Назовите основные свойства транзакции.

+ Атомарность (atomicity) гарантирует, что никакая транзакция не будет зафиксирована в системе частично. Будут либо выполнены все её подоперации, либо не выполнено ни одной.
+ Согласованность (consistency). Транзакция, достигающая своего нормального завершения (EOT — end of transaction, завершение транзакции) и, тем самым, фиксирующая свои результаты, сохраняет согласованность базы данных. Другими словами, каждая успешная транзакция по определению фиксирует только допустимые результаты.
+ Изолированность (isolation). Во время выполнения транзакции  параллельные транзакции не должны оказывать влияние на ее результат.
+ Долговечность (durability). Независимо от проблем на нижних уровнях (к примеру, обесточивание системы или сбои в оборудовании) изменения, сделанные успешно завершённой транзакцией, должны остаться сохраненными после возвращения системы в работу. Если пользователь получил подтверждение от системы, что транзакция выполнена, он может быть уверен, что сделанные им изменения не будут отменены из-за какого-либо сбоя.

[к оглавлению](#sql)

## Расскажите про уровни изолированности транзакций.

https://www.youtube.com/watch?v=gOB3hpAVIIQ

Уровень изолированности транзакций — условное значение, определяющее, в какой мере в результате выполнения логически параллельных транзакций в СУБД допускается получение несогласованных данных. 

<img width="935" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/8881d1f1-bd59-4ed1-9785-78075b5fcf2d">

Во время использования транзакций, для обеспечения целостности данных, СУБД использует блокировки, чтобы заблокировать доступ других обращений к данным, участвующим в транзакции. Такие блокировки необходимы, чтобы предотвратить:

+ «грязное» чтение (dirty read) — чтение данных, добавленных или изменённых транзакцией, которая впоследствии не подтвердится (откатится);
+ неповторяющееся чтение (non-repeatable read) — при повторном чтении в рамках одной транзакции ранее прочитанные данные оказываются изменёнными;
+ фантомное чтение (phantom reads) — ситуация, когда при повторном чтении в рамках одной транзакции одна и та же выборка дает разные множества строк.

В порядке роста уровня изолированности транзакций и надежности работы с данными: 

+ Чтение неподтверждённых данных (read uncommitted, dirty read) — чтение незафиксированных изменений как своей транзакции, так и параллельных транзакций. Нет гарантии, что данные, измененные другими транзакциями, не будут в любой момент изменены в результате их отката, поэтому такое чтение является потенциальным источником ошибок. Невозможны потерянные изменения, возможны неповторяемое чтение и фантомы.

Типичный способ реализации данного уровня изоляции — блокировка данных на время выполнения команды изменения, что гарантирует, что команды изменения одних и тех же строк, запущенные параллельно, фактически выполнятся последовательно, и ни одно из изменений не потеряется. Транзакции, выполняющие только чтение, при данном уровне изоляции никогда не блокируются. 

+ Чтение подтвержденных данных  (read committed) — чтение всех изменений своей транзакции и зафиксированных изменений параллельных транзакций. Потерянные изменения и грязное чтение не допускается, возможны неповторяемое чтение и фантомы

Блокирование читаемых и изменяемых данных. 

Заключается в том, что пишущая транзакция блокирует изменяемые данные для читающих транзакций, работающих на уровне read committed или более высоком, до своего завершения, препятствуя, таким образом, «грязному» чтению, а данные, блокируемые читающей транзакцией, освобождаются сразу после завершения операции SELECT (таким образом, ситуация «неповторяющегося чтения» может возникать на данном уровне изоляции). 

Сохранение нескольких версий параллельно изменяемых строк. 

При каждом изменении строки СУБД создаёт новую версию этой строки, с которой продолжает работать изменившая данные транзакция, в то время как любой другой «читающей» транзакции возвращается последняя зафиксированная версия. Преимущество такого подхода в том, что он обеспечивает бо́льшую скорость, так как предотвращает блокировки. 

+ Повторяемость чтения   (repeatable read, snapshot) — чтение всех изменений своей транзакции, любые изменения, внесенные параллельными транзакциями после начала своей, недоступны. Потерянные изменения, грязное и неповторяемое чтение невозможны, возможны фантомы. 

Блокировки в разделяющем режиме применяются ко всем данным, считываемым любой инструкцией транзакции, и сохраняются до её завершения. Это запрещает другим транзакциям изменять строки, которые были считаны незавершённой транзакцией. Пользоваться данным и более высокими уровнями транзакций без необходимости обычно не рекомендуется. 

Уровень изоляции "Repeatable Read" реализуется с использованием двух основных механизмов: блокировок и механизмов контроля версий. Конкретная реализация может различаться в зависимости от используемой базы данных.

1. Блокировки: При выполнении транзакции на уровне "Repeatable Read" блокировки применяются для предотвращения конфликтов чтения и записи между параллельно выполняющимися транзакциями. Когда транзакция считывает данные, она блокирует эти данные, чтобы другие транзакции не могли изменить или удалить их до завершения текущей транзакции. Это гарантирует, что данные, прочитанные в рамках транзакции, остаются неизменными до ее завершения.

2. Механизмы контроля версий: Дополнительно к блокировкам, некоторые базы данных могут использовать механизмы контроля версий для поддержки уровня изоляции "Repeatable Read". Вместо блокировки данных механизмы контроля версий создают копию данных на момент начала транзакции и позволяют транзакции видеть только эту версию данных. Если другая транзакция изменяет данные, то она создаст новую версию данных, не затрагивая транзакцию, выполняющую чтение. Таким образом, транзакция "Repeatable Read" видит данные, которые были валидными на момент ее начала, и не подвержена эффекту "неповторяющегося чтения".

При выполнении операций записи на уровне "Repeatable Read" могут быть применены различные подходы. Например, некоторые базы данных могут использовать блокировку с обновлением ("write lock"), чтобы блокировать другие транзакции от изменения данных до завершения текущей транзакции. Другие базы данных могут использовать подход, основанный на журналах транзакций и восстановлении ("transaction log and undo/redo"), чтобы обеспечить устойчивость транзакций и поддержку уровня изоляции "Repeatable Read".

Важно отметить, что конкретные детали реализации доступны для разработчиков баз данных и обычно не являются пользовательскими интерфейсами или частью стандартов SQL. Поэтому точные механизмы реализации могут различаться в зависимости от используемой базы данных.

+ Упорядочиваемость   (serializable) — результат параллельного выполнения стерилизуемой транзакции с другими транзакциями должен быть логически эквивалентен результату их какого-либо последовательного выполнения. Проблемы синхронизации не возникают. 
 
Самый высокий уровень изолированности; транзакции полностью изолируются друг от друга. Результат выполнения нескольких параллельных транзакций должен быть таким, как если бы они выполнялись последовательно. Только на этом уровне параллельные транзакции не подвержены эффекту «фантомного чтения». 

---------
Выбирая используемый уровень изолированности транзакций, разработчик информационной системы в определённой мере обеспечивает выбор между скоростью работы и обеспечением гарантированной согласованности получаемых из системы данных.

При параллельном выполнении транзакций возможны следующие проблемы:

+ потерянное обновление (англ. lost update) — при одновременном изменении одного блока данных разными транзакциями теряются все изменения, кроме последнего;
+ «грязное» чтение (англ. dirty read) — чтение данных, добавленных или изменённых транзакцией, которая впоследствии не подтвердится (откатится);
+ неповторяющееся чтение (англ. non-repeatable read) — при повторном чтении в рамках одной транзакции ранее прочитанные данные оказываются изменёнными;
+ фантомное чтение (англ. phantom reads) — одна транзакция в ходе своего выполнения несколько раз выбирает множество строк по одним и тем же критериям. Другая транзакция в интервалах между этими выборками добавляет строки или изменяет столбцы некоторых строк, используемых в критериях выборки первой транзакции, и успешно заканчивается. В результате получится, что одни и те же выборки в первой транзакции дают разные множества строк.

[к оглавлению](#sql)

## Что такое нормализация и денормализация? Расскажите про 3 нормальные формы?

Нормализация – процесс удаления избыточных данных. Это метод проектирования БД, который позволяет привести базу к минимальной избыточности.  
 
ОШИБКА!!! Не говорите, что нормализация – это процесс приведения к нормальной форме (масло масленое). 
 
Избыточность данных – это ситуация, когда одни и те же данные хранятся в базе в нескольких местах (таблицах). Именно это и приводит к аномалиям. 
 
Нормализация нужна для: 
+ устранения аномалий 
+ повышения производительности 
+ повышения удобства управления данными 
 
Базовые принципы реляционной теории: 
+ порядок строк не имеет значения 
+ порядок столбцов не имеет значения 

<img width="644" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/99ad42d3-f072-4865-87f7-bcbddf5b542b">

https://youtu.be/zqQxWdTpSIA 

Пример аномалии (данные избыточны и это проблема).  Решение: вынести данные о материале в отдельную таблицу (справа), появляется связь. 

<img width="1235" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/993b9ebd-c792-4fbc-b666-f75d63de57e6">

<img width="1031" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/cfc568da-d297-44bb-a753-a7d61dde5239">

Статья на хабре, откуда взяты примеры таблиц: https://habr.com/ru/post/254773/   

<img width="635" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/290cd532-2e2f-4244-b83c-07e25821f789">

Первая нормальная форма 1НФ  
 
+ В таблице НЕ должно быть дублирующих строк
+ В каждой ячейке таблицы хранится атомарное значение (одно НЕ составное)
+ В столбце хранятся данные одного типа
+ Отсутствуют массивы и списки в любом виде 

<img width="912" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/b12e2fbb-d336-4ed1-a9c0-8c198d99883b">

Нарушение нормализации 1НФ происходит в моделях BMW, т.к. в одной ячейке содержится список из 3 элементов: M5, X5M, M1, т.е. он не является атомарным.  
 
Преобразуем таблицу к 1НФ: 

<img width="907" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/7133ca78-13dd-4d5a-8162-46aac69068cf">

<img width="823" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/8cb3c2c8-427f-4823-82ce-d97df3cd86fb">

Вторая нормальная форма 2НФ 
 
+ Таблица должна находиться в 1НФ
+ Таблица должна иметь ключ
+ Все неключевые столбцы должны зависеть от полного ключа (в случае, если ключ составной) 
 
Пример: человек и его паспорт. По серии и номеру (составной ключ) можно определить уникального человека. 
 
Отношение находится во 2НФ, если оно находится в 1НФ и каждый не ключевой атрибут неприводимо зависит от Первичного Ключа (ПК). 
 
Неприводимость означает, что в составе потенциального ключа отсутствует меньшее подмножество атрибутов, от которого можно также вывести данную функциональную зависимость. Например, дана такая таблица с составным ключом (модель + фирма): 

<img width="991" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/74a9cb42-f143-46f3-9dfd-98fa1b5bd741">

Таблица находится в первой нормальной форме, но не во второй. Цена машины зависит от модели и фирмы (составной ключ). Скидка зависят ТОЛЬКО от фирмы, то есть зависимость от первичного ключа неполная.  
 
Исправляется это путем декомпозиции на два отношения, в которых не ключевые атрибуты зависят от первичного ключа ПК. 

<img width="1001" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/c292d0ca-6962-4f0c-93b1-233a26a88b53">

Декомпозиция: процесс разбиения одного отношения (таблицы) на несколько: 

<img width="1047" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/7f141e6b-58a5-4fa2-bd49-12490d46f81f">

<img width="427" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/dcfa28fc-d9bb-4a78-9e37-d656c1e38aa6">

Третья нормальная форма 3НФ 
 
+ Таблица должна находиться во 2НФ 
+ В таблицах отсутствует транзитивная зависимость 
 
Отношение находится в 3НФ, когда находится во 2НФ и каждый не ключевой атрибут не транзитивно зависит от первичного ключа. Проще говоря, второе правило требует выносить все не ключевые поля, содержимое которых может относиться к нескольким записям таблицы в отдельные таблицы. Таблица находится во 2НФ, но не в 3НФ: 

<img width="1030" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/83042657-c5e2-439c-a466-9a9619a60f8c">

В отношении атрибут «Модель» является первичным ключом. Личных телефонов у автомобилей нет, и телефон зависит исключительно от магазина. 
 
Таким образом, в отношении существуют следующие функциональные зависимости: 
Модель → Магазин, Магазин → Телефон, Модель → Телефон. Зависимость Модель → Телефон является транзитивной, следовательно, отношение не находится в 3НФ.  
 
В результате разделения исходного отношения получаются два отношения, 
находящиеся в 3НФ

<img width="686" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/1f5508fd-ecbd-4b86-9db7-2c5ab4241a67">
 
Магазин → Телефон 
Модель → Магазин 
                        
<img width="1030" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/1a628095-d91d-48ce-aff0-6836e5c99911">

<img width="508" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/c458d172-3faa-407b-bfa3-624bfa510dcb">

<img width="850" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/f59237ba-5862-45f1-bf12-cd19799a32ff">

Денормализация БД  
 
Денормализация базы данных — это процесс осознанного приведения базы данных к виду, в котором она не будет соответствовать правилам нормализации. Обычно это необходимо для повышения производительности и скорости извлечения данных, за счет увеличения избыточности данных. 

При денормализации важно сохранить баланс между повышением скорости работы базы и увеличением риска появления противоречивых данных, между облегчением жизни программистам, пишущим Select'ы, и усложнением задачи тех, кто обеспечивает наполнение базы и обновление данных. Поэтому проводить денормализацию базы надо очень аккуратно, очень выборочно, только там, где без этого никак не обойтись. 
 
Если заранее нельзя подсчитать плюсы и минусы денормализации, то изначально необходимо реализовать модель с нормализованными таблицами, и лишь затем, для оптимизации проблемных запросов проводить денормализацию. 
 
Оправдан ли будет переход? 
 
Определить требования (чего хотим достичь) -> определить требования к данным (что нужно соблюдать) -> найти минимальный шаг, удовлетворяющий эти требования -> подсчитать затраты на реализацию -> реализовать. 
 
Используемые термины 
 
Атрибут — свойство некоторой сущности. Часто называется полем таблицы. 
 
Домен атрибута — множество допустимых значений, которые может принимать атрибут. 
 
Кортеж — конечное множество взаимосвязанных допустимых значений атрибутов, которые вместе описывают некоторую сущность (строка таблицы). 
 
Отношение — конечное множество кортежей (таблица). 
 
Схема отношения — конечное множество атрибутов, определяющих некоторую сущность. Иными словами, это структура таблицы, состоящей из конкретного набора полей. 
 
Проекция — отношение, полученное из заданного путём удаления и (или) перестановки некоторых атрибутов. 
 
Функциональная зависимость между атрибутами (множествами атрибутов) X и Y означает, что для любого допустимого набора кортежей в данном отношении: если два кортежа совпадают по значению X, то они совпадают по значению Y. Например, если значение атрибута «Название компании» — Canonical Ltd, то значением атрибута «Штабквартира» в таком кортеже всегда будет Millbank Tower, London, United Kingdom. Обозначение: {X} -> {Y}. 
 
Нормальная форма — требование, предъявляемое к структуре таблиц в теории реляционных баз данных для устранения из базы избыточных функциональных зависимостей между атрибутами (полями таблиц). 
 
Метод нормальных форм (НФ) состоит в сборе информации о объектах решения задачи в рамках одного отношения и последующей декомпозиции этого отношения на несколько взаимосвязанных отношений на основе процедур нормализации отношений. 
 
Цель нормализации: исключить избыточное дублирование данных, которое является причиной аномалий, возникших при добавлении, редактировании и удалении кортежей(строк таблицы). 
 
Аномалией называется такая ситуация в таблице БД, которая приводит к противоречию в БД либо существенно усложняет обработку БД. Причиной является излишнее дублирование данных в таблице, которое вызывается наличием функциональных зависимостей от не ключевых атрибутов. 
 
Аномалии-модификации проявляются в том, что изменение одних данных может повлечь просмотр всей таблицы и соответствующее изменение некоторых записей таблицы. 
 
Аномалии-удаления — при удалении какого либо кортежа из таблицы может пропасть информация, которая не связана на прямую с удаляемой записью. 
 
Аномалии-добавления возникают, когда информацию в таблицу нельзя поместить, пока она не полная, либо вставка записи требует дополнительного просмотра таблицы. 

[к оглавлению](#sql)

## Что такое TIMESTAMP?

Для работы с датой и временем в MySQL есть несколько типов данных: DATE, TIME, DATETIME и TIMESTAMP.

<img width="1058" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/6ac62588-cf7e-413e-88b7-c6ac624714e7">

Отличие TIMESTAMP и DATETIME 
 
Типы данных DATETIME и TIMESTAMP в MySQL похожи друг на друга, так как оба направлены на хранение даты и времени. Но между ними есть ряд существенных отличий, определяющих какой из этих типов данных, когда лучше использовать. 

<img width="1039" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/3be53fea-4ec7-4aae-9307-b4d5833b4f2b">

Также стоит помнить о существенном ограничении TIMESTAMP в диапазоне возможных значений от 1970-01-01 00:00:01 до 2038-01-19 03:14:07, что ограничивает его применении. Так, данный тип данных не подойдет для хранения дат рождения пользователей. 

Способ задания значений: 

Значения DATETIME, DATE и TIMESTAMP могут быть заданы одним из следующих способов: 

<img width="1024" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/563ef42c-68bd-4e03-9b75-32605177fb34">

При указании даты допускается использовать любой знак пунктуации в качестве разделительного между частями разделов даты или времени. Также возможно задавать дату вообще без разделительного знака, слитно. 

<img width="1016" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/74b577c8-4f67-400c-bf18-35be1a5f25dd">

---------------
DATETIME предназначен для хранения целого числа: YYYYMMDDHHMMSS. И это время не  зависит от временной зоны настроенной на сервере. Размер: 8 байт

TIMESTAMP хранит значение равное количеству секунд, прошедших с полуночи 1 января 1970 года по усреднённому времени Гринвича. При получении из базы отображается с учётом часового пояса. Размер: 4 байта

----------
TIMESTAMP - это тип данных в базах данных, который используется для хранения даты и времени. Он позволяет представлять дату и время с точностью до микросекунд.

В базах данных TIMESTAMP может использоваться для следующих целей:

1. Хранение даты и времени, когда запись была создана или изменена. Это полезно для отслеживания изменений в таблице.
2. Задание даты и времени для конкретных событий в приложении, таких как заказы, регистрация пользователей, комментарии и т.д.
3. Поддержка функций, которые используют дату и время для выполнения рассчетов, например, вычисление промежутка времени между двумя датами или суммирование времени.

TIMESTAMP принимает значение в следующем формате:  YYYY-MM-DD HH:MM:SS.SSSSSS, где

- YYYY - год (четыре цифры)
- MM - месяц (две цифры)
- DD - день (две цифры)
- HH - час (две цифры)
- MM - минута (две цифры)
- SS - секунда (две цифры)
- SSSSSS - микросекунда (шесть цифр)

TIMESTAMP обычно представлен как количество секунд, прошедших с начала эпохи (1 января 1970 года 00:00:00 UTC), до указанного времени.

Некоторые базы данных и языки программирования, такие как MySQL и PHP, могут использовать свои собственные форматы TIMESTAMP, но основной формат YYYY-MM-DD HH:MM:SS.SSSSSS широко используется в многих различных контекстах.

В SQL-базах данных TIMESTAMP и DATETIME - это типы данных, используемые для хранения даты и времени.

DATETIME используется в тех случаях, когда предполагается, что дата и время не будут изменены никакими внешними факторами. Например, это может быть дата создания записи в базе данных или дата заказа товара в интернет-магазине.

TIMESTAMP, с другой стороны, обычно используется в случаях, когда дата и время должны быть связаны с определенными событиями. Например, это может быть дата и время изменения записи в таблице базы данных. Одно из главных преимуществ TIMESTAMP заключается в том, что оно автоматически обновляется при изменении строки в таблице.

В целом, если вам нужно хранить дату и время для отслеживания событий или изменений, использование TIMESTAMP обычно предпочтительнее. Если же вам нужно хранить дату и время, которые не будут изменяться, используйте DATETIME. Важно также учитывать особенности конкретной базы данных, использование индексов и другие факторы при выборе типа данных для хранения даты и времени.

[к оглавлению](#sql)

## Расскажи про шардирование баз данных 

https://www.youtube.com/watch?v=qdNlt8wR_84

При большом количестве данных запросы начинают долго выполняться, и сервер перестаёт справляться с нагрузкой. Одно из решений для оптимизации — это масштабирование базы данных. Например, шардинг или репликация (копирование). 

Шардинг бывает вертикальным (партицирование для 1 экз. БД) и горизонтальным. 

Допустим, есть большая таблица пользователей. Партицирование — это когда одну большую таблицу разделяют на много маленьких по какому-либо принципу. 

Единственное отличие горизонтального масштабирования от вертикального в том, что горизонтальное будет разносить данные по разным инстансам в других базах. 

Т.е. только записи с category_id=1 будут попадать в эту таблицу.

На базовую таблицу необходимо добавить правило. Когда мы будем работать с таблицей news, вставка на запись с category_id = 1 должна попасть именно в партицию news_1. Правило называем как хотим.

<img width="489" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/532784eb-053d-4083-82fb-132a53d17607">

<img width="988" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/9bb1ff9c-f767-480e-9837-3e8215bc9a66">

----------------
Шардирование баз данных (sharding) — это техника горизонтального масштабирования, при которой большие объемы данных разбиваются на более мелкие части, которые хранятся на разных физических серверах.

Основная цель шардирования — обеспечение распределения нагрузки на несколько серверов для более эффективной обработки запросов пользователей и увеличения производительности при работе с большими объемами данных.

Процесс шардирования может быть реализован с помощью различных подходов. Один из наиболее распространенных - горизонтальное шардирование, при котором таблицы базы данных разбиваются на отдельные «куски» (шарды) по горизонтальным строкам или диапазонам значений. Эти шарды могут храниться на разных физических серверах или даже в разных датацентрах, что позволяет достичь лучшей отказоустойчивости и доступности.

При использовании шардирования необходимо учитывать некоторые важные моменты, такие как:

+ Необходимость разработки соответствующей архитектуры, с учетом всех особенностей проекта и выбранных подходов;
+ Разумное разбиение данных на шарды с учетом не только объемов, но и логики работы с ними;
+ Разработка эффективной стратегии балансировки нагрузки на шарды;
+ Управление репликацией и синхронизацией данных между шардами;
+ Обеспечение безопасности и доступности, в том числе при отказах частей системы.

Шардирование баз данных может быть подходящим решением для проблем масштабируемости при работе с большими объемами данных, но требует определенных знаний, опыта и ресурсов для его правильной реализации и поддержки.

[к оглавлению](#sql)

## Как сделать запрос из двух баз? 

Допустим, у нас есть две таблицы: с товарами (есть поле owner_id, отвечающего за id владельца товара) и с пользователями (есть поле id). 

Мы хотим одним SQL-запросом получить все записи, причём чтобы в каждой была информация о пользователе и его одном товаре. В следующей записи была информация о том же пользователе и следующем его товаре. Когда товары этого пользователя закончатся, то переходить к следующему пользователю.  

Таким образом, мы должны соединить две таблицы и получить результат, в котором каждая запись содержит информацию о пользователе и об одном его товаре. 

<img width="1051" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/8051d345-56af-4896-8c1a-8df1c8a3c2be">

<img width="491" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/8f23d106-5e5f-4645-bd18-40b16914a930">

[к оглавлению](#sql)

## Что такое триггер? 

Триггер (trigger) — это хранимая процедура особого типа, которую пользователь не вызывает непосредственно, а исполнение которой обусловлено действием по модификации данных: добавлением, удалением или изменением данных в заданной таблице реляционной базы данных. 

Триггеры применяются для обеспечения целостности данных и реализации сложной бизнес-логики. Триггер запускается сервером автоматически и все производимые им модификации данных рассматриваются как выполняемые в транзакции, в которой выполнено действие, вызвавшее срабатывание триггера. Соответственно, в случае обнаружения ошибки или нарушения целостности данных может произойти откат этой транзакции.

Момент запуска триггера определяется с помощью ключевых слов BEFORE (триггер запускается до выполнения связанного с ним события) или AFTER (после события). В случае, если триггер вызывается до события, он может внести изменения в модифицируемую событием запись. 

Кроме того, триггеры могут быть привязаны не к таблице, а к представлению (VIEW). В этом случае с их помощью реализуется механизм «обновляемого представления». В этом случае ключевые слова BEFORE и AFTER влияют лишь на последовательность вызова триггеров, так как собственно событие (удаление, вставка или обновление) не происходит.

---------------
Триггер в SQL — это специальный тип хранимого объекта базы данных, который автоматически выполняется при определенных событиях или операциях в базе данных, например, при вставке, обновлении или удалении строк из таблицы. Триггеры могут исполняться как до, так и после выполнения операции.

SQL-триггеры - это блоки кода, которые запускаются автоматически при определенном событии в базе данных (например, при изменении данных в таблице). Вот несколько примеров триггеров SQL:

1. Триггер, который запускается при изменении данных в таблице "orders" и обновляет столбец "last_modified" в таблице "order_history":
```sql
CREATE TRIGGER orders_last_modified
AFTER UPDATE ON orders
FOR EACH ROW
BEGIN
    UPDATE order_history
    SET last_modified = CURRENT_TIMESTAMP
    WHERE order_id = NEW.order_id;
END;
```

2. Триггер, который запускается при удалении записи из таблицы "employees" и добавляет удаленную запись в таблицу "employee_history":
```sql
CREATE TRIGGER employee_deletion
AFTER DELETE ON employees
FOR EACH ROW
BEGIN
    INSERT INTO employee_history (employee_id, name, deleted_at)
    VALUES (OLD.employee_id, OLD.name, CURRENT_TIMESTAMP);
END;
```

3. Триггер, который запускается при добавлении записи в таблицу "invoice_items" и обновляет столбец "total_amount" в таблице "invoices":
```sql
CREATE TRIGGER update_invoice_total
AFTER INSERT ON invoice_items
FOR EACH ROW
BEGIN
    UPDATE invoices
    SET total_amount = total_amount + NEW.price * NEW.quantity
    WHERE invoice_id = NEW.invoice_id;
END;
``` 

4. Триггер, который запускается при обновлении столбца "status" в таблице "orders" и отправляет email-уведомление администратору:
```sql
CREATE TRIGGER send_order_email
AFTER UPDATE ON orders
FOR EACH ROW
BEGIN
    IF NEW.status <> OLD.status AND NEW.status = 'completed' THEN
        -- код для отправки email-уведомления
    END IF;
END;
``` 

5. Триггер, который запускается при добавлении новой записи в таблицу "customers" и создает соответствующий аккаунт в системе автоматической рассылки:
```sql
CREATE TRIGGER create_mailing_account
AFTER INSERT ON customers
FOR EACH ROW
BEGIN
    INSERT INTO mailing_system_accounts (email, password)
    VALUES (NEW.email, generate_random_password());
END;
``` 

Это лишь несколько примеров триггеров SQL, они могут иметь множество других применений в зависимости от потребностей бизнеса и требований приложений.

[к оглавлению](#sql)

## Что такое sql-injection (SQL инъекции)? 

Внедрение SQL кода (англ. SQL injection) — один из распространённых способов взлома сайтов и программ, работающих с базами данных, основанный на внедрении в запрос произвольного SQL-кода. 

SQL инъекция означает ввод/вставку SQL-кода в запрос с помощью введенных пользователем данных. Это может произойти в любых приложениях, использующих реляционные базы данных, такие как Oracle, MySQL, PostgreSQL и SQL Server.

<img width="969" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/37fdcb7c-8f00-4dea-b5ad-b558407d852a">

Н. Алишев (Spring Framework. Урок 26: SQL инъекции. PreparedStatement. JDBC API) https://youtu.be/Y2sRuCUpJ78  

----------
SQL-инъекция (SQL injection) - это техника атаки на веб-приложения, при которой злоумышленник использует уязвимости в обработке входных данных для внедрения и выполнения произвольных SQL-запросов в базе данных. Это может привести к несанкционированному доступу к данным, модификации, удалению или созданию новых записей и даже к полному контролю над базой данных и веб-приложением.

Пример SQL-инъекции: предположим, что у веб-приложения есть запрос для аутентификации пользователей с запросом в базу данных, который выглядит следующим образом:

```
SELECT * FROM users WHERE username='$username' AND password='$password'
```

Злоумышленник может ввести в поле "username" следующий код:

```
' OR 1=1--
```

Что приведет к тому, что SQL-запрос будет выглядеть так:

```
SELECT * FROM users WHERE username='' OR 1=1--' AND password='$password'
```

В результате этого запроса в базе данных будут выбраны все записи из таблицы "users", так как условие "1=1" всегда верно, и злоумышленник сможет получить доступ к данным без правильного ввода имени пользователя и пароля.

Чтобы избежать SQL-инъекций, следует использовать следующие рекомендации:

1. Использовать параметризированные запросы, которые не включают в себя введенные пользователем данные напрямую в SQL-запрос.

2. Экранировать специальные символы в данных пользователя, такие как кавычки и знаки граничения, чтобы предотвратить изменение структуры SQL-запроса.

3. Проверять и фильтровать входные данные пользователя, проверяя, соответствуют ли они ожидаемому формату и типу данных.

4. Проводить регулярное тестирование на проникновение для обнаружения уязвимостей и исправлять их своевременно.

Внедрение этих мер защиты позволяет снизить риски SQL-инъекций и сделать веб-приложение более безопасным.

[к оглавлению](#sql)

## Как выбрать между Statement, PreparedStatement и CallableStatement? 
 
Statement – SQL-выражение, подготовленное к выполнению в рамках определенной JDBC-сессии. Выполняется методом execute для обычного выражения, executeUpdate для модифицирующего, executeBatch для пакетного. Когда ожидаемый размер результата больше Integer.MAX_VALUE, используются версии методов executeLarge*. 
 
После выполнения, экземпляр Statement владеет ResultSet-ом, и другими данными о результате выполнения, такими как количество обновленных записей и сгенерированные ключи. 
 
PreparedStatement – пред-скомпилированная версия 	Statement	, его наследник. 

Эффективнее выполняет одно и то же выражение множество раз. Входные параметры объявляются в SQL-выражении символом ?	, следом сеттерами задаются их типы и значения. Делегирует обязанность экранировать введенные пользователем параметры базе данных. 
 
CallableStatement – наследник PreparedStatement для вызова хранимых процедур. Кроме входных параметров, позволяет регистрировать выходные. 
 
Экземпляры всех трех типов создаются методами интерфейса Connection. 

-------------
Statement, PreparedStatement и CallableStatement - это все различные типы объектов, используемых для выполнения запросов к базе данных в языке Java. 

Statement - это наиболее простой тип объекта для выполнения запросов к базе данных. Он представляет собой объект, который создает и выполняет простой SQL-запрос. Он может быть хорошим выбором, если у вас есть простые запросы без параметров.

PreparedStatement - представляет собой для выполнения параметризованных SQL-запросов. Он является более мощным, чем Statement, и позволяет предварительно компилировать запросы базы данных и кэшировать их в оперативной памяти, что повышает производительность при повторном использовании. PreparedStatement также предоставляет защиту от SQL-инъекций, что делает его безопасным для использования в приложениях, которые получают данные от пользователей.

CallableStatement - является расширением PreparedStatement и используется для вызова хранимых процедур базы данных. Он позволяет вызывать хранимые процедуры базы данных и получать результаты их выполнения. CallableStatement также поддерживает параметризацию запросов и защиту от SQL-инъекций.

Таким образом, при выборе между этими типами объектов в Java, вам следует учитывать сложность вашего запроса и требования безопасности. Если у вас есть простой запрос без параметров, можете использовать Statement. Если вам нужна поддержка параметризованных запросов и защиты от SQL-инъекций, PreparedStatement может быть более предпочтительным выбором. Если вы хотите вызвать хранимые процедуры базы данных, то вам следует использовать CallableStatement.

[к оглавлению](#sql)

## Какие классы вовлечены в соединение с базой данных? 
 
DriverManager управляет всеми JDBC-драйверами в приложении. Представляет набор статических методов. Лениво загружает системным класс-лоадером доступные Пред-сконфигурированные драйверы: 
+ По списку полных имен классов из проперти jdbc.drivers; 
+ Через Service Provider Interface (SPI). 
 
Менеджер занимается созданием экземпляра Connection – ключевого класса при работе с базой данных. Альтернативный менеджеру (и даже рекомендуемый) способ соединения с источником данных – ConnectionBuilder. Билдер получают из javax.sql.DataSource – формально это часть Java EE, так что здесь не будем подробно на нем останавливаться. 
 
Driver – главный класс реализации JDBC-драйвера. Когда загружается класслоадером,  сам регистрирует себя в DriverManager. Так что кроме предсконфигурированных драйверов, дополнительные можно загрузить просто вызвав Class.forName. 
 
Можно явно создавать Connection через драйвер, минуя менеджера и билдер. Драйвер предоставляет информацию о возможных/требуемых для своей работы свойствах в виде массива DriverPropertyInfo. 
 
DriverAction – дополнительный интерфейс, который должен реализовывать 	Driver	, если хочет получать уведомления о раз-регистрации DriverManager-ом. 
 
---------------
В Java для соединения с базой данных обычно используется JDBC (Java Database Connectivity). Соединение с базой данных выполняется в нескольких классах:

1. DriverManager: Это класс, который управляет соединениями с базой данных. Он предоставляет методы для получения соединения с базой данных (getConnection()) и отключения от нее (close()).

2. Connection: Этот класс представляет соединение с конкретной базой данных. С его помощью можно выполнить SQL-запросы и получить результаты.

3. Statement: Этот класс предназначен для выполнения простых SQL-запросов без параметров. Он предоставляет методы execute() для выполнения любых SQL-запросов.

4. PreparedStatement: Этот класс предназначен для выполнения обработанных SQL-запросов. Он предоставляет методы для установки параметров запроса и выполнения его (executeQuery() или executeUpdate()).

5. ResultSet: Этот класс представляет результаты выполнения SQL-запроса. Он предоставляет методы для перемещения по результатам и получения значений из них.

В зависимости от конкретной библиотеки или фреймворка для работы с базами данных, могут использоваться и другие классы. Например, в фреймворке Hibernate для работы с базами данных используются классы Session и Transaction.

[к оглавлению](#sql)

## Что можно делать с классом Connection? 
 
Итак, в результате соединения JDBC драйвера создается объект Connection – сессия работы с базой данных. Это главный класс при работе с JDBC. Основная роль этого класса – исполнение SQL-выражений (Statement) и получение их результатов в виде ResultSet. 
 
Connection предоставляет в виде класса DatabaseMetaData мета-информацию о базе данных в целом: таблицы, поддерживаемая грамматика SQL, хранимые процедуры, возможности этого соединения, и т.д.
 
В коннекшне задается множество настройки самого соединения. Это уровень изоляции транзакций, режим авто-коммита, ключи шардирования, и многое другое. Маппинг типов данных SQL в Java-типы задается здесь же, свойством typeMap. 
 
Помимо выполнения выражений, Connection предоставляет средства для управления транзакциями. Его методами можно создать Savepoint, откатиться к нему, закоммитить транзакцию когда авто-коммит отключен. 

------------
Класс Connection в языке Java представляет собой соединение с базой данных. Этот класс используется для установления соединения между приложением Java и сервером базы данных. 

Вот несколько вариантов действий, которые можно совершить с классом Connection в Java:

1. Открытие и закрытие соединения: используйте методы `Connection.open()` и `Connection.close()` для открытия и закрытия соединения. Обязательно закрывайте соединение после использования, чтобы не расходовать ресурсы сервера базы данных.

2. Выполнение SQL-запросов: используйте метод `Connection.createStatement()` для создания объекта Statement, который используется для выполнения SQL-запросов. Метод `Statement.executeQuery()` используется для выполнения запросов на выборку данных, а метод `Statement.executeUpdate()` - для операций изменения данных.

3. Подготовленные выражения: можно использовать метод `Connection.prepareStatement()` для создания подготовленного SQL-выражения, которое может быть повторно использовано с разными параметрами.

4. Управление транзакциями: можно использовать метод `Connection.setAutoCommit()` для управления автоматическим подтверждением транзакций. Методы `Connection.commit()` и `Connection.rollback()` используются для подтверждения или отмены транзакций вручную.

5. Установка свойств соединения: можно использовать методы `Connection.setReadOnly()` и `Connection.setTransactionIsolation()` для установки свойств соединения, таких как режим только для чтения и уровень изоляции транзакций.

6. Управление пулом соединений: можно использовать классы, такие как `DataSource` и `ConnectionPoolDataSource`, для управления пулом соединений, что может повысить производительность приложения и уменьшить нагрузку на сервер базы данных.

Это лишь некоторые примеры того, что можно делать с классом Connection в языке Java. Конечно, все зависит от конкретных задач и требований вашего приложения.

[к оглавлению](#sql)

## Какая разница между @ElementCollection, @⁠⁠OneToMany и @ManyToMany?⁠	 
 
Все эти аннотации – часть JPA (Java Persistence API).  С их использованием мы регулярно сталкиваемся в реализациях JPA, таких как Hibernate. 
 
Когда в базу данных сохраняется сущность, в которой есть поле-коллекция, это поле обязано быть помеченным одной из аннотаций. 
 
@⁠OneToMany и @ManyToMany⁠	 хранят вложенные объекты как отдельные полноценные сущности – для них действуют всё те же требования, которые JPA выдвигает для всех 	@Entity	 классов. Каждая из аннотаций отвечает за свое отношение. 
 
@ElementCollection⁠	 создает коллекцию встраиваемых классов. Применять её можно только на коллекции, тип элементов которых помечен @Embeddable, или входит в список стандартных встраиваемых классов (обертки примитивов, строки, даты, и т.д.). 
 
На уровне хранения в реляционной базе, для @ElementCollection будет также создана отдельная таблица. Технически она будет находиться в отношении one-to-many. 
 
Но из Java кода коллекция будет выглядеть встроенной: её элементом не нужно иметь собственные id, ими нельзя манипулировать отдельно от основной сущности.  
 
Единственное, чем такая коллекция отличается от встроенного поля-примитива – её можно загружать лениво (включено по умолчанию). 

-------------
Аннотации @ElementCollection, @OneToMany и @ManyToMany являются частями Java Persistence API (JPA) и используются для управления отношениями между объектами в базах данных. 

1) @ElementCollection: 

Эта аннотация используется для хранения коллекции простых значений (например, строк, чисел, дат и т.д.) как часть объекта-владельца. Простыми словами, если у вас есть класс, который имеет поле, содержащее коллекцию объектов, которые не имеют собственной жизненной цикл и связываются только с объектом-владельцем, то вам нужно использовать аннотацию @ElementCollection.

Например, у нас есть класс Person с аннотацией @ElementCollection, которая содержит коллекцию адресов человека:
```
@Entity
public class Person {
    
    @ElementCollection
    private List<String> addresses = new ArrayList<>();

    // остальные поля, геттеры и сеттеры
}
```

2) @OneToMany:

Аннотация @OneToMany используется для обозначения отношения «один-ко-многим» между двумя классами. Она указывает, что у одного объекта может быть несколько связанных объектов.

Например, если у вас есть класс Order, и каждый заказ имеет несколько элементов OrderLine, где каждый элемент OrderLine связан только с одним заказом, то вы можете использовать аннотацию @OneToMany, чтобы указать связь между ними. 

```
@Entity
public class Order {

    @OneToMany(mappedBy = "order", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<OrderLine> orderLines = new ArrayList<>();

    // остальные поля, геттеры и сеттеры
}

@Entity
public class OrderLine {

    @ManyToOne
    @JoinColumn(name = "order_id")
    private Order order;

    // остальные поля, геттеры и сеттеры
}
``` 

3) @ManyToMany:

Аннотация @ManyToMany используется для обозначения отношения «многие-ко-многим» между двумя классами. Она указывает, что один объект может быть связан с несколькими объектами другого класса, и наоборот.

Например, если у вас есть класс User, и каждый пользователь может иметь несколько ролей, а каждая роль может быть назначена нескольким пользователям, вы можете использовать аннотацию @ManyToMany, чтобы указать связь между ними.

```
@Entity
public class User {

    @ManyToMany
    @JoinTable(
        name = "user_role",
        joinColumns = @JoinColumn(name = "user_id"),
        inverseJoinColumns = @JoinColumn(name = "role_id"))
    private Set<Role> roles = new HashSet<>();

    // остальные поля, геттеры и сеттеры
}

@Entity
public class Role {

    @ManyToMany(mappedBy = "roles")
    private Set<User> users = new HashSet<>();

    // остальные поля, геттеры и сеттеры
}
```

Обратите внимание, что в примере с аннотацией @OneToMany применяется также аннотация @JoinColumn с аргументом "order_id". Эта аннотация указывает, что в таблице OrderLine будет создан столбец "order_id", который будет являться внешним ключом и указывать на запись в таблице Order. Также в аннотации @OneToMany используется аргумент "mappedBy", который указывает на имя поля в классе OrderLine, которое будет использоваться для связи с объектом класса Order. Это позволяет работать с соответствующими записями в таблицах базы данных с помощью ORM-framework без дополнительного кода.

[к оглавлению](#sql)

## SQL или NoSQL — вот в чём вопрос 

(No SQL или Not Only SQL) – посмотреть перед собеседованиями эту статью и далее видео → https://habr.com/ru/company/ruvds/blog/324936/  

В мире технологий баз данных существует два основных направления: SQL и NoSQL, реляционные и нереляционные базы данных. Различия между ними заключаются в том, как они спроектированы, какие типы данных поддерживают, как хранят информацию. 

Реляционные БД сгруппированы в таблицах, формат которых задан на этапе проектирования хранилища. 

Нереляционные БД устроены иначе. То, что в реляционной БД будет разбито на несколько взаимосвязанных таблиц, в нереляционной может храниться в виде целостной сущности. Нереляционные базы лучше поддаются масштабированию. 

Возможности, которые стали причиной популярности таких NoSQL баз данных, как MongoDB, CouchDB, Cassandra, HBase: 

1.Хранение больших объёмов неструктурированной информации.  

База данных NoSQL не накладывает ограничений на типы хранимых данных. Более того, при необходимости в процессе работы можно добавлять новые типы данных. 
 
2.Использование облачных вычислений и хранилищ.  

Облачные хранилища — отличное решение, но они требуют, чтобы данные можно было легко распределить между несколькими серверами для обеспечения масштабирования. Использование, для тестирования и разработки, локального оборудования, а затем перенос системы в облако, где она и работает — это именно то, для чего созданы NoSQL базы данных. 
 
3.Быстрая разработка.  

Если вы разрабатываете систему, используя agile-методы, применение реляционной БД способно замедлить работу. NoSQL базы данных не нуждаются в том же объёме подготовительных действий, которые обычно нужны для реляционных баз. 

Тут показана база данных, содержащая сведения о взаимоотношениях людей.  

Вариант a — это без-схемная структура, построенная в виде графа, характерная для NoSQL-решений. 

Вариант b показывает, как те же данные можно представить в структурированном виде, типичном для SQL.  

<img width="973" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/c132b20d-d030-41b1-94e0-adcc445cab6d">

Без-схемность означает, что два документа в структуре данных NoSQL не должны иметь одинаковые поля и могут хранить данные разных типов.  
Вот, например, массив объектов, набор полей которых не совпадает. 

<img width="798" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/ae47b410-62f8-4012-a5db-60c9c3d46b9d">

И в SQL, и в NoSQL-базах индексы служат одной и той же цели — ускорить и оптимизировать извлечение данных. Но то, как именно они работают — различается изза разных архитектур баз данных и особенностей хранения информации в базе.  

В то время, как SQL-индексы представлены в виде B-деревьев, которые отражают иерархическую структуру реляционных данных, в NoSQL базах данных они указывают на документы, или на части документов, между которыми, в основном, нет никаких отношений.  

CRM-приложения являются весьма удачным примером, в котором две системы баз данных выступают не конкурентами, а существуют в гармонии, играя каждая свою роль в большой архитектуре управления данными. 

Признаки проектов, для которых идеально подойдут SQL-базы: 
+ Имеются логические требования к данным, которые могут быть определены заранее.
+ Очень важна целостность данных.
+ Нужна основанная на устоявшихся стандартах, хорошо зарекомендовавшая себя технология, используя которую можно рассчитывать на большой опыт разработчиков и техническую поддержку. 
 
Свойства проектов, для которых подойдёт что-то из сферы NoSQL: 
+ Требования к данным нечёткие, неопределённые, или развивающиеся с развитием проекта.
+ Цель проекта может корректироваться со временем, при этом важна возможность немедленного начала разработки. • 	Одни из основных требований к базе данных — скорость обработки данных и масштабируемость. 
 
Всё чаще наблюдается интеграция этих технологий друг в друга. Например, Microsoft, Oracle и Teradata сейчас предлагают некоторые формы интеграции с Hadoop для подключения аналитических инструментов, основанных на SQL, к миру неструктурированных больших данных. 
 
Дополнительно по теме NoSQL, источник: https://www.youtube.com/watch?v=JG9Sgnj0xAI&t=112s  

По типам данных: 

<img width="849" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/210c2e70-6695-494b-b775-7e4440d699c4">

По способу хранения данных:  in-memory, persistent (in-place updates, snapshots, append-only log). 
 
Теорема CAP 

Это эвристическое утверждение о том, что в любой реализации распределённых вычислений возможно обеспечить не более двух из трёх следующих свойств:  
+ согласованность данных (англ. consistency) — во всех вычислительных узлах в один момент времени данные не противоречат друг другу; 
+ доступность (англ. availability) — любой запрос к распределённой системе завершается корректным откликом, однако без гарантии, что ответы всех узлов системы совпадают;
+ устойчивость к разделению (англ. partition tolerance) — расщепление распределённой системы на несколько изолированных секций не приводит к некорректности отклика от каждой из секций. 

<img width="710" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/eed64868-cc2a-4c3c-90c6-83fa6df5c69d">

Когда использовать NoSQL БД? 
+ Масштабируемость (линейная масштабируемость, когда путём увеличения ресурсов кластера, мы получаем пропорциональное увеличение характеристик кластера. Круто!)
+ Быстрое прототипирование (традиционные БД требуют ресурсов на обслуживание, использование не гибкое в меняющихся реалиях бизнестребований)
+ Высокая доступность (разносим БД по нескольким дата-центрам)
+ Кэширование
+ Буферизация (льётся большой поток данных, который нужно быстро обрабатывать, по потом сохранять результат)i
+ Очередь заданий (например, на сайте есть форма регистрации пользователя и во время сеанса не обязательно производить операцию сохранения e-mail в БД. Логичнее поставить это в очередь выполнения заданий). 
+ Хранилище бинарников (например, необходимо хранить фото, тогда можно поднять собственный кластер)
+ Быстрые счётчики
+ Эффективная оценка кардинальности множеств (уников) Помощь: алгоритм HyperLogLog. Проблема: производительность падает пропорционально количеству данных.
+ CMS – система управления контентом.
+ Полнотекстовый поиск. 
  
Анти-паттерны: как не нужно делать: 
+ Ваши данные реляционны (рис. 1) 
+ Излишний embedding
+ Недостаточный embedding
+ Неверно выбранный тип данных
+ Недостаточно продуманная схема данных

<img width="1094" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/89742766-fe8d-43c9-b7a7-df203cb117df">

Заключение (в стиле кэп): 
+ Знайте и изучайте свою предметную область
+ Следите за новостями
+ Выбирайте БД не только по пресс-релизам (изучайте также недостатки) 

[к оглавлению](#sql)


## SQL live coding на собеседовании

Кандидату дается условие устно, интервьюер смотрит что он пишет.  Перейти по ссылке и написать два простых запроса. 
 
1)Изменить тип данных столбца. В коде поменяем тип данных. Какие операции с БД нужно совершить, чтобы не потерять существующие данные и внести изменения? 
 
2)Рассмотрите схему базы данных на рисунке ниже и напишите соответствующие запросы 

<img width="532" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/62648089-a9d7-4b52-9018-0abdcbee0c16">

<img width="1021" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/60222e3f-d549-4a06-b6b5-1bde4a692795">

----------------
Вопросы с реальных собесов:  

Какие могут быть проблемы если ты создаешь индекс на таблицу весом 300гб в высоконагруженном проекте? 

Создание индекса на таблицу весом 300 ГБ в высоконагруженном проекте может привести к нескольким проблемам:

1. Долгое время создания индекса: создание индекса на большой таблице может занять большое количество времени, особенно если таблица активно используется во время создания индекса. Это может привести к тому, что приложение будет недоступно для пользователей на длительное время или будет работать медленно снижая производительность.

2. Потребление большого объема дискового пространства: создание индекса на таблице может привести к увеличению занимаемого ею объема дискового пространства. Это может быть проблемой, если диск заполнен на 80-90%, т.к. это может значительно замедлить работу всей системы.

3. Увеличенное время обновления и вставки данных: индекс должен быть обновлен каждый раз, когда данные в таблице изменяются. При обновлении индекса производительность может быть замедлена, что может привести к более долгому времени обновления и вставки данных.

4. Увеличенная нагрузка на процессор: при поиске данных по индексу используется процессор, что может привести к увеличению нагрузки на процессор. Это может быть проблемой, если у вас есть ограниченное количество ресурсов процессора.

5. Риск повреждения индекса: громадный индекс может повредиться, если произойдет непредвиденная ошибка или отказ жесткого диска. Восстановление такого индекса может быть длительным и трудоемким процессом.

Чтобы избежать этих проблем, нужно рассмотреть отслеживание роста размера таблицы, принимать меры оптимизации запросов SQL, а также рассмотреть возможность фрагментирования таблицы и индексирования только тех столбцов, которые широко используются для поиска данных. Также можно рассмотреть вариант использования кластерных индексов, которые позволяют сократить количество элементов в индексе и ускорить поиск данных.

А как можно улучшить селективность при неизменяемых данных? https://ru.stackoverflow.com/questions/675860/%D0%9E%D0%BF%D1%82%D0%B8%D0%BC%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-sql-%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D0%B0-%D0%B2-postgres

---------------
ПРАКТИКА ………………………………………………………………………………………………... 
Обязательные задачи SQL https://habr.com/ru/post/181033/ 
 
Академия SQL (учебник и онлайн тренажёр) https://sql-academy.org/ru/guide  
Документация PostgreSQL https://www.postgresql.org/docs/current/index.html  
Смотрите и практикуйте также курс DMDEV =) 

[к оглавлению](#sql)
