[Вопросы для собеседования](https://github.com/Oknel-Vap/Interview_questions/blob/main/QUESTIONS.md#interview_questions)

# Сериализация и копирование

+ [Что такое сериализация и как она реализована в Java?](#что-такое-сериализация-и-как-она-реализована-в-java)
+ [Для чего нужна сериализация?](#для-чего-нужна-сериализация)
+ [Опишите процесс сериализации/десериализации с использованием Serializable.](#опишите-процесс-сериализациидесериализации-с-использованием-serializable)
+ [Как изменить стандартное поведение сериализации/десериализации?](#как-изменить-стандартное-поведение-сериализациидесериализации)
+ [Какие поля не будут сериализованы при сериализации? Будет ли сериализовано final поле?](#какие-поля-не-будут-сериализованы-при-сериализации-будет-ли-сериализовано-final-поле)
+ [Как создать собственный протокол сериализации?](#как-создать-собственный-протокол-сериализации)
+ [Какая роль поля serialVersionUID в сериализации?](#какая-роль-поля-serialversionuid-в-сериализации)
+ [Когда стоит изменять значение поля serialVersionUID?](#когда-стоит-изменять-значение-поля-serialversionuid)
+ [В чем проблема сериализации Singleton?](#в-чем-проблема-сериализации-singleton)
+ [Расскажите про клонирование объектов.](#расскажите-про-клонирование-объектов)
+ [В чем отличие между поверхностным и глубоким клонированием?](#в-чем-отличие-между-поверхностным-и-глубоким-клонированием)
+ [Какой способ клонирования предпочтительней?](#какой-способ-клонирования-предпочтительней)
+ [Почему метод clone() объявлен в классе Object, а не в интерфейсе Cloneable?](#почему-метод-clone-объявлен-в-классе-object-а-не-в-интерфейсе-cloneable)
+ [Как создать глубокую копию объекта? (2 способа)](#как-создать-глубокую-копию-объекта-2-способа)


## Что такое сериализация и как она реализована в Java?

Сериализация (Serialization) - процесс преобразования структуры данных в линейную последовательность байтов для дальнейшей передачи или сохранения. Сериализованные объекты можно затем восстановить (десериализовать).

В Java, согласно спецификации Java Object Serialization существует два стандартных способа сериализации: стандартная сериализация, через использование интерфейса Java.io.Serializable и «расширенная» сериализация - Java.io.Externalizable.

Сериализация позволяет в определенных пределах изменять класс. Вот наиболее важные изменения, с которыми спецификация Java Object Serialization может справляться автоматически:

+ добавление в класс новых полей;
+ изменение полей из статических в нестатические;
+ изменение полей из транзитных в нетранзитные.
+ Обратные изменения (из нестатических полей в статические и из нетранзитных в транзитные) или удаление полей требуют определенной дополнительной обработки в зависимости от того, какая степень обратной совместимости необходима. Сериализация работает быстрее, чем JSON и XML, за счет того что это бинарные данные (байты).

Для чего нужна сериализация? - для передачи или сохранения объектов (данных).

[к оглавлению](#сериализация-и-копирование)

##  Для чего нужна сериализация?

Для передачи или сохранения объектов (данных).

Сериализация в Java используется для преобразования объектов в поток байтов, которые могут быть сохранены в файле или переданы по сети, и восстановления объектов из этих потоков байтов. Сериализация может быть полезна в следующих случаях:

+ Сохранение объектов в файлы: Сериализация позволяет сохранять состояние объектов в файлы на диске и восстанавливать их в будущем. Например, можно сериализовать состояние игрового уровня, чтобы сохранить прогресс игры и восстановить его при следующем запуске.
+ Передача объектов по сети: Сериализация позволяет передавать объекты между клиентом и сервером по сети. Например, можно сериализовать объект, содержащий данные пользователя, и передать его на сервер для аутентификации и обработки.
+ Использование объектов в кэше: Сериализация позволяет сохранить объекты в кэше, чтобы обеспечить быстрый доступ к ним. Например, можно сериализовать результаты выполнения сложных запросов к базе данных и сохранить их в кэше. При следующем запросе можно будет восстановить результаты из кэша, избегая излишних операций.
+ Распределенные вычисления: Сериализация позволяет передавать объекты между различными процессами или узлами в распределенной системе. Например, можно сериализовать задачу и отправить ее на удаленную машину для выполнения.
+ Многопоточное программирование: Сериализация объектов может быть использована для передачи данных между потоками, включая передачу данных через конвейеры или очереди.

Сериализация в Java обеспечивает удобную и стандартизированную основу для работы с объектами в различных сценариях, где требуется сохранение, передача или обмен данными с объектами.

[к оглавлению](#сериализация-и-копирование)

## Опишите процесс сериализации/десериализации с использованием Serializable.

При использовании Serializable применяется алгоритм сериализации, который с помощью рефлексии (Reflection API) выполняет:

+ запись в поток метаданных о классе, ассоциированном с объектом (имя класса, идентификатор SerialVersionUID, идентификаторы полей класса);
+ рекурсивную запись (загоняются все классы по очереди) в поток описания суперклассов до класса Java.lang.Object (не включительно);
+ запись примитивных значений полей сериализуемого экземпляра, начиная с полей самого верхнего суперкласса;
+ рекурсивную запись объектов, которые являются полями сериализуемого объекта.

Рефлексия (от позднелат. reflexio — обращение назад) — это механизм исследования данных о программе во время её выполнения. Рефлексия позволяет исследовать информацию о полях, методах и конструкторах классов.

При этом ранее сериализованные объекты повторно не сериализуются, что позволяет алгоритму корректно работать с циклическими ссылками. 

Для выполнения десериализации под объект выделяется память, после чего его поля заполняются значениями из потока. Конструктор объекта при этом не вызывается.

Однако при десериализации будет вызван конструктор без параметров родительского несериализуемого класса, а его отсутствие повлечет ошибку десериализации.

Для сериализации объектов в поток используется класс ObjectOutputStream. Он записывает данные в поток.
```java
void writeObject(Object obj): записывает в поток отдельный объект

void close(): закрывает поток

void flush(): очищает буфер и сбрасывает его содержимое в выходной поток
```
Для десериализации – ObjectInputStream.
```java
Object readObject(): считывает из потока объект

void close(): закрывает поток
```
Процесс сериализации и десериализации с использованием интерфейса `Serializable` в Java позволяет сохранять состояние объекта в виде последовательности байтов и восстанавливать объект из этой последовательности. Давайте рассмотрим процесс более подробно:

1. Сериализация:
   - Класс, который вы хотите сериализовать, должен реализовывать интерфейс `Serializable`. Этот интерфейс не содержит никаких методов, а служит только для пометки класса как сериализуемого.
   - При сериализации объекта создается поток байтов, в который записывается состояние объекта. Для этого используется класс `ObjectOutputStream`.
   - Вызывается метод `writeObject()` объекта `ObjectOutputStream`, передавая ему сериализуемый объект. Этот метод преобразует объект в последовательность байтов и записывает их в поток (Запись в поток означает запись данных в определенный источник данных, например, в файл или сетевое соединение. В Java запись в поток осуществляется с использованием классов, предоставляемых пакетом java.io.).
   - В результате выполнения сериализации получается файл или поток байтов, содержащий состояние объекта.

2. Десериализация:
   - Для восстановления объекта из сериализованной последовательности байтов используется класс `ObjectInputStream`.
   - Создается объект `ObjectInputStream`, который читает данные из файла или потока байтов.
   - Вызывается метод `readObject()` объекта `ObjectInputStream`, который считывает байты из потока и восстанавливает объект.
   - В результате выполнения десериализации получается восстановленный объект, который можно использовать в программе.

Вот пример кода, демонстрирующий процесс сериализации и десериализации с использованием интерфейса `Serializable`:

```java
import java.io.*;

public class SerializationExample {
    public static void main(String[] args) {
        // Сериализация объекта
        try {
            // Создание объекта для сериализации
            Person person = new Person("John", 25);

            // Сериализация объекта в файл
            FileOutputStream fileOut = new FileOutputStream("person.ser");
            ObjectOutputStream out = new ObjectOutputStream(fileOut);
            out.writeObject(person);
            out.close();
            fileOut.close();
            System.out.println("Объект был сериализован и сохранен в файл 'person.ser'.");
        } catch (IOException e) {
            e.printStackTrace();
        }

        // Десериализация объекта
        try {
            // Чтение объекта из файла
            FileInputStream fileIn = new FileInputStream("person.ser");
            ObjectInputStream in = new ObjectInputStream(fileIn);
            Person person = (Person) in.readObject();
            in.close();
            fileIn.close();
            System.out.println("Объект был успешно десериализован: " + person.toString());
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}

// Пример класса Person, реализующего интерфейс Serializable
class Person implements Serializable {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return "Person [name=" + name + ", age=" + age + "]";
    }
}
```

В этом примере класс `Person` реализует интерфейс `Serializable`, и объект этого класса сериализуется в файл `person.ser`. Затем объект десериализуется из этого файла, и восстановленный объект выводится на консоль.

Сериализация объекта:

   a. Создание экземпляра класса:
      - Прежде чем сериализовать объект, необходимо создать экземпляр класса, который вы хотите сериализовать. Для примера возьмем класс `Person`, который имеет поля `name` и `age`.

   b. Вызов метода `writeObject()`:
      - Создайте объект `ObjectOutputStream`, который оборачивает поток вывода, например, `FileOutputStream`.
      - Вызовите метод `writeObject()` объекта `ObjectOutputStream`, передавая ему сериализуемый объект в качестве аргумента. Этот метод преобразует объект в последовательность байтов и записывает их в поток.
      - Пример: `out.writeObject(person);`

   c. Механизм сериализации:
      - Во время сериализации механизм сериализации обходит все поля объекта и сериализует их значения. Если какое-либо поле ссылается на другой сериализуемый объект, то и этот объект будет сериализован.
      - Сериализация происходит рекурсивно, то есть если объект содержит ссылки на другие объекты, то они также будут сериализованы.
      - Поля, помеченные ключевым словом `transient`, не будут сериализованы. Это может быть полезно для исключения временных или ненужных данных из сериализации.

   d. SerialVersionUID:
      - Когда объект сериализуется, ему присваивается уникальный идентификатор версии, называемый `SerialVersionUID`. Этот идентификатор используется при десериализации для проверки совместимости версий класса.
      - Если класс, используемый при десериализации, имеет другую версию `SerialVersionUID`, чем у сериализованного объекта, возникнет исключение `InvalidClassException`. Чтобы избежать этой ошибки, рекомендуется явно указывать `SerialVersionUID` в вашем классе, добавив поле с модификатором `static` и `final`.
      - Пример: `private static final long serialVersionUID = 123456789L;`

   e. Обработка исключений:
      - При сериализации объекта могут возникнуть исключения, например, если класс не реализует интерфейс `Serializable` или если какое-либо поле содержит ссылку на несериализуемый объект.
      - Обработка исключений важна для обеспечения корректной работы сериализации. Рекомендуется использовать блок `try-catch` для обработки исключений и предпринять соответствующие действия в случае ошибки.

При восстановлении объекта может возникнуть исключение ClassNotFoundException. С чем это связано? Дело в том, что мы легко можем сериализовать объект класса Person в файл, передать его по сети нашему товарищу, который может восстановить объект другим приложением, в котором класса Person попросту нет.

[к оглавлению](#сериализация-и-копирование)

## Как изменить стандартное поведение сериализации/десериализации?

Реализовать интерфейс Java.io.Externalizable, который позволяет применение пользовательской логики сериализации. Способ сериализации и десериализации описывается в методах writeExternal() и readExternal().

Во время десериализации вызывается конструктор без параметров, а потом уже на созданном объекте вызывается метод readExternal.

Для «мегакастомной» сериализации. Не пишется мета-информация и инфа о суперклассах.

Если у сериализуемого объекта реализован один из следующих методов, то механизм сериализации будет использовать его, а не метод по умолчанию :
```java
writeObject() - запись объекта в поток;

readObject() - чтение объекта из потока;

writeReplace() - позволяет заменить себя экземпляром другого класса перед записью;

readResolve() - позволяет заменить на себя другой объект после чтения
```
Для изменения стандартного поведения сериализации и десериализации в Java вы можете использовать различные механизмы и аннотации. Вот несколько способов изменить поведение:

1. Использование аннотаций:
   - `@Transient`: Аннотация `@Transient` позволяет исключить поле из сериализации. Если поле помечено этой аннотацией, оно не будет сохранено в сериализованном объекте.
   - `@Serial`: Аннотация `@Serial` позволяет указать альтернативное имя для поля при сериализации и десериализации. Например, вы можете использовать ее для сохранения и восстановления данных с использованием других имен полей.

2. Реализация интерфейсов:
   - `Externalizable`: Реализация интерфейса `Externalizable` позволяет вам полностью контролировать процесс сериализации и десериализации. Вы должны реализовать методы `writeExternal()` и `readExternal()`, в которых определяете, какие поля должны быть сохранены и восстановлены.
   - `Serializable`: Реализация интерфейса `Serializable` предоставляет стандартное поведение сериализации и десериализации. Однако вы можете дополнительно определить методы `writeObject()` и `readObject()`, чтобы включить пользовательскую логику в процесс сериализации и десериализации.

3. Переопределение методов:
   - `writeObject()` и `readObject()`: Вы можете переопределить методы `writeObject()` и `readObject()` в классе, чтобы добавить свою логику сериализации и десериализации. Например, вы можете изменить или дополнить значения полей перед записью или после чтения.

4. Использование внешних сериализаторов:
   - Вы можете использовать сторонние библиотеки или фреймворки, такие как Jackson, Gson или XStream, чтобы получить большую гибкость и контроль над сериализацией и десериализацией. Эти библиотеки предоставляют различные аннотации и настройки для управления процессом сериализации и десериализации.

Обратите внимание, что изменение стандартного поведения сериализации и десериализации может потребовать особой осторожности и может привести к проблемам совместимости. При изменении поведения убедитесь, что вы учитываете возможные последствия и тестируете ваш код внимательно.

Конкретные примеры для второго способа, связанного с реализацией интерфейсов `Externalizable` и `Serializable`, могут выглядеть следующим образом:

1. Использование интерфейса `Externalizable`:
```java
import java.io.*;

public class MyClass implements Externalizable {
    private String name;
    private int age;

    public MyClass() {
        // Обязательный пустой конструктор для Externalizable
    }

    public MyClass(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public void writeExternal(ObjectOutput out) throws IOException {
        // Сохранение только поля "name"
        out.writeObject(name);
    }

    @Override
    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
        // Восстановление только поля "name"
        name = (String) in.readObject();
    }

    // Геттеры и сеттеры для полей name и age
}
```
В этом способе мы явно создали конструктор по умолчанию, причем публичный. Зачем это сделано? Для интерфейса Externalizable будет вызван метод получения конструктора getExternalizableConstructor(), внутри которого мы через Reflection попробуем получить конструктор по умолчанию класса, для которого мы восстанавливаем объект. Если нам не удается его найти, или он не public, то мы получаем исключение. Обойти эту ситуацию можно следующим образом: не создавать явно никакого конструктора в классе и заполнять поля с помощью сеттеров и получать значение геттерами. Тогда при компиляции класса будет создан конструктор по умолчанию, который будет доступен для getExternalizableConstructor(). Для Serializable метод getSerializableConstructor() получает конструктор класса Object и от него ищет нужный класс, если не найдет, то получим исключение ClassNotFoundException. Выходит, что ключевое различие между Serializable и Externalizable в том, что первому не нужен конструктор для создания восстановления объекта. Он просто полностью восстановится из байтов. Для второго при восстановлении сначала будет создан объект с помощью конструктора в точке объявления, а затем в него будут записаны значения его полей из байтов, полученных при сериализации. 

2. Использование интерфейса `Serializable` с явным добавлением методов `writeObject()` и `readObject()`:
```java
import java.io.*;

public class MyClass implements Serializable {
    private String name;
    private int age;

    public MyClass(String name, int age) {
        this.name = name;
        this.age = age;
    }

    private void writeObject(ObjectOutputStream out) throws IOException {
        // Сохранение только поля "name"
        out.writeObject(name);
    }

    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
        // Восстановление только поля "name"
        name = (String) in.readObject();
    }

    // Геттеры и сеттеры для полей name и age
}
```

В обоих примерах мы ограничились сохранением и восстановлением только поля "name". Вы можете адаптировать код в соответствии с вашими потребностями и добавить логику для других полей или изменить поведение сериализации и десериализации по своему усмотрению.

Причем, даже если нам нужно все таки задать поведение сериализации, мы можем не использовать Externalizable, а так же реализовать Serializable, добавив (не переопределив) в него методы writeObject() и readObject(). Но для того, чтобы они «работали» нужно точно соблюсти их сигнатуру. Внутри наших добавленных методов вызываются defaultWriteObject() и defaultReadObject(). Они отвечают за сериализацию по умолчанию, как если бы она работала без добавленных нами методов.


[к оглавлению](#сериализация-и-копирование)

## Какие поля не будут сериализованы при сериализации? Будет ли сериализовано final поле?

Да (final сериализуется).

Поля класса, помеченные модификатором transient, не сериализуются. 

Обычно в таких полях хранится промежуточное состояние объекта, которое, к примеру, проще вычислить.

Другой пример такого поля - ссылка на экземпляр объекта, который не требует сериализации или не может быть сериализован.

При стандартной сериализации поля, имеющие модификатор static, не сериализуются. Соответственно, после десериализации это поле значения не меняет.

При использовании реализации Externalizable сериализовать и десериализовать статическое поле можно, но не рекомендуется этого делать, т.к. это может сопровождаться трудноуловимыми ошибками.

Поля с модификатором final сериализуются как и обычные. За одним исключением – их невозможно десериализовать при использовании Externalizable, поскольку final поля должны быть инициализированы в конструкторе, а после этого в readExternal() изменить значение этого поля будет невозможно. Соответственно, если необходимо сериализовать объект с final полем необходимо использовать только стандартную сериализацию.

При сериализации в Java не будут сериализованы следующие типы полей:

1. Поля, помеченные как `transient`: Поля, которые помечены ключевым словом `transient`, являются временными и не должны быть сериализованы. Это может быть полезно для исключения конфиденциальных данных или временных состояний объекта из сериализации.

2. Статические поля: Статические поля не относятся к конкретному экземпляру объекта, поэтому они не сериализуются. Статические поля относятся к классу в целом, а не к его конкретным экземплярам.

3. Поля, несериализуемые по своей природе: Это включает поля, которые имеют типы, не реализующие интерфейс `Serializable` и не являющиеся примитивными типами данных. Несериализуемые поля могут вызывать исключение `NotSerializableException` при попытке сериализации.

Относительно `final` полей, их поведение зависит от контекста:

- Если `final` поле является примитивным типом данных, оно будет сериализовано вместе с объектом.
- Если `final` поле является ссылочным типом данных и класс, содержащий это поле, реализует интерфейс `Serializable`, то `final` поле также будет сериализовано.
- Если `final` поле является ссылочным типом данных, но класс, содержащий это поле, не реализует интерфейс `Serializable`, то `final` поле не будет сериализовано. В этом случае его значение не будет сохранено при сериализации и будет потеряно при десериализации.

Обратите внимание, что при десериализации `final` поле будет иметь значение, установленное в момент создания объекта, а не сохраненное значение. Это связано с тем, что `final` поля должны быть инициализированы до конца конструктора и не могут быть изменены после этого.


[к оглавлению](#сериализация-и-копирование)

## Как создать собственный протокол сериализации?

Для создания собственного протокола сериализации достаточно реализовать интерфейс Externalizable, который содержит два метода:

public void writeExternal(ObjectOutput out) throws IOException;

public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException


[к оглавлению](#сериализация-и-копирование)

## Какая роль поля serialVersionUID в сериализации?

serialVersionUID используется для указании версии сериализованных данных.

Когда мы не объявляем serialVersionUID в нашем классе явно, среда выполнения Java делает это за нас, но этот процесс чувствителен ко многим метаданным класса включая количество полей, тип полей, модификаторы доступа полей, интерфейсов, которые реализованы в классе и пр. Рекомендуется явно объявлять serialVersionUID т.к. при добавлении, удалении атрибутов класса динамически сгенерированное значение может измениться и в момент выполнения будет выброшено исключение InvalidClassException.

private static final long serialVersionUID = 20161013L;

[к оглавлению](#сериализация-и-копирование)

## Когда стоит изменять значение поля serialVersionUID?

serialVersionUID нужно изменять при внесении в класс несовместимых изменений, например при удалении какого-либо его атрибута.

Чтобы не допустить автоматическую сериализацию можно переопределить private методы для создания исключительной ситуации NotSerializableException.
```java
private void writeObject(ObjectOutputStream out) throws IOException { 

throw new NotSerializableException(); 

} 

private void readObject(ObjectInputStream in) throws IOException { 

throw new NotSerializableException(); 

}
```
Любая попытка записать или прочитать этот объект теперь приведет к возникновению исключительной ситуации.

Значение поля serialVersionUID следует изменять в следующих случаях:

+ Когда происходят изменения в классе, которые могут привести к несовместимости с предыдущими версиями класса. Например, добавление новых полей или методов, изменение типов существующих полей или методов.
+ Когда нужно гарантировать совместимость с предыдущими версиями класса. Если класс уже был сериализован и сохранен в файл или передан по сети, и затем были внесены изменения в класс, новая версия должна иметь другое значение serialVersionUID, чтобы обеспечить корректную десериализацию сохраненных экземпляров класса.
+ Когда требуется компиляция класса с помощью разных версий компилятора Java. Разные версии компилятора могут генерировать разные значения serialVersionUID, что может привести к несовместимости при десериализации.

В остальных случаях, если класс не будет десериализовываться, изменение значения serialVersionUID скорее всего не понадобится.

Значение `serialVersionUID`, считанное из потока во время десериализации, сравнивается с текущим значением `serialVersionUID` в классе, к которому применяется десериализация.

Если значения `serialVersionUID` совпадают, то десериализация продолжается без проблем. Однако если значения не совпадают, возникает исключение `InvalidClassException`, и десериализация не выполняется. Это гарантирует, что десериализация происходит только для классов с одинаковым `serialVersionUID`, чтобы обеспечить совместимость версий классов.

Если класс не определяет явно `serialVersionUID`, то Java автоматически генерирует его на основе хэш-кода структуры класса. В этом случае, при десериализации, значение `serialVersionUID`, считанное из потока, будет сравниваться с автоматически сгенерированным значением `serialVersionUID`. Если они не совпадают, возникает исключение `InvalidClassException`.

Чтобы обеспечить успешную десериализацию при изменении класса, рекомендуется явно определять `serialVersionUID` и обновлять его при внесении изменений в структуру класса. Это позволяет контролировать совместимость версий классов и избегать проблем при десериализации.

[к оглавлению](#сериализация-и-копирование)

## В чем проблема сериализации Singleton?

Проблема в том, что после десериализации мы получим другой объект. Таким образом, сериализация дает возможность создать Singleton еще раз, что недопустимо.

Существует два способа избежать этого:
+ явный запрет сериализации.
+ определение метода с сигнатурой default/public/private/protected Object readResolve() throws ObjectStreamException, назначением которого станет возврат замещающего объекта вместо объекта, на котором он вызван.

Singleton - это шаблон проектирования, который обеспечивает создание только одного экземпляра класса в рамках одной JVM. Он достигается путем применения закрытого конструктора и статической переменной экземпляра класса.

Проблема с сериализацией Singleton в Java заключается в том, что при десериализации объекта, который является Singleton-ом, может быть создан новый экземпляр, что нарушает инварианты Singleton-а. Другими словами, после десериализации может оказаться, что у нас есть два экземпляра Singleton-а вместо одного, что не соответствует предназначению шаблона.

Есть два способа решения этой проблемы:

Переопределить методы readResolve() и writeReplace() в классе Singleton, чтобы гарантировать, что при десериализации всегда будет возвращаться единственный экземпляр Singleton-а. Например:
```java
private Object readResolve() {
return INSTANCE;
}

private Object writeReplace() {
return INSTANCE;
}
```
Эти методы гарантируют, что при десериализации будет возвращен тот же экземпляр Singleton-а, что и при сериализации, то есть INSTANCE.

Использовать Enum для реализации Singleton-а вместо класса. ENUM Singleton не имеет проблем с сериализацией, поскольку JVM гарантирует, что каждый элемент перечисления создается только один раз. Например:
```java
public enum Singleton {
INSTANCE;
}
```
В целом, использование Enum и переопределение методов readResolve() и writeReplace() - это два способа решения проблемы сериализации Singleton-а в Java.

При десериализации JVM использует механизм специальных методов, называемых "методами магической ссылки" (magic methods), для обработки различных аспектов сериализации и десериализации. Один из таких методов - это метод `readResolve()`, который может быть определен в классе, реализующем интерфейс `Serializable`.

Когда JVM выполняет процесс десериализации, она проверяет, есть ли в классе, который должен быть восстановлен из сериализованного состояния, метод `readResolve()`. Если метод `readResolve()` присутствует и имеет правильную сигнатуру (`private Object readResolve() throws ObjectStreamException`), то JVM автоматически вызывает этот метод после создания объекта при десериализации.

Таким образом, JVM "понимает", что нужно вызвать метод `readResolve()`, исходя из наличия этого метода в классе и его сигнатуры. Это является частью стандартного процесса десериализации в JVM и позволяет программисту контролировать восстановление объектов после десериализации.

[к оглавлению](#сериализация-и-копирование)

## Расскажите про клонирование объектов

Использование оператора присваивания не создает нового объекта, а лишь копирует ссылку на объект. Таким образом, две ссылки указывают на одну и ту же область памяти, на один и тот же объект.

Для создания нового объекта с таким же состоянием используется клонирование объекта.

Класс Object содержит protected метод clone(), осуществляющий побитовое копирование объекта производного класса. Однако сначала необходимо переопределить метод clone() как public для обеспечения возможности его вызова. В переопределенном методе следует вызвать базовую версию метода super.clone(), которая и выполняет собственно клонирование. 

Чтобы окончательно сделать объект клонируемым, класс должен реализовать интерфейс Cloneable.

Интерфейс Cloneable не содержит методов относится к маркерным интерфейсам, а его реализация гарантирует, что метод clone() класса Object возвратит точную копию вызвавшего его объекта с воспроизведением значений всех его полей. В противном случае метод генерирует исключение CloneNotSupportedException.

Следует отметить, что при использовании этого механизма объект создается без вызова конструктора.

Это решение эффективно только в случае, если поля клонируемого объекта представляют собой значения базовых типов и их обёрток или неизменяемых (immutable) объектных типов.

Если же поле клонируемого типа является изменяемым ссылочным типом, то для корректного клонирования требуется другой подход. Причина заключается в том, что при создании копии поля оригинал и копия представляют собой ссылку на один и тот же объект. В этой ситуации следует также клонировать и сам объект поля класса.

Такое клонирование возможно только в случае, если тип атрибута класса также реализует интерфейс Cloneable и переопределяет метод clone(). Так как, если это будет иначе вызов метода невозможен из-за его недоступности. Отсюда следует, что если класс имеет суперкласс, то для реализации механизма клонирования текущего класса-потомка необходимо наличие корректной реализации такого механизма в суперклассе. При этом следует отказаться от использования объявлений final для полей объектных типов по причине невозможности изменения их значений при реализации клонирования.
```java
class Book implements Cloneable { 

private String name; 
private Author author; 

… 
public Book clone() throws CloneNotSupportedException{ 

Book newBook = (Book) super.clone(); 
newBook.author=(Author) author.clone(); 
return newBook; 
}

} 

class Author implements Cloneable{ 

… 
public Author clone() throws CloneNotSupportedException{ 

return (Author) super.clone(); 

} 

}
```
Помимо встроенного механизма клонирования в Java для клонирования объекта можно использовать:

Специализированный конструктор копирования - в классе описывается конструктор, который принимает объект этого же класса и инициализирует поля создаваемого объекта значениями полей переданного.
```java
public class Bird implements Flyable { 

//специализированный конструктор копирования объектов исп. сам себя в качестве параметра 

public Bird(Bird birdOther) { 

this(birdOther.getName(), birdOther.getAge(), 
new BirdHead(birdOther.birdHead)); 

} 

public class BirdHead { 

public BirdHead(BirdHead otherBirdHead) {

this(otherBirdHead.getHeadDiameter(), 
otherBirdHead.getHeadName()); 

} 


Bird birdClone1 = new Bird("синичка", 1, new BirdHead(1,"голова синички")); 
Bird birdClone2 = new Bird(birdClone1); 

birdClone2.setName("снигирь"); 
birdClone2.getBirdHead().setHeadName("голова снигиря"); 
System.out.println(birdClone1); 
System.out.println(birdClone2);//Как видим, при изменении объекта 2 , данные в объекте 1 не изменились 
```

Фабричный метод - (Factory method), который представляет собой статический метод, возвращающий экземпляр своего класса.
Да, вы правы, фабричный метод также может быть использован для клонирования объектов. Фабричный метод представляет собой статический метод, который создает и возвращает экземпляр своего класса. В контексте клонирования, фабричный метод может быть использован для создания нового объекта, который является копией существующего объекта.

Вот пример, как фабричный метод может быть использован для клонирования объекта:

```java
public class MyClass {
    private int value;
    private MyObject obj;

    private MyClass(int value, MyObject obj) {
        this.value = value;
        this.obj = obj;
    }

    public static MyClass createInstance(MyClass other) {
        return new MyClass(other.value, other.obj);
    }

    // ...
}
```

В данном примере, фабричный метод `createInstance()` принимает объект `other` того же класса в качестве параметра и создает новый объект `MyClass`, инициализируя его значениями полей объекта `other`. Это позволяет создать копию объекта `MyClass` без необходимости использования метода `clone()`.

Фабричный метод может быть полезным, когда у вас нет доступа к методу `clone()` или когда вы предпочитаете использовать другой механизм для создания копий объектов. Он также может предоставить большую гибкость при создании объектов, например, позволяя настраивать создаваемые объекты или выполнять дополнительные операции перед созданием копии.

Важно отметить, что использование фабричного метода для клонирования объектов требует явного написания кода для создания копии объекта, в отличие от использования метода `clone()`, который автоматически выполняет клонирование.

Механизм сериализации - сохранение и последующее восстановление объекта в/из потока байтов.

[к оглавлению](#сериализация-и-копирование)

## В чем отличие между поверхностным и глубоким клонированием?

Поверхностное копирование копирует настолько малую часть информации об объекте, насколько это возможно. По умолчанию, клонирование в Java является поверхностным, т.е. класс Object не знает о структуре класса, которого он копирует.

Клонирование такого типа осуществляется JVM по следующим правилам:
+ Если класс имеет только члены примитивных типов, то будет создана совершенно новая копия объекта и возвращена ссылка на этот объект.
+ Если класс помимо членов примитивных типов содержит члены ссылочных типов, то тогда копируются ссылки на объекты этих классов.
Следовательно, оба объекта будут иметь одинаковые ссылки. То есть, изменение состояния объектов в скопированном объекте может также повлиять на исходный объект и наоборот.

Глубокое копирование дублирует абсолютно всю информацию объекта:

+ Нет необходимости копировать отдельно примитивные данные;
+ Все члены ссылочного типа в оригинальном классе должны поддерживать клонирование. Для каждого такого члена при переопределении метода clone() должен вызываться super.clone();
+ Если какой-либо член класса не поддерживает клонирование, то в методе клонирования необходимо создать новый экземпляр этого класса и скопировать каждый его член со всеми атрибутами в новый объект класса, по одному.

[к оглавлению](#сериализация-и-копирование)

## Какой способ клонирования предпочтительней?

Наиболее безопасным и следовательно предпочтительным способом клонирования является использование специализированного конструктора копирования:
+ Отсутствие ошибок наследования (не нужно беспокоиться, что у наследников появятся новые поля, которые не будут склонированы через метод clone());
+ Поля для клонирования указываются явно;
+ Возможность клонировать даже final поля.

В Java предпочтительнее использовать клонирование через интерфейс Cloneable и метод clone(). Однако, необходимо учитывать, что клонирование может быть ненадежным при использовании вложенных объектов или при необходимости глубокого клонирования. В некоторых случаях, более предпочтительной может быть ручная реализация копирования объектов с помощью конструктора копирования или метода фабрики.

Глубокая копия является предпочтительным подходом по сравнению с поверхностной копией, когда в объекте присутствуют какие-либо объекты, на которые есть ссылки. Глубокое копирование утомительно в реализации, подвержено ошибкам и сложно в обслуживании.

[к оглавлению](#сериализация-и-копирование)

## Почему метод clone() объявлен в классе Object, а не в интерфейсе Cloneable?

Чтобы создать через клон новый объект – через интерфейс.

Метод clone() объявлен в классе Object с указанием модификатора native, чтобы обеспечить доступ к стандартному механизму поверхностного копирования объектов.

Одновременно он объявлен и как protected, чтобы нельзя было вызвать этот метод у не переопределивших его объектов. Непосредственно интерфейс Cloneable является маркерным (не содержит объявлений методов) и нужен только для обозначения самого факта, что данный объект готов к тому, чтобы быть клонированным. Вызов переопределённого метода clone() у не Cloneable объекта вызовет выбрасывание CloneNotSupportedException.

Метод clone() объявлен в классе Object, а не в интерфейсе Cloneable, потому что метод clone() должен быть реализован в самом объекте, а не в интерфейсе. Интерфейс Cloneable не содержит никакой реализации метода clone(), он просто указывает, что класс, имплементирующий данный интерфейс, должен поддерживать клонирование.

Кроме того, метод clone() имеет модификатор доступа protected, что означает, что он может быть вызван только из класса или его подклассов. Таким образом, любой класс, который хочет поддерживать клонирование, может реализовать метод clone() и обеспечить его правильную работу.

Также следует отметить, что при клонировании объектов вызывается метод clone() у объекта-прототипа, который должен иметь тип Object. Если же бы метод clone() был объявлен в интерфейсе Cloneable, то тогда у каждого объекта-прототипа в Java было бы неявно добавлено объявление метода clone(), что могло бы привести к проблемам совместимости и другим нежелательным последствиям.

Контракт клонирования в Java диктует, что каждая clone реализация должна сначала получить клонированный экземпляр из super.clone(). Это создает цепочку, которая всегда заканчивается вызовом Object.clone, и этот метод содержит «магический» код нативного уровня, который создает двоичную копию базового необработанного кода struct, представляющего объект Java. Если бы этого механизма не существовало, clone он не был бы полиморфным: Object.clone метод создает экземпляр любого класса, для которого он вызывается; это невозможно воспроизвести без собственного кода.

Вот почему Object.clone нельзя было избежать этого метода. Cloneable мог бы содержать clone метод, но это создало бы проблемы с throws предложением. В нынешнем виде вы можете объявлять clone без объявленных исключений или объявлять произвольные исключения. Такая гибкость была бы невозможна, если бы метод уже был объявлен в интерфейсе.

https://stackoverflow.com/questions/27224577/why-is-object-clone-native-in-java

По сути, потому что clone()метод делает то, что вы не можете сделать в языке Java: он клонирует состояние объекта, включая его фактическое обозначение класса.

Механизм клонирования в Java основан на том, что каждый класс вызывает cloneметод суперкласса вплоть до Object. Затем Object использует этот «магический» нативный cloneметод для дублирования исходного объекта, включая его фактический класс.

[к оглавлению](#сериализация-и-копирование)

## Как создать глубокую копию объекта? (2 способа)

Через конструктор копирования (1 способ) и через перепределение clone () (2 способ), сериализация (3 способ).Сериализация JSON с помощью Gson.

[к оглавлению](#сериализация-и-копирование)
