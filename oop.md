[Вопросы для собеседования](https://github.com/Oknel-Vap/Interview_questions/blob/main/QUESTIONS.md#interview_questions)

# ООП
+ [Что такое _ООП_?](#Что-такое-ООП)
+ [Назовите основные принципы _ООП_.](#Назовите-основные-принципы-ООП)
+ [Что такое _«инкапсуляция»_?](#Что-такое-инкапсуляция)
+ [Что такое _«наследование»_?](#Что-такое-наследование)
+ [Что такое _«полиморфизм»_?](#Что-такое-полиморфизм)
+ [Что такое _«абстракция»_?](#Что-такое-абстракция)
+ [Что представляет собой _«обмен сообщениями»_?](#Что-представляет-собой-обмен-сообщениями)
+ [Расскажите про основные понятия ООП: _«класс»_, _«объект»_, _«интерфейс»_.](#Расскажите-про-основные-понятия-ООП-класс-объект-интерфейс)
+ [В чем заключаются преимущества и недостатки объектно-ориентированного подхода в программировании?](#В-чем-заключаются-преимущества-и-недостатки-объектно-ориентированного-подхода-в-программировании)
+ [Что подразумевают в плане принципов ООП выражения _«является»_ и _«имеет»_?](#Что-подразумевают-в-плане-принципов-ООП-выражения-является-и-имеет)
+ [В чем разница между _композицией_ и _агрегацией_?](#В-чем-разница-между-композицией-и-агрегацией)
+ [Что такое _статическое_ и _динамическое связывание_?](#Что-такое-статическое-и-динамическое-связывание)
+ [Что такое SOLID?](SOLID.md)
+ [Что такое REST?](#Что-такое-REST)

## Что такое _ООП_?

https://habr.com/ru/articles/463125/

__Объектно-ориентированное программирование (ООП)__ — методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования. 

+ объектно-ориентированное программирование использует в качестве основных логических конструктивных элементов объекты, а не алгоритмы;
+ каждый объект является экземпляром определенного класса 
+ классы образуют иерархии. 

Программа считается объектно-ориентированной, только если выполнены все три указанных требования. В частности, программирование, не использующее наследование, называется не объектно-ориентированным, а программированием с помощью абстрактных типов данных.

Согласно парадигме ООП программа состоит из объектов, обменивающихся сообщениями. Объекты могут обладать состоянием, единственный способ изменить состояние объекта - послать ему сообщение, в ответ на которое, объект может изменить собственное состояние. 

[к оглавлению](#ООП)

## Назовите основные принципы _ООП_.
+ _Инкапсуляция_ - сокрытие реализации.
+ _Наследование_ - создание новой сущности на базе уже существующей.
+ _Полиморфизм_ - возможность иметь разные формы для одной и той же сущности.
+ _Абстракция_ - набор общих характеристик.
+ _Посылка сообщений_ - форма связи, взаимодействия между сущностями.
+ _Переиспользование_- все что перечислено выше работает на повторное использование кода.

Это единственно верный порядок парадигм ООП, так как каждая последующая использует предыдущие.

[к оглавлению](#ООП)

## Что такое _«инкапсуляция»_?
__Инкапсуляция__ – это свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе и скрыть детали реализации от пользователя, открыв только то, что необходимо при последующем использовании.

Цель инкапсуляции — уйти от зависимости внешнего интерфейса класса (то, что могут использовать другие классы) от реализации. Чтобы малейшее изменение в классе не влекло за собой изменение внешнего поведения класса.

>Представим на минутку, что мы оказались в конце позапрошлого века, когда Генри Форд ещё не придумал конвейер, а первые попытки создать автомобиль сталкивались с критикой властей по поводу того, что эти коптящие монстры загрязняют воздух и пугают лошадей. Представим, что для управления первым паровым автомобилем необходимо было знать, как устроен паровой котёл, постоянно подбрасывать уголь, следить за температурой, уровнем воды. При этом для поворота колёс использовать два рычага, каждый из которых поворачивает одно колесо в отдельности. Думаю, можно согласиться с тем, что вождение автомобиля того времени было весьма неудобным и трудным занятием.

>Теперь вернёмся в сегодняшний день к современным чудесам автопрома с коробкой-автоматом. На самом деле, по сути, ничего не изменилось. Бензонасос всё так же поставляет бензин в двигатель, дифференциалы обеспечивают поворот колёс на различающиеся углы, коленвал превращает поступательное движение поршня во вращательное движение колёс. Прогресс в другом. Сейчас все эти действия скрыты от пользователя и позволяют ему крутить руль и нажимать на педаль газа, не задумываясь, что в это время происходит с инжектором, дроссельной заслонкой и распредвалом. Именно сокрытие внутренних процессов, происходящих в автомобиле, позволяет эффективно его использовать даже тем, кто не является профессионалом-автомехаником с двадцатилетним стажем. Это сокрытие в ООП носит название инкапсуляции.

Пример:
```java
public class SomePhone {

    private int year;
    private String company;
    public SomePhone(int year, String company) {
        this.year = year;
        this.company = company;
    }
    private void openConnection(){
        //findComutator
        //openNewConnection...
    }
    public void call() {
        openConnection();
        System.out.println("Вызываю номер");
    }

    public void ring() {
        System.out.println("Дзынь-дзынь");
    }

}
```
Модификатор private делает доступными поля и методы класса только внутри данного класса. Это означает, что получить доступ к private полям из вне невозможно, как и нет возможности вызвать private методы.

Сокрытие доступа к методу openConnection, оставляет нам также возможность к свободному изменению внутренней реализации этого метода, так как этот метод гарантированно не используется другими объектами и не нарушит их работу.

Для работы с нашим объектом мы оставляем открытыми методы call и ring с помощью модификатора public. Предоставление открытых методов для работы с объектом также является частью механизма инкапсуляции, так как если полностью закрыть доступ к объекту – он станет бесполезным.

Пример инкапсуляции в жизни можно найти в использовании банковских счетов. Рассмотрим пример банковского счета:

У банковского счета есть некоторые данные, такие как баланс и номер счета. Кроме того, у него есть операции, такие как внесение денег, снятие денег и проверка баланса. Давайте рассмотрим пример инкапсуляции банковского счета:

```java
public class BankAccount {
    private String accountNumber;
    private double balance;
    
    public BankAccount(String accountNumber) {
        this.accountNumber = accountNumber;
        this.balance = 0.0;
    }
    
    public String getAccountNumber() {
        return accountNumber;
    }
    
    public double getBalance() {
        return balance;
    }
    
    public void deposit(double amount) {
        if (amount > 0) {
            balance += amount;
            System.out.println(amount + " долларов внесено на счет " + accountNumber);
        } else {
            System.out.println("Неверная сумма для внесения");
        }
    }
    
    public void withdraw(double amount) {
        if (amount > 0 && amount <= balance) {
            balance -= amount;
            System.out.println(amount + " долларов снято со счета " + accountNumber);
        } else {
            System.out.println("Недостаточно средств на счете");
        }
    }
}
```

В этом примере класс `BankAccount` инкапсулирует данные о банковском счете, такие как номер счета и баланс. Поля `accountNumber` и `balance` объявлены как `private`, что означает, что они доступны только внутри класса `BankAccount`.

Для доступа к этим полям извне класса `BankAccount` используются публичные методы `getAccountNumber()` и `getBalance()`. Эти методы предоставляют только чтение данных о счете.

Кроме того, класс `BankAccount` предоставляет методы `deposit()` и `withdraw()`, которые позволяют вносить и снимать деньги со счета соответственно. При этом эти методы проверяют валидность операций и обновляют баланс счета.

Таким образом, инкапсуляция в этом примере позволяет контролировать доступ к данным банковского счета и обеспечивает безопасность операций с ним. Внешний код не может напрямую изменять баланс или номер счета, а может только использовать публичные методы для получения информации о счете или выполнения операций с ним. Это помогает предотвратить неправильное использование данных и обеспечивает безопасность банковского счета.

Вы правильно заметили, что внешний код может изменить баланс счета, используя соответствующие методы, предоставленные классом `BankAccount`. Однако, важно отметить, что безопасность банковского счета обеспечивается не путем полного предотвращения доступа к изменению счета, а через контролируемый и безопасный способ его изменения.

Класс `BankAccount` может включать дополнительные механизмы безопасности для обеспечения целостности и консистентности данных. Например, он может использовать проверки и ограничения в методах `deposit()` и `withdraw()`, чтобы гарантировать, что операции происходят только с правильными значениями и в правильном контексте.

Кроме того, класс `BankAccount` может использовать приватные переменные и методы для внутренней логики и обработки данных. Это означает, что внешний код не имеет прямого доступа к этим приватным элементам и не может изменять их напрямую. Вместо этого, внешний код может взаимодействовать только с публичными методами, которые обеспечивают контролируемый доступ к изменению счета.

Например, методы `deposit()` и `withdraw()` могут содержать проверки на валидность суммы операции и доступность средств на счете. Это помогает предотвратить некорректные операции, такие как внесение отрицательной суммы или снятие больше денег, чем есть на счете.

Также, класс `BankAccount` может использовать другие механизмы безопасности, такие как аутентификация и авторизация, для контроля доступа к операциям счета. Например, он может требовать аутентификации пользователя перед выполнением операций, чтобы убедиться, что только правильные пользователи могут изменять счет.

Все эти меры безопасности вместе помогают обеспечить безопасность банковского счета, минимизировать возможность ошибок и злоупотреблений, и обеспечить конфиденциальность и целостность данных. Однако, важно отметить, что безопасность банковского счета - это комплексный процесс, который включает не только сам класс `BankAccount`, но и другие аспекты, такие как защита данных и сетевая безопасность.

[к оглавлению](#ООП)

## Что такое _«наследование»_?
__Наследование__ – это свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью.

Класс, от которого производится наследование, называется _предком_, _базовым_ или _родительским_. Новый класс – _потомком_, _наследником_ или _производным_ классом.

>Представим себя, на минуту, инженерами автомобильного завода. Нашей задачей является разработка современного автомобиля. У нас уже есть предыдущая модель, которая отлично зарекомендовала себя в течение многолетнего использования. Всё бы хорошо, но времена и технологии меняются, а наш современный завод должен стремиться повышать удобство и комфорт выпускаемой продукции и соответствовать современным стандартам.

>Нам необходимо выпустить целый модельный ряд автомобилей: седан, универсал и малолитражный хэтч-бэк. Очевидно, что мы не собираемся проектировать новый автомобиль с нуля, а, взяв за основу предыдущее поколение, внесём ряд конструктивных изменений. Например, добавим гидроусилитель руля и уменьшим зазоры между крыльями и крышкой капота, поставим противотуманные фонари. Кроме того, в каждой модели будет изменена форма кузова.

>Очевидно, что все три модификации будут иметь большинство свойств прежней модели (старый добрый двигатель 1970 года, непробиваемая ходовая часть, зарекомендовавшая себя отличным образом на отечественных дорогах, коробку передач и т.д.). При этом каждая из моделей будет реализовать некоторую новую функциональность или конструктивную особенность. В данном случае, мы имеем дело с наследованием.

Пример:
Рассмотрим пример создания класса смартфон с помощью наследования. Все беспроводные телефоны работают от аккумуляторных батарей, которые имеют определенный ресурс работы в часах. Поэтому добавим это свойство в класс беспроводных телефонов:
```java
public abstract class WirelessPhone extends AbstractPhone {

    private int hour;

    public WirelessPhone(int year, int hour) {
        super(year);
        this.hour = hour;
    }
}
```
Сотовые телефоны наследуют свойства беспроводного телефона, мы также добавили в этот класс реализацию методов call и ring:
```java
public class CellPhone extends WirelessPhone {
    public CellPhone(int year, int hour) {
        super(year, hour);
    }

    @Override
    public void call(int outputNumber) {
        System.out.println("Вызываю номер " + outputNumber);
    }

    @Override
    public void ring(int inputNumber) {
        System.out.println("Вам звонит абонент " + inputNumber);
    }
}
```
И, наконец, класс смартфон, который в отличие от классических сотовых телефонов имеет полноценную операционную систему. В смартфон можно добавлять новые программы, поддерживаемые данной операционной системой, расширяя, таким образом, его функциональность. С помощью кода класс можно описать так:
```java
public class Smartphone extends CellPhone {

    private String operationSystem;

    public Smartphone(int year, int hour, String operationSystem) {
        super(year, hour);
        this.operationSystem = operationSystem;
    }
    
    public void install(String program){
        System.out.println("Устанавливаю " + program + "для" + operationSystem);
    }

}
```
Как видите, для описания класса Smartphone мы создали совсем немного нового кода, но получили новый класс с новой функциональностью. Использование этого принципа ООП java позволяет значительно уменьшить объем кода, а значит, и облегчить работу программисту.

Конечно, вот еще один пример наследования в Java:

```java
// Родительский класс
class Animal {
    private String name;

    public Animal(String name) {
        this.name = name;
    }

    public void eat() {
        System.out.println(name + " is eating.");
    }

    public void sleep() {
        System.out.println(name + " is sleeping.");
    }
}

// Дочерний класс, наследующий от Animal
class Dog extends Animal {
    public Dog(String name) {
        super(name);
    }

    public void bark() {
        System.out.println("Dog is barking.");
    }
}

// Пример использования классов
public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog("Buddy");
        dog.eat();
        dog.sleep();
        dog.bark();
    }
}
```

В этом примере класс `Dog` наследуется от класса `Animal`. Класс `Animal` является родительским классом, а класс `Dog` - дочерним классом. Дочерний класс наследует свойство `name` и методы `eat()` и `sleep()` от родительского класса `Animal`. Дочерний класс также добавляет свой собственный метод `bark()`, который отражает поведение собаки.

В методе `main()` создается объект класса `Dog` с именем "Buddy". Затем вызываются методы `eat()`, `sleep()` и `bark()`, которые принадлежат как родительскому классу `Animal`, так и дочернему классу `Dog`.

[к оглавлению](#ООП)

## Что такое _«полиморфизм»_?
__Полиморфизм__ – это свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.

Преимуществом полиморфизма является то, что он помогает снижать сложность программ, разрешая использование одного и того же интерфейса для задания единого набора действий. Выбор же конкретного действия, в зависимости от ситуации, возлагается на компилятор языка программирования. Отсюда следует ключевая особенность полиморфизма - использование объекта производного класса, вместо объекта базового (потомки могут изменять родительское поведение, даже если обращение к ним будет производиться по ссылке родительского типа).

>Любое обучение вождению не имело бы смысла, если бы человек, научившийся водить, скажем, ВАЗ 2106 не мог потом водить ВАЗ 2110 или BMW X3. С другой стороны, трудно представить человека, который смог бы нормально управлять автомобилем, в котором педаль газа находится левее педали тормоза, а вместо руля – джойстик. 

>Всё дело в том, что основные элементы управления автомобиля имеют одну и ту же конструкцию, и принцип действия. Водитель точно знает, что для того, чтобы повернуть налево, он должен повернуть руль, независимо от того, есть там гидроусилитель или нет. 
Если человеку надо доехать с работы до дома, то он сядет за руль автомобиля и будет выполнять одни и те же действия, независимо от того, какой именно тип автомобиля он использует. По сути, можно сказать, что все автомобили имеют один и тот же интерфейс, а водитель, абстрагируясь от сущности автомобиля, работает именно с этим интерфейсом. Если водителю предстоит ехать по немецкому автобану, он, вероятно выберет быстрый автомобиль с низкой посадкой, а если предстоит возвращаться из отдалённого маральника в Горном Алтае после дождя, скорее всего, будет выбран УАЗ с армейскими мостами. Но, независимо от того, каким образом будет реализовываться движение и внутреннее функционирование машины, интерфейс останется прежним.

_Полиморфная переменная_, это переменная, которая может принимать значения разных типов, а _полиморфная функция_, это функция, у которой хотя бы один аргумент является полиморфной переменной.
Выделяют два вида полиморфных функций:

+ _ad hoc_, функция ведет себя по разному для разных типов аргументов (например, функция `draw()` — рисует по разному фигуры разных типов);
+ _параметрический_, функция ведет себя одинаково для аргументов разных типов (например, функция `add()` — одинаково кладет в контейнер элементы разных типов).

Принцип в ООП, когда программа может использовать объекты с одинаковым интерфейсом без информации о внутреннем устройстве объекта, называется полиморфизмом. 

Пример:

Давайте представим, что нам в программе нужно описать пользователя, который может пользоваться любыми моделями телефона, чтобы позвонить другому пользователю. Вот как можно это сделать:

```java
public class User {
    private String name;

    public User(String name) {
        this.name = name;
    }

    public void callAnotherUser(int number, AbstractPhone phone) {
// вот он полиморфизм - использование в коде абстактного типа AbstractPhone phone!
        phone.call(number);
    }
}
```

Теперь опишем различные модели телефонов. Одна из первых моделей телефонов:
```java
public class ThomasEdisonPhone extends AbstractPhone {

    public ThomasEdisonPhone(int year) {
        super(year);
    }

    @Override
    public void call(int outputNumber) {
        System.out.println("Вращайте ручку");
        System.out.println("Сообщите номер абонента, сэр");
    }

    @Override
    public void ring(int inputNumber) {
        System.out.println("Телефон звонит");
    }
}
```

Обычный стационарный телефон:

```java
public class Phone extends AbstractPhone {

    public Phone(int year) {
        super(year);
    }

    @Override
    public void call(int outputNumber) {
        System.out.println("Вызываю номер" + outputNumber);
    }

    @Override
    public void ring(int inputNumber) {
        System.out.println("Телефон звонит");
    }
}
```

И, наконец, крутой видеотелефон:

```java
public class VideoPhone extends AbstractPhone {

    public VideoPhone(int year) {
        super(year);
    }

    @Override
    public void call(int outputNumber) {
        System.out.println("Подключаю видеоканал для абонента " + outputNumber);
    }

    @Override
    public void ring(int inputNumber) {
        System.out.println("У вас входящий видеовызов..." + inputNumber);
    }
}
```

Создадим объекты в методе main() и протестируем метод callAnotherUser:

```java
AbstractPhone firstPhone = new ThomasEdisonPhone(1879);
AbstractPhone phone = new Phone(1984);
AbstractPhone videoPhone=new VideoPhone(2018);
User user = new User("Андрей");
user.callAnotherUser(224466,firstPhone);
// Вращайте ручку
//Сообщите номер абонента, сэр
user.callAnotherUser(224466,phone);
//Вызываю номер 224466
user.callAnotherUser(224466,videoPhone);
//Подключаю видеоканал для абонента 224466
```

Используя вызов одного и того же метода объекта user, мы получили различные результаты. Выбор конкретной реализации метода call внутри метода callAnotherUser производился динамически на основании конкретного типа вызывающего его объекта в процессе выполнения программы. В этом и заключается основное преимущество полиморфизма – выбор реализации в процессе выполнения программы.

В примерах классов телефонов, приведенных выше, мы использовали переопределение методов – прием, при котором изменяется реализация метода, определенная в базовом классе, без изменения сигнатуры метода. По сути, это является заменой метода, и именно новый метод, определенный в подклассе, вызывается при выполнении программы. 

Обычно, при переопределении метода, используется аннотация @Override, которая подсказывает компилятору о необходимости проверить сигнатуры переопределяемого и переопределяющего методов.

[к оглавлению](#ООП)

## Что такое _«абстракция»_?
_Абстрагирование_ – это способ выделить набор общих характеристик объекта, исключая из рассмотрения частные и незначимые. Соответственно, __абстракция__ – это набор всех таких характеристик.

>Представьте, что водитель едет в автомобиле по оживлённому участку движения. Понятно, что в этот момент он не будет задумываться о химическом составе краски автомобиля, особенностях взаимодействия шестерёнок в коробке передач или влияния формы кузова на скорость (разве что, автомобиль стоит в глухой пробке и водителю абсолютно нечем заняться). Однако, руль, педали, указатель поворота он будет использовать регулярно.

Пример:
```java
// Abstract class
abstract class Animal {
    // Abstract method (does not have a body)
    public abstract void animalSound();

    // Regular method
    public void sleep() {
        System.out.println("Zzz");
    }
}

// Subclass (inherit from Animal)
class Pig extends Animal {
    public void animalSound() {
        // The body of animalSound() is provided here
        System.out.println("The pig says: wee wee");
    }
}

class MyMainClass {
    public static void main(String[] args) {
        Pig myPig = new Pig(); // Create a Pig object
        myPig.animalSound();
        myPig.sleep();
    }
}
```

[к оглавлению](#ООП)

## Что представляет собой _«обмен сообщениями»_?
Объекты взаимодействуют, посылая и получая сообщения. Сообщение — это запрос на выполнение действия, дополненный набором аргументов, которые могут понадобиться при выполнении действия. В ООП посылка сообщения (вызов метода) — это единственный путь передать управление объекту. Если объект должен «отвечать» на это сообщение, то у него должна иметься соответствующий данному сообщению метод. Так же объекты, используя свои методы, могут и сами посылать сообщения другим объектам. Обмен сообщениями реализуется с помощью динамических вызовов, что приводит к чрезвычайно позднему связыванию (extreme late binding).

>Пусть требуется создать физическую модель, описывающую сталкивающиеся шары разных размеров. Традиционный подход к решению этой задачи примерно таков: определяется набор данных, описывающих каждый шар (например, его координаты, массу и ускорение); каждому шару присваивается уникальный идентификатор (например, организуется массив, значение индекса которого соответствует номеру шара), который позволит отличать каждый из шаров от всех других. Наконец, пишется подпрограмма с названием, скажем, `bounce`; эта процедура должна на основе номера шара и его начальных параметров соответствующим образом изменять данные, описывающие шар. В отличие от традиционного подхода объектно-ориентированная версия программы моделирует каждый из шаров посредством объекта. При этом объект, соответствующий конкретному шару, содержит не только его параметры, но и весь код, описывающий поведение шара при различных взаимодействиях. Так, каждый шар будет иметь собственный метод `bounce()`. Вместо того, чтобы вызывать подпрограмму `bounce` с аргументом, определяющим, скажем, шар №3, необходимо будет передать объекту «шар №3» сообщение, предписывающее ему выполнить столкновение.

В Java "обмен сообщениями" обычно относится к механизму взаимодействия между объектами, основанному на передаче и обработке сообщений. Объекты взаимодействуют друг с другом, отправляя сообщения и получая ответы на них.

В Java обмен сообщениями может быть реализован с помощью различных механизмов, включая:

1. Методы вызова: Объект может вызывать методы другого объекта, передавая ему параметры и ожидая результата. Это наиболее распространенный способ обмена сообщениями в Java.

2. Интерфейсы: Интерфейсы могут быть использованы для определения контракта между объектами. Объекты могут реализовывать интерфейсы и взаимодействовать друг с другом, вызывая методы, определенные в интерфейсе.

3. Обратные вызовы (Callback): Обратные вызовы позволяют объекту передать ссылку на себя другому объекту, чтобы последний мог вызвать определенный метод обратного вызова при наступлении определенного события.

4. Событийно-ориентированное программирование (Event-driven programming): В Java можно использовать механизмы событий и слушателей для обмена сообщениями. Объект может генерировать событие, а другие объекты могут регистрироваться в качестве слушателей и реагировать на это событие.

5. Паттерн наблюдатель (Observer pattern): Этот паттерн позволяет объектам быть наблюдателями за изменениями в других объектах. Когда состояние наблюдаемого объекта изменяется, он уведомляет своих наблюдателей, отправляя им сообщение.

Все эти механизмы позволяют объектам взаимодействовать друг с другом, передавая сообщения и обрабатывая их. "Обмен сообщениями" в Java является основой для создания сложных систем из множества взаимодействующих объектов.

В контексте обмена сообщениями в Java, "сообщение" представляет собой данные или запрос, которые отправляются от одного объекта к другому. Сообщение может содержать информацию, которую отправляющий объект хочет передать получающему объекту, или запрос на выполнение определенного действия.

Сообщение может быть представлено различными способами в зависимости от выбранного механизма обмена сообщениями. Например:

- В случае вызова методов, сообщение представляет собой вызов определенного метода с передачей аргументов.
- При использовании интерфейсов, сообщение может быть вызовом метода, определенного в интерфейсе.
- В механизме обратных вызовов (Callback), сообщение может содержать ссылку на метод обратного вызова, который будет вызван в определенный момент.
- В событийно-ориентированном программировании, сообщение может быть событием, которое генерируется и передается другим объектам.
- В паттерне наблюдателя (Observer pattern), сообщение может быть уведомлением о изменении состояния наблюдаемого объекта.

В общем случае, сообщение представляет собой способ передачи информации или запроса между объектами, чтобы они могли взаимодействовать и выполнять необходимые действия.

[к оглавлению](#ООП)

## Расскажите про основные понятия ООП: _«класс»_, _«объект»_, _«интерфейс»_.
__Класс__ – это способ описания сущности, определяющий состояние и поведение, зависящее от этого состояния, а также правила для взаимодействия с данной сущностью (контракт). 

Правила, о которых идет речь, относятся к контракту или спецификации класса. Они определяют ожидаемое поведение объектов этого класса и правила взаимодействия с ними. Контракт класса включает в себя следующие аспекты:

1. Публичные методы: Класс определяет публичные методы, которые могут быть вызваны другими объектами для выполнения определенных операций. Правила контракта описывают, какие параметры ожидаются методами, какие значения возвращаются и какие побочные эффекты могут произойти.

2. Инварианты и предусловия: Класс может определять инварианты, которые должны быть истинными для объектов этого класса в любой момент времени. Инварианты являются условиями, которые должны быть выполнены для корректного состояния объекта. Класс также может определять предусловия для своих методов, которые описывают условия, которые должны быть истинными перед вызовом метода.

3. Постусловия: Класс может определять постусловия для своих методов, которые описывают условия, которые должны быть выполнены после выполнения метода. Постусловия могут описывать изменения состояния объекта или другие гарантии, которые должны быть истинными после выполнения метода.

4. Исключения: Класс может определять исключения, которые могут быть выброшены методами в определенных ситуациях. Правила контракта могут указывать, в каких случаях исключения могут быть выброшены и какие исключения ожидаются.

Правила контракта класса помогают определить ожидаемое поведение объектов этого класса и обеспечить их корректное использование. Они служат основой для взаимодействия с объектами класса и позволяют программистам использовать класс согласно его намерению и спецификации.

С точки зрения программирования класс можно рассматривать как набор данных (полей, атрибутов, членов класса) и функций для работы с ними (методов).

С точки зрения структуры программы, класс является сложным типом данных.

В Java класс представляет собой основную структурную единицу программы. Класс определяет состояние и поведение объектов, которые создаются на его основе.

В классе объявляются поля (переменные), методы (функции) и конструкторы. Поля описывают состояние объекта, методы определяют его поведение, а конструкторы служат для создания новых экземпляров (объектов) класса.

Классы могут быть упорядочены в иерархию с помощью наследования, где один класс называется суперклассом, а другие классы, которые наследуют его свойства и методы, называются подклассами или производными классами.

__Объект (экземпляр)__ – это отдельный представитель класса, имеющий конкретное состояние и поведение, полностью определяемое классом. Каждый объект имеет конкретные значения атрибутов и методы, работающие с этими значениями на основе правил, заданных в классе.

__Интерфейс__ – это набор методов класса, доступных для использования. Интерфейсом класса будет являться набор всех его публичных методов в совокупности с набором публичных атрибутов. По сути, интерфейс специфицирует класс, чётко определяя все возможные действия над ним. 

Интерфейс – это ссылочный, абстрактный тип в Java. Он схож с классом. Это совокупность абстрактных методов.

Так вот интерфейс очень смахивает на абстрактный класс, но является не классом, а просто пустышкой с перечислением абстрактных методов (без имплементации). Другими словами, интерфейс имеет декларативную природу, то есть, чистый контракт без капельки кода.

В Java интерфейс - это контракт, который определяет набор методов (или сигнатур методов), которые классы должны реализовать. Он служит для определения общего поведения, которое должны иметь классы, реализующие данный интерфейс.

Интерфейс в Java определяет только сигнатуры методов, то есть их имена, параметры и возвращаемые значения, но не содержит реализацию этих методов. Классы, которые реализуют интерфейс, обязаны предоставить реализацию всех методов, определенных в интерфейсе.

[к оглавлению](#ООП)

## В чем заключаются преимущества и недостатки объектно-ориентированного подхода в программировании?
Объектно-ориентированный подход (ООП) в программировании предлагает ряд преимуществ, но также имеет и некоторые недостатки. Ниже приведены основные преимущества и недостатки ООП.

Преимущества объектно-ориентированного подхода:

1. Модульность и повторное использование кода: ООП позволяет разбить программу на независимые модули (классы), которые могут быть повторно использованы в других частях программы или в других проектах. Это упрощает разработку, поддержку и расширение программного обеспечения.

2. Инкапсуляция и скрытие данных: ООП позволяет объединить данные и методы, работающие с этими данными, в единый объект. Это позволяет скрыть детали реализации и предоставить только необходимый интерфейс для работы с объектом. Инкапсуляция способствует безопасности и защите данных.

3. Наследование: ООП поддерживает механизм наследования, который позволяет создавать иерархии классов. Это позволяет наследующим классам наследовать свойства и методы базовых классов, что способствует повторному использованию кода и упрощает разработку.

4. Полиморфизм: ООП поддерживает полиморфизм, что означает, что объекты одного класса могут иметь разные формы и могут быть использованы вместо объектов других классов. Это позволяет писать более гибкий и расширяемый код.

Недостатки объектно-ориентированного подхода:

1. Сложность: ООП может быть сложным для начинающих программистов, так как требует понимания концепций, таких как классы, объекты, наследование и полиморфизм. Некорректное применение ООП может привести к проблемам производительности и сложности в поддержке кода.

2. Избыточность: Иногда объектно-ориентированный код может быть более громоздким и требовать больше памяти и вычислительных ресурсов, чем эквивалентный процедурный код. Это может быть проблемой в некоторых ограниченных средах или на устройствах с ограниченными ресурсами.

3. Производительность: В некоторых случаях объектно-ориентированный код может быть менее эффективным с точки зрения производительности, чем эквивалентный процедурный код. Возникают накладные расходы на создание и управление объектами, а также на вызовы методов через виртуальные таблицы.

4. Проблемы проектирования: Некорректное проектирование объектно-ориентированной системы может привести к проблемам, таким как чрезмерная связность между классами, сложность иерархий наследования или проблемы с расширяемостью и поддержкой.

В целом, объектно-ориентированный подход имеет множество преимуществ, которые делают его популярным в разработке программного обеспечения. Однако он также имеет свои недостатки, и его применение должно быть осознанным и соответствовать требованиям конкретной задачи или проекта.

Преимущества:

+ Объектная модель вполне естественна, поскольку в первую очередь ориентирована на человеческое восприятие мира, а не на компьютерную реализацию.
+ Классы позволяют проводить конструирование из полезных компонентов, обладающих простыми инструментами, что позволяет абстрагироваться от деталей реализации.
+ Данные и операции над ними образуют определенную сущность, и они не разносятся по всей программе, как нередко бывает в случае процедурного программирования, а описываются вместе. Локализация кода и данных улучшает наглядность и удобство сопровождения программного обеспечения.
+ Инкапсуляция позволяет привнести свойство модульности, что облегчает распараллеливание выполнения задачи между несколькими исполнителями и обновление версий отдельных компонентов.
+ Возможность создавать расширяемые системы.
+ Использование полиморфизма оказывается полезным при:
    + Обработке разнородных структур данных. Программы могут работать, не различая вида объектов, что существенно упрощает код. Новые виды могут быть добавлены в любой момент.
    + Изменении поведения во время исполнения. На этапе исполнения один объект может быть заменен другим, что позволяет легко, без изменения кода, адаптировать алгоритм в зависимости от того, какой используется объект.
    + Реализации работы с наследниками. Алгоритмы можно обобщить настолько, что они уже смогут работать более чем с одним видом объектов.
    + Возможности описать независимые от приложения части предметной области в виде набора универсальных классов, или фреймворка, который в дальнейшем будет расширен за счет добавления частей, специфичных для конкретного приложения.
+ Повторное использование кода:
    + Сокращается время на разработку, которое может быть отдано другим задачам.
    + Компоненты многоразового использования обычно содержат гораздо меньше ошибок, чем вновь разработанные, ведь они уже не раз подвергались проверке.
    + Когда некий компонент используется сразу несколькими клиентами, улучшения, вносимые в его код, одновременно оказывают положительное влияние и на множество работающих с ним программ.
    + Если программа опирается на стандартные компоненты, ее структура и пользовательский интерфейс становятся более унифицированными, что облегчает ее понимание и упрощает использование.

Недостатки:

+ В сложных иерархиях классов поля и методы обычно наследуются с разных уровней. И не всегда легко определить, какие поля и методы фактически относятся к данному классу.
+ Код для обработки сообщения иногда «размазан» по многим методам (иначе говоря, обработка сообщения требует не одного, а многих методов, которые могут быть описаны в разных классах).
+ Документирование классов - задача более трудная, чем это было в случае процедур и модулей. Поскольку любой метод может быть переопределен, в документации должно говориться не только о том, что делает данный метод, но и о том, в каком контексте он вызывается.
+ Неэффективность и неэкономное распределения памяти на этапе выполнения (по причине издержек на динамическое связывание и проверки типов на этапе выполнения).
+ Излишняя универсальность. Часто содержится больше методов, чем это реально необходимо текущей программе. А поскольку лишние методы не могут быть удалены, они становятся мертвым грузом.

[к оглавлению](#ООП)

## Что подразумевают в плане принципов ООП выражения _«является»_ и _«имеет»_?
__«является»__ подразумевает наследование.
__«имеет»__ подразумевает ассоциацию (агрегацию или композицию).

[к оглавлению](#ООП)

## В чем разница между _композицией_ и _агрегацией_?

Ассоциация обозначает связь между объектами. Композиция и агрегация — частные случаи ассоциации «часть-целое».

В Java ассоциация - это отношение между двумя классами, которое позволяет одному классу использовать функциональность или иметь доступ к данным другого класса. Ассоциация может быть однонаправленной или двунаправленной.

Однонаправленная ассоциация означает, что один класс использует функциональность или имеет доступ к данным другого класса, но не наоборот. Например, класс "Студент" может иметь ассоциацию с классом "Университет", где студент использует функциональность университета, такую как получение информации о курсах или библиотечных ресурсах.

Двунаправленная ассоциация означает, что два класса взаимодействуют друг с другом и имеют доступ к функциональности и данным друг друга. Например, класс "Заказ" и класс "Клиент" могут иметь двунаправленную ассоциацию, где заказ имеет доступ к информации о клиенте, а клиент имеет доступ к информации о заказе.

Ассоциация может быть реализована с помощью полей-ссылок, методов или параметров методов. Например, в однонаправленной ассоциации класс "Студент" может иметь поле-ссылку на объект класса "Университет", чтобы получить доступ к его функциональности. В двунаправленной ассоциации оба класса могут иметь поля-ссылки друг на друга.

Ассоциация является одним из основных понятий объектно-ориентированного программирования и позволяет создавать более гибкую и модульную структуру программы, где классы могут сотрудничать и обмениваться информацией.

Агрегация предполагает, что объекты связаны взаимоотношением «part-of» (часть). Композиция более строгий вариант агрегации. Дополнительно к требованию «part-of» накладывается условие, что экземпляр «части» может входить только в одно целое (или никуда не входить), в то время как в случае агрегации экземпляр «части» может входить в несколько целых.

>Например, книга состоит из страниц, и мы не можем вырвать страницу из книги и вложить в другую книгу. Страницы четко привязаны к конкретной книге, поэтому это композиция.
В тоже время мы можем взять и перенести книгу из одной библиотеки в другую - это уже агрегация.

[к оглавлению](#ООП)

## Что такое _статическое_ и _динамическое связывание_?
В Java связывание (binding) - это процесс определения, какой код будет выполнен в ответ на вызов метода или доступ к полю во время выполнения программы. Связывание определяет, какой метод или поле будет связано с вызываемым выражением.

Существует два типа связывания в Java:

1. Статическое связывание (static binding): Происходит во время компиляции и определяется на основе типа переменной или вызываемого метода в момент компиляции. Компилятор выбирает соответствующий метод или поле, и связывание остается неизменным во время выполнения программы. Статическое связывание применяется к `private` методам и полям, а также к `final` методам и полям.

2. Динамическое связывание (dynamic binding): Происходит во время выполнения программы и определяется на основе фактического типа объекта, на котором вызывается метод или к которому обращается поле. Динамическое связывание применяется к методам и полям, которые не являются `private` или `final`, а также к полиморфным методам, которые переопределены в подклассах.

Динамическое связывание позволяет достичь полиморфизма в Java, что означает, что один и тот же метод может иметь различное поведение в зависимости от типа объекта, на котором он вызывается.

Например, предположим, у нас есть классы `Animal` и `Cat`, где `Cat` является подклассом `Animal` и переопределяет метод `makeSound()`:

```java
class Animal {
    public void makeSound() {
        System.out.println("Animal makes a sound");
    }
}

class Cat extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Cat meows");
    }
}
```

Если мы создадим объект типа `Animal` и вызовем метод `makeSound()`, будет использоваться динамическое связывание, и будет вызван метод `makeSound()` из класса `Cat`, так как фактический тип объекта - `Cat`:

```java
Animal animal = new Cat();
animal.makeSound(); // Вывод: "Cat meows"
```

В этом примере метод `makeSound()` в классе `Cat` переопределяет метод с тем же именем в классе `Animal`, и во время выполнения программы будет выбран правильный метод на основе фактического типа объекта. Это динамическое связывание.

В Java `final` поля и методы статически связываются. Это означает, что связывание (binding) происходит во время компиляции и определяется на основе типа переменной или вызываемого метода в момент компиляции, а не во время выполнения программы.

Когда поле или метод объявлены с ключевым словом `final`, это означает, что они не могут быть переопределены или изменены в подклассах (для методов) или в других местах программы (для полей). Это свойство `final` гарантирует, что поле или метод будут использоваться согласно своему определению в компилируемом классе, и компилятор может принять оптимизации, основанные на этом знании.

Например, если у нас есть класс `Parent` с `final` методом:

```java
class Parent {
    public final void doSomething() {
        // Реализация метода
    }
}
```

И класс `Child`, который наследует от `Parent`:

```java
class Child extends Parent {
    // Нельзя переопределить final метод
}
```

В этом случае, компилятор статически свяжет вызов `doSomething()` с реализацией метода в классе `Parent`. Если бы `doSomething()` не был объявлен как `final`, то класс `Child` мог бы переопределить этот метод.

То же самое относится и к `final` полям. Они связываются статически и не могут быть изменены после инициализации.

Таким образом, использование ключевого слова `final` обеспечивает статическое связывание для полей и методов, что имеет преимущества в производительности и безопасности, так как компилятор может принимать оптимизации на основе этой информации.

Да, то же самое относится и к `private` полям и методам. В Java `private` поля и методы также связываются статически. 

Ключевое слово `private` указывает, что поле или метод доступны только внутри того же класса, в котором они объявлены. Они не могут быть доступны или переопределены в других классах или подклассах.

Когда `private` метод вызывается внутри класса, компилятор статически связывает этот вызов с соответствующей реализацией метода в том же классе. Это позволяет компилятору принять оптимизации и гарантирует, что вызываемый метод будет тем, который определен в классе.

Аналогично, `private` поле статически связывается с использованием его определения в том же классе, где оно объявлено. Это позволяет компилятору принять оптимизации на основе этой информации.

Таким образом, `private` поля и методы также связываются статически, что означает, что связывание происходит во время компиляции и определяется на основе типа переменной или вызываемого метода в момент компиляции, а не во время выполнения программы.

Присоединение вызова метода к телу метода называется связыванием. Если связывание проводится компилятором (компоновщиком) перед запуском программы, то оно называется _статическим_ или _ранним связыванием (early binding)_.

В свою очередь, _позднее связывание (late binding)_ это связывание, проводимое непосредственно во время выполнения программы, в зависимости от типа объекта. Позднее связывание также называют _динамическим (dynamic)_ или _связыванием на стадии выполнения (runtime binding)_. В языках, реализующих позднее связывание, должен существовать механизм определения фактического типа объекта во время работы программы, для вызова подходящего метода. Иначе говоря, компилятор не знает тип объекта, но механизм вызова методов определяет его и вызывает соответствующее тело метода. Механизм позднего связывания зависит от конкретного языка, но нетрудно предположить, что для его реализации в объекты должна включаться какая-то дополнительная информация.

При использовании полиморфизма и наличии переопределенных методов в дочерних классах, динамическое связывание позволяет вызывать методы, специфичные для конкретного объекта, даже если переменная, через которую происходит вызов, имеет тип родительского класса.

Для всех методов Java используется механизм позднего (динамического) связывания, если только метод не был объявлен как `final` (приватные методы являются `final` по умолчанию).

Статическое связывание происходит во время компиляции, когда компилятор выбирает метод на основе типа переменной, а не фактического типа объекта. В Java статическое связывание применяется к статическим методам и методам, вызываемым через имя класса, а не через объект.

[к оглавлению](#ООП)

## [Что такое SOLID?](SOLID.md)

## Что такое REST?

*REST (Representational state transfer)* – это стиль архитектуры программного обеспечения для распределенных систем, таких как World Wide Web, который, как правило, используется для построения веб-служб.

Системы, поддерживающие REST, называются RESTful-системами.

В общем случае REST является очень простым интерфейсом управления информацией без использования каких-то дополнительных внутренних прослоек. Каждая единица информации однозначно определяется глобальным идентификатором, таким как URL. Каждая URL в свою очередь имеет строго заданный формат.

Отсутствие дополнительных внутренних прослоек означает передачу данных в том же виде, что и сами данные. Т.е. мы не заворачиваем данные во что либо.

Каждая единица информации однозначно определяется URL – это значит, что URL по сути является первичным ключом для единицы данных.

Как происходит управление информацией сервиса – это целиком и полностью основывается на протоколе передачи данных. Наиболее распространенный протокол конечно же HTTP.

Архитектура REST очень проста в плане использования. По виду пришедшего запроса сразу можно определить, что он делает, не разбираясь в форматах (в отличие от SOAP, XML-RPC). Данные передаются без применения дополнительных слоев, поэтому REST считается менее ресурсоемким, поскольку не надо парсить запрос чтоб понять что он должен сделать и не надо переводить данные из одного формата в другой.

# Источники
+ [DevColibri](https://devcolibri.com/%d1%87%d1%82%d0%be-%d1%82%d0%b0%d0%ba%d0%be%d0%b5-%d0%be%d0%be%d0%bf-%d0%b8-%d1%81-%d1%87%d0%b5%d0%bc-%d0%b5%d0%b3%d0%be-%d0%b5%d0%b4%d1%8f%d1%82/)
+ [Хабрахабр](https://habrahabr.ru/post/87119/)
+ [Википедия](https://ru.wikipedia.org/wiki/Объектно-ориентированное_программирование)

[Вопросы для собеседования](README.md)
