[Вопросы для собеседования](https://github.com/Oknel-Vap/Interview_questions/blob/main/QUESTIONS.md#interview_questions)

# Процедурная Java

+ [Какие примитивные типы данных есть в Java?](#какие-примитивные-типы-данных-есть-в-java)
+ [Что такое char?](#что-такое-char)
+ [Сколько памяти занимает boolean?](#сколько-памяти-занимает-boolean)
+ [Что такое классы-обертки?](#что-такое-классы-обертки)
+ [Что такое автоупаковка и автораспаковка?](#что-такое-автоупаковка-и-автораспаковка)
+ [Что такое явное и неявное приведение типов? В каких случаях в java нужно использовать явное приведение?](#что-такое-явное-и-неявное-приведение-типов-в-каких-случаях-в-java-нужно-использовать-явное-приведение)
+ [Что такое пул интов?](#Что-такое-пул-интов)
+ [Какие нюансы у строк в Java?](#какие-нюансы-у-строк-в-java)
+ [Что такое пул строк?](#что-такое-пул-строк)
+ [Почему не рекомендуется изменять строки в цикле? Что рекомендуется использовать?](#почему-не-рекомендуется-изменять-строки-в-цикле-что-рекомендуется-использовать)
+ [Почему строки не рекомендуется использовать для хранения паролей?](#почему-строки-не-рекомендуется-использовать-для-хранения-паролей)
+ [Почему String неизменяемый и финализированный класс?](#почему-string-неизменяемый-и-финализированный-класс)
+ [Почему строка является популярным ключом в HashMap в Java?](#почему-строка-является-популярным-ключом-в-hashmap-в-java)
+ [Что делает метод intern() в классе String?](#что-делает-метод-intern-в-классе-string)
+ [Можно ли использовать строки в конструкции switch?](#можно-ли-использовать-строки-в-конструкции-switch)
+ [Какая основная разница между String, StringBuffer, StringBuilder?](#какая-основная-разница-между-string-stringbuffer-stringbuilder)
+ [Существуют ли в java многомерные массивы?](#существуют-ли-в-java-многомерные-массивы)
+ [Какими значениями инициируются переменные по умолчанию?](#какими-значениями-инициируются-переменные-по-умолчанию)
+ [Что такое сигнатура метода?](#что-такое-сигнатура-метода)
+ [Расскажите про метод main](#расскажите-про-метод-main)
+ [Каким образом переменные передаются в методы, по значению или по ссылке?](#каким-образом-переменные-передаются-в-методы-по-значению-или-по-ссылке)

## Какие примитивные типы данных есть в Java?

примитивных типов (или просто примитивов) входят четыре подвида и восемь типов данных:

1) целые числа (byte, short, int, long);

2) числа с плавающей точкой (float, double);

3) логический (boolean);

4) символьный (char).

![](images/prim.png)

[к оглавлению](#Процедурная-Java)

## Что такое char?

Символы описываются в языке Java char типом. Символы преобразуются по таблице кодировки UTF-16. По большому счёту это все буквы, числа и специальные символы существующие на нашей планете. 

Размер в байтах - 2 байта

Возможные значения (от..до) - 0..65,535

Значение по умолчанию - '\u0000'

Пример объявление символьных типов:

`char c1 = 'a';`

Тип char является псевдоцелочисленным типом, поэтому значения этого типа можно задавать в виде числа - кода символа из таблицы кодировки UTF-16. Каждому символу соответствует определённое число из таблицы и Java при виде этого числа в рамках типа char выводит его на экран как символ.

Например, при выполнении этого кода

`char c2 = 97;`

`System.out.println(c2);`

на консоль выведется 

`a`

[Статья на тему](https://pr0java.blogspot.com/2015/04/java-char.html)

[к оглавлению](#Процедурная-Java)

## Сколько памяти занимает boolean?

В Java тип boolean занимает 1 байт (8 бит) в памяти.

Хотя в спецификации языка Java не указано явно, что размер типа boolean должен быть 1 байт, на практике большинство реализаций Java используют 1 байт для представления значения true или false. Это связано с тем, что наименьший адресуемый размер в памяти в Java - 1 байт.

Значение true обычно представляется единицей (1), а значение false - нулем (0). Таким образом, для хранения переменной типа boolean достаточно 1 байта памяти.

Важно отметить, что размер типа boolean может отличаться в других языках программирования или на разных платформах. Однако в контексте Java тип boolean обычно занимает 1 байт.

[к оглавлению](#Процедурная-Java)

## Что такое классы-обертки?

Очень часто необходимо создать класс, основное назначение которого содержать в себе какое-то примитивное значение. Например, как мы увидим в следующих занятиях, обобщенные классы и в частности коллекции работают только с объектами. Поэтому, чтобы каждый разработчик не изобретал велосипед, в Java SE уже добавлены такие классы, которые называются оболочки типов (или классы обертки, Wrappers).

К оболочкам типов относятся классы Double, Float, Long, Integer, Short, Byte, Character, Boolean, Void. Для каждого примитивного значения и ключевого слова void есть свой класс двойник. Имя класса, как вы видите, совпадает с именем примитивного значения. Исключения составляют класс Integer (примитивный тип int) и класс Character (примитивный тип char). Кроме содержания в себе значения, классы оболочки предоставляют обширный ряд методов, которые мы рассмотрим в этом уроке.

Объекты классов оболочек неизменяемые (immutable). Это значит, что объект не может быть изменен. 

Все классы обертки числовых типов имеют переопределенный метод equals(Object), сравнивающий примитивные значения объектов.

### Конструкторы оболочек

В следующей таблицы для каждого класса оболочки указан соответствующий примитивный тип и варианты конструкторов. Как вы видите каждый класс имеет два конструктора: один на вход принимает значение соответствующего примитивного значения, а второй - значение типа String. Исключения: класс Character, у которого только один конструктор с аргументом char и класс Float, объявляющий три конструктора - для значения float, String и еще double.

<img width="615" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/58dce9c6-0aa1-4b6a-a829-d06ac1d591ac">

При вызове конструктора с аргументом String класса Boolean, не обязательно передавать строки true или false. Если аргумент содержит любую другую строку, просто будет создан объект, содержащий значение false. Исключение выброшено не будет.

### Методы классов оболочек

_**Методы valueOf()**_

Метод valueOf() предоставляет второй способ создания объектов оболочек. Метод перегруженный, для каждого класса существует два варианта - один принимает на вход значение соответствующего типа, а второй - значение типа String. Так же как и с конструкторами, передаваемая строка должна содержать числовое значение. Исключение составляет опять же класс Character - в нем объявлен только один метод, принимающий на вход значение char. 

И в целочисленные классы Byte, Short, Integer, Long добавлен еще один метод, в который можно передать строку, содержащую число в любой системе исчисления. Вторым параметром вы указываете саму систему исчисления.

<img width="446" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/7139675e-69a5-427f-9d51-4983760716d2">


_**Методы parseXxx()**_

В каждом классе оболочке содержатся методы, позволяющие преобразовывать строку в соответствующее примитивное значение. В классе Double - это метод parseDouble(), в классе Long - parseLong() и так далее. Разница с методом valueOf() состоит в том, что метод valueOf() возвращает объект, а parseXxx() - примитивное значение.

Также в целочисленные классы Byte, Short, Integer, Long добавлен метод, в который можно передать строку, содержащую число в любой системе исчисления. Вторым параметром вы указываете саму систему исчисления.

_**Методы toString()**_

Все типы оболочки переопределяют toString(). Этот метод возвращает читабельную для человека форму значения, содержащегося в оболочке. Это позволяет выводить значение, передавая объект оболочки типа методу println().

Также все числовые оболочки типов предоставляют статический метод toString(), на вход которого передается примитивное значение. Метод возвращает значение String.

Integer и Long предоставляют третий вариант toString() метода, позволяющий представить число в любой системе исчисления. Он статический, первый аргумент – примитивный тип, второй - основание системы счисления:

<img width="448" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/a439464a-4b5f-4826-8a8a-b58a45f62bf5">


_**Методы toHexString(), toOctalString(), toBinaryString()**_

Integer и Long позволяют преобразовывать числа из десятичной системы исчисления к шестнадцатеричной, восьмеричной и двоичной системе. Например:

<img width="497" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/08cfd6a2-692d-41fd-81ac-a34f06b5999b">

В классы Double и Float добавлен только метод toHexString().

### Класс Number

Все оболочки числовых типов наследуют абстрактный класс Number. Number объявляет методы, которые возвращают значение объекта в каждом из различных числовых форматов.

<img width="720" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/21077d1a-82ef-41e8-897c-0e9ae207f78e">

### Статические константы классов оболочек

Каждый класс оболочка содержит статические константы, содержащие максимальное и минимальное значения для данного типа.

Например, в классе Integer есть константы Integer.MIN_VALUE – минимальное int значение и Integer.MAX_VALUE – максимальное int значение.

Классы обертки числовых типов Float и Double, помимо описанного для целочисленных примитивных типов, дополнительно содержат определения следующих констант:

+ NEGATIVE_INFINITY – отрицательная бесконечность;
+ POSITIVE_INFINITY – положительная бесконечность;
+ NaN – не числовое значение (расшифровывается как Not a Number).
  
При делении на ноль возникает ошибка - на ноль делить нельзя. Чтобы этого не происходило, и ввели переменные NEGATIVE_INFINITY и POSITIVE_INFINITY. Результат умножения бесконечности на ноль - это значение NaN

[к оглавлению](#Процедурная-Java)

## Что такое автоупаковка и автораспаковка?

Для присваивания ссылок-примитивов объектам их классов-оберток (и наоборот) не требуется ничего делать, все происходит автоматически

```java
int x = 7;

Integer y = 111;

x = y; // автораспаковка

y = x * 123; // автоупаковка
```

Автоупаковка и распаковка не работают для массивов.

Автоупаковка - это механизм неявной инициализации объектов классов-оберток (Byte, Short, Integer, Long, Float, Double, Character, Boolean) значениями соответствующих им исходных примитивных типов (byte, short, int...), без явного использования конструктора класса.

+ Автоупаковка происходит при прямом присваивании примитива классу-обертке (с помощью оператора =), либо при передаче примитива в параметры метода (типа класса-обертки).

+ Автоупаковке в классы-обертки могут быть подвергнуты как переменные примитивных типов, так и константы времени компиляции (литералы и final-примитивы). При этом литералы должны быть синтаксически корректными для инициализации переменной исходного примитивного типа.

+ Автоупаковка переменных примитивных типов требует точного соответствия типа исходного примитива типу класса-обертки.

Например, попытка упаковать переменную типа byte в Short, без предварительного явного приведения byte в short вызовет ошибку компиляции.

+ Автоупаковка констант примитивных типов допускает более широкие границы соответствия.

В этом случае компилятор способен предварительно осуществлять неявное расширение/сужение типа примитивов.

Неявное расширение/сужение исходного типа примитива до типа примитива соответствующего классу-обертке (для преобразования int в Byte, сначала компилятор самостоятельно неявно сужает int к byte) автоупаковку примитива в соответствующий класс-обертку.

Однако, в этом случае существуют два дополнительных ограничения:

a) присвоение примитива обертке может производится только оператором = (нельзя передать такой примитив в параметры метода без явного приведения типов)

b) тип левого операнда не должен быть старше чем Character, тип правого не должен старше, чем int.

Допустимо расширение/сужение byte в/из short, byte в/из char, short в/из char и только сужение byte из int, short из int, char из int. Все остальные варианты требуют явного приведения типов.

Дополнительной особенностью целочисленных классов-оберток созданных автоупаковкой констант в диапазоне -128 ... +127 является то, что они кэшируются JVM. Поэтому такие обертки с одинаковыми значениями будут являться ссылками на один объект.

[к оглавлению](#Процедурная-Java)

## Что такое явное и неявное приведение типов? В каких случаях в java нужно использовать явное приведение?

Каждое выражение и каждая переменная имеет строго определенный тип уже на момент компиляции. Механизм приведения типов (casting) - способ преобразования значения переменной одного типа в значение другого типа:

`Неявные` – выполняются автоматически (расширяющие преобразования, сужающие с потерей данных: int->float, long->float, long->double).

`Явные` – надо указывать тип (сужающие преобразования от типа с большей разрядностью к типу с меньшей разрядностью). Потеря данных (старшие биты будут потеряны).

<img width="631" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/12e0c3d3-5ef1-4106-b980-f9bd87efdf11">


### Разновидности приведения:

_**Тождественное (identity)**_ - Преобразование выражения любого типа к точно такому же типу всегда допустимо и происходит автоматически.

_**Расширение (повышение, upcasting) примитивного типа (widening primitive)**_ - Означает, что осуществляется переход от менее емкого типа к более ёмкому. Этот тип приведения всегда допустим и происходит автоматически.

Например, от типа byte (длина 8 бит) к типу int (длина 32 бита). Такие преобразование безопасны в том смысле, что новый тип всегда гарантировано вмещает в себя все данные, которые хранились в старом типе и таким образом не происходит потери данных.

_**Сужение (понижение, downcasting) примитивного типа (narrowing primitive)**_ - Означает, что переход осуществляется от более емкого типа к менее емкому. При таком преобразовании есть риск потерять данные.

В Java такое преобразование должно совершаться явным образом, при этом все старшие биты, не умещающиеся в новом типе, просто отбрасываются - никакого округления или других действий для получения более корректного результата не производится.

Например, если число типа int было больше 127, то при приведении его к byte значения битов старше восьмого будут потеряны.

_**Расширение объектного типа (widening reference)**_ - Означает неявное восходящее приведение типов или переход от более конкретного типа к менее конкретному, т.е. переход от потомка к предку. Разрешено всегда и происходит автоматически.

_**Сужение объектного типа (narrowing reference)**_ - Означает нисходящее приведение, то есть приведение от предка к потомку (подтипу). Возможно только если исходная переменная является подтипом приводимого типа.

Требует явного указания типа. При несоответствии типов в момент выполнения выбрасывается исключение ClassCastException.

_**Преобразование к строке (to String)**_ - Любой тип может быть приведен к строке, т.е. к экземпляру класса String.

_**Запрещенные преобразования (forbidden)**_ - Не все приведения между произвольными типами допустимы. Например, к запрещенным преобразованиям относятся приведения от любого ссылочного типа к примитивному и наоборот (кроме преобразования к строке). Кроме того невозможно привести друг к другу классы находящиеся на разных ветвях дерева наследования и т.п.

>**При приведении ссылочных типов с самим объектом ничего не происходит, меняется лишь тип ссылки, через которую происходит обращение к объекту.**

Для проверки возможности приведения нужно воспользоваться оператором instanceof:

```java
Parent parent = new Child();

if (parent instanceof Child) {

Child child = (Child) parent;

}
```
В Java, типы `byte` и `short` занимают меньше памяти, чем тип `char`. Тип `byte` занимает 8 бит (1 байт), тип `short` занимает 16 бит (2 байта), а тип `char` занимает 16 бит (2 байта).

При преобразовании типа `byte` или `short` в тип `char`, вам также нужно явно указать преобразование, потому что существует потенциальная потеря информации.

Тип `char` предназначен для представления символов в кодировке Unicode, а типы `byte` и `short` предназначены для хранения числовых значений. При преобразовании `byte` или `short` в `char`, значения сохраняются, но их интерпретация изменяется.

Важно понимать, что тип `char` использует беззнаковое представление, тогда как типы `byte` и `short` используют знаковое представление. При преобразовании отрицательных значений типов `byte` или `short` в тип `char`, знаковое значение будет расширено до беззнакового значения в диапазоне от 0 до 65535.

Вот примеры преобразования типов `byte` и `short` в тип `char`:

```java
byte byteValue = 65;
char charValue1 = (char) byteValue; // Явное преобразование byte в char

short shortValue = 65;
char charValue2 = (char) shortValue; // Явное преобразование short в char
```

В обоих примерах значение `65` сохраняется при преобразовании, но его интерпретация изменяется. В результате получается символ `'A'`, потому что символ `'A'` имеет код Unicode 65.

Таким образом, даже если типы `byte` и `short` занимают меньше памяти, чем тип `char`, все равно требуется явное преобразование, чтобы указать, что вы осознанно выполняете преобразование и понимаете потенциальные проблемы, связанные с интерпретацией значений и потерей информации.

[к оглавлению](#Процедурная-Java)

## Что такое пул интов?

Для более эффективного использования памяти, в JAVA используются так называемые пулы.

Есть строковый пул, Integer pool и тд. Когда мы создаем объект не используя операцию new, объект помещается в пул, и в последствии, если мы захотим создать такой же объект (опять не используя new), новый объект создан не будет, а мы просто получим ссылку на наш объект из пула.

Особенность Integer-пула — он хранит только числа, которые помещаются в тип данных byte: от -128 до 127. Для остальных чисел пул не работает.

```java
Integer i1 = 127;

Integer i2 = 127;

Integer i3 = 128;

Integer i4 = 128;

System.out.println(i1==i2); //true

System.out.println(i3==i4); //false
```

[к оглавлению](#Процедурная-Java)

## Какие нюансы у строк в Java?

Это неизменяемый (immutable) (не меняется после создания) и финализированный (без потомков) тип данных; потокобезопасный может использоваться в многопоточке

+ Все объекты класса String JVM хранит в пуле строк;(если вы создаете строки динамически (например, с помощью конструктора new String("hello")), они не будут добавлены в пул строк и будут иметь отдельные объекты даже при наличии строки с таким же значением в пуле.)
+ Объект класса String можно получить используя двойные кавычки;
+ Можно использовать оператор + для конкатенации строк;
+ Начиная с Java 7 строки можно использовать в конструкции switch.
+ Каждый объект можно привести к строке .toString

[к оглавлению](#Процедурная-Java)

## Что такое пул строк?

Пул строк – это набор строк хранящийся в Heap.

Пул строк возможен благодаря неизменяемости строк в Java и реализации идеи интернирования строк;

Интернирование строк — это механизм, при котором одинаковые литералы представляют собой один объект в памяти.

Пул строк помогает экономить память, но по этой же причине создание строки занимает больше времени;

Когда для создания строки используются ", то сначала ищется строка в пуле с таким же значением, если находится, то просто возвращается ссылка, иначе создается новая строка в пуле, а затем возвращается ссылка на неё;

`String habr = "habrahabr"; - “строковый литерал”`

При использовании оператора new создается новый объект String. Затем при помощи метода intern() эту строку можно поместить в пул или же получить из пула ссылку на другой объект String с таким же значением;
```java
String q = "I'm";

String w = "I'm";

String r = new String("I'm");

String t = r.intern();

System.out.println("q==w: " + (q==w)); //true

System.out.println("q==r: " + (q==r)); //false

System.out.println("q==t: " + (q==t)); //true
```
Пул строк является примером паттерна «Приспособленец» (Flyweight).

[к оглавлению](#Процедурная-Java)

## Почему не рекомендуется изменять строки в цикле? Что рекомендуется использовать?

Строки являются неизменяемыми объектами и поэтому возможно компилятору придётся создавать как минимум один новый объект, чтобы удержать результат при аппендинге к строкам. Конструирование строки в цикле требует создания новой строки в каждой итерации и поэтому отнимает больше времени и памяти. Это плохо скажется на производительности алгоритма.

Строка – неизменяемый класс, поэтому растет потребление ресурсов при редактировании, т. к. при каждой итерации будет создаваться новый объект строки. Рекомендуется использовать StringBuilder.

Применить StringBuilder до цикла, в цикле .append
```java
String s5 = "I'm ";

String s6 = " + Java developer";

StringBuffer sb = new StringBuffer(); 

for (int i = 0; i < 8; i++) {

    System.out.println(sb.append(s5).append(s6));

}
```
`StringBuilder` в Java представляет собой класс, который используется для построения и модификации строк. Он предоставляет более эффективный способ работы со строками, чем обычная конкатенация с помощью оператора `+`.

`StringBuilder` устроен таким образом, что он использует изменяемый буфер для хранения символов строки. При создании объекта `StringBuilder` выделяется начальный буфер определенного размера, который по мере необходимости автоматически расширяется. Это позволяет избежать создания лишних промежуточных строк при конкатенации.

Когда вы вызываете методы `append()` или `insert()` у объекта `StringBuilder`, переданные символы или строки добавляются в его внутренний буфер. Если буфер оказывается недостаточным для хранения добавляемых данных, он автоматически расширяется путем выделения нового буфера большего размера и копирования существующих данных.

`StringBuilder` также предоставляет методы для удаления, замены и вставки символов или подстрок внутри строки. Эти операции выполняются непосредственно в изменяемом буфере, без создания новых промежуточных строк.

Когда вам нужно получить окончательную строку, вы можете вызвать метод `toString()` у объекта `StringBuilder`, который создаст новую строку на основе содержимого его буфера и вернет ее.

Использование `StringBuilder` вместо обычной конкатенации строк может значительно улучшить производительность и экономить память, особенно при работе с большим количеством строк или при выполнении множественных модификаций строки.

[к оглавлению](#Процедурная-Java)

## Почему строки не рекомендуется использовать для хранения паролей?

`String (in pool before garbage) -> char []`

С момента создания строка остается в пуле, до тех пор пока не будет удалена сборщиком мусора. Поэтому, даже после окончания использования пароля, он некоторое время продолжает оставаться доступным в памяти и способа избежать этого не существует.

Это представляет определённый риск для безопасности, поскольку кто-либо, имеющий доступ к памяти сможет найти пароль в виде текста. В случае использования массива символов для хранения пароля имеется возможность очистить его сразу по окончанию работы с паролем, позволяя избежать риска безопасности, свойственного строке.

В Java строки (тип `String`) являются неизменяемыми объектами, что означает, что они не могут быть изменены после создания. Это имеет некоторые последствия в контексте безопасности паролей:

1. Неизменяемость: Когда строка содержит пароль, она остается в памяти до тех пор, пока не будет собрана сборщиком мусора. В течение этого времени строка может быть доступна в памяти несколько раз, даже после того, как она больше не нужна. Это увеличивает риск возможного компрометации пароля.

2. Кэширование: Строки в Java могут быть закэшированы в пуле строк, что означает, что одинаковые строки могут использовать один и тот же объект в памяти. Если пароль хранится в строке и кэшируется, то другой участник программы или злоумышленник может получить доступ к этому паролю, используя ссылку на тот же объект строки.

3. Сериализация: Строки в Java могут быть сериализованы и десериализованы. При сериализации строки, ее содержимое может быть сохранено в файле или передано по сети. Это может привести к потенциальному раскрытию пароля, если не предпринимаются соответствующие меры безопасности.

Вместо использования строк для хранения паролей, рекомендуется использовать специальные классы, такие как `char[]` или `java.util.Arrays`, которые могут быть очищены после использования. Это позволяет контролировать данные пароля в памяти и уничтожить их после использования, минимизируя риск компрометации пароля.

В Java для очистки массива символов, используемого для хранения пароля, можно выполнить следующие действия:

1. Используйте метод `Arrays.fill()` для заполнения массива символов случайными значениями или нулями. Например:
```java
char[] password = {'p', 'a', 's', 's', 'w', 'o', 'r', 'd'};
Arrays.fill(password, '\0'); // Заполняем массив символов нулевыми значениями
```
Это поможет затереть фактические символы пароля в памяти и сделать их нечитаемыми.

2. После заполнения массива символов, рекомендуется также уничтожить ссылку на массив, чтобы предотвратить возможность случайного доступа к данным пароля в памяти. Например:
```java
char[] password = {'p', 'a', 's', 's', 'w', 'o', 'r', 'd'};
Arrays.fill(password, '\0'); // Заполняем массив символов нулевыми значениями
password = null; // Уничтожаем ссылку на массив
```
Установка ссылки на массив в значение `null` поможет ускорить процесс освобождения памяти, так как сборщик мусора может обнаружить, что массив больше не используется и освободить память.

Важно отметить, что эти действия помогут уменьшить риск компрометации пароля в памяти, но это не гарантирует полной безопасности. Некоторые языки программирования или среды выполнения могут сохранять копии данных в памяти или на диске во время выполнения программы. Поэтому, помимо очистки массива символов, также важно принимать меры для обеспечения безопасности пароля, такие как хеширование и соблюдение хороших практик безопасности.

[к оглавлению](#Процедурная-Java)

## Почему String неизменяемый и финализированный класс?

+ Пул строк возможен только потому, что строка неизменяемая, таким образом виртуальная машина сохраняет больше свободного места в Heap, поскольку разные строковые переменные указывают на одну и ту же переменную в пуле. Если бы строка была изменяемой, то интернирование строк не было бы возможным, потому что изменение значения одной переменной отразилось бы также и на остальных переменных, ссылающихся на эту строку.
+ Если строка будет изменяемой, тогда это станет серьезной угрозой безопасности приложения. Например, имя пользователя базы данных и пароль передаются строкой для получения соединения с базой данных и в программировании сокетов реквизиты хоста и порта передаются строкой. Так как строка неизменяемая, её значение не может быть изменено, в противном случае злоумышленник может изменить значение ссылки и вызвать проблемы в безопасности приложения.
+ Неизменяемость позволяет избежать синхронизации: строки безопасны для многопоточности и один экземпляр строки может быть совместно использован различными потоками.
+ Строки используются classloader-ом и неизменность обеспечивает правильность загрузки класса.
+ Поскольку строка неизменяемая, её hashCode() кэшируется в момент создания и нет необходимости рассчитывать его снова. Это делает строку отличным кандидатом для ключа в HashMap т.к. его обработка происходит быстрее.

[к оглавлению](#Процедурная-Java)

## Почему строка является популярным ключом в HashMap в Java?

Поскольку строка неизменяемая, её hashCode() кэшируется в момент создания и нет необходимости рассчитывать его снова. Это делает строку отличным кандидатом для ключа в HashMap т.к. его обработка происходит быстрее

[к оглавлению](#Процедурная-Java)

## Что делает метод intern() в классе String?

Метод intern() используется для сохранения строки в пуле строк или получения ссылки, если такая строка уже находится в пуле.
```java
String q = "I'm"; 

String w = "I'm"; 

String r = new String("I'm"); 

String t = r.intern(); 

System.out.println("q==w: "+(q==w)); //true 

System.out.println("q==r: "+(q==r)); //false 

System.out.println("q==t: "+(q==t)); //true
```

Метод intern() используется для уменьшения использования памяти, особенно если в программе используется много строк, которые повторяются.

Когда мы вызываем метод intern() для строки, JVM сначала проверяет, есть ли уже такая строка в пуле строк. Если да, то метод вернет ссылку на эту строку, иначе создаст новую строку в пуле и вернет ссылку на нее.

Таким образом, если мы создаем много строк, которые повторяются, и используем метод intern(), то мы можем сэкономить память, т.к. разные переменные будут ссылаться на один и тот же объект в пуле строк.

В случае, если мы пишем String t = "I'm"; , JVM автоматически поместит строку "I'm" в пул строк, но если бы мы создали ее динамически (например, String t = new String("I'm");), то она была бы создана в обычной области памяти (не в пуле строк), и если бы мы создали еще одну строку с таким же значением в другом месте программы, то JVM создала бы два разных объекта в памяти.

Поэтому использование метода intern() рекомендуется для оптимизации памяти при работе со строками.

Метод intern используется для оптимизации использования памяти и уменьшения количества объектов в памяти. При вызове метода intern() для строки создается ссылка на строку в строковом пуле, если такой строки еще нет в пуле. Если такая строка уже есть в пуле, то возвращается ссылка на нее.

Таким образом, если бы мы написали String t = r, то было бы создано два разных объекта строки "I'm", каждый из которых занимал бы место в памяти. А при использовании метода intern() возвращается ссылка на уже существующий объект, что позволяет сэкономить память и уменьшить количество объектов в памяти.

Использование метода intern() может быть полезно, например, когда нужно обрабатывать большое количество одинаковых строковых значений, например, при парсинге большого документа или обработке большой базы данных.

Да, вы правильно поняли. Если вызвать метод `intern()` на строке, которая не существует в пуле строк, будет создана новая строка в пуле и возвращена ссылка на нее. Таким образом, после вызова `str2.intern()`, у вас будет две ссылки на одну и ту же строку: `str2` и `internedStr2`. Оба объекта будут содержать одинаковые символы, но `internedStr2` будет ссылаться на строку в пуле строк, а `str2` будет ссылаться на объект строки, созданный с использованием оператора `new`.

Важно отметить, что метод `intern()` возвращает ссылку на строку из пула только в том случае, если строка уже существует в пуле. Если строка не существует в пуле, она будет добавлена в пул, и метод `intern()` вернет ссылку на новую строку.

Вот пример для наглядности:

```java
String str1 = "Hello";
String str2 = new String("Hello");

String internedStr1 = str1.intern();
String internedStr2 = str2.intern();

System.out.println(str1 == str2); // Выводит false
System.out.println(str2 == internedStr2); // Выводит false
System.out.println(internedStr1 == internedStr2); // Выводит true
```

В этом примере `str1` и `str2` содержат одинаковые символы, но они являются разными объектами. После вызова `intern()` на `str1` и `str2`, `internedStr1` и `internedStr2` будут содержать ссылки на одну и ту же строку из пула. Поэтому сравнение `internedStr1 == internedStr2` возвращает `true`.

[к оглавлению](#Процедурная-Java)

## Можно ли использовать строки в конструкции switch?

Да, начиная с Java 7 в операторе switch можно использовать строки, ранние версии Java не поддерживают этого. При этом:

+ участвующие строки чувствительны к регистру;
+ используется метод equals() для сравнения полученного значения со значениями case, поэтому во избежание NullPointerException стоит предусмотреть проверку на null.
+ согласно документации Java 7 для строк в switch, компилятор Java формирует более эффективный байткод для строк в конструкции switch, чем для сцепленных условий if-else.

[к оглавлению](#Процедурная-Java)

## Какая основная разница между String, StringBuffer, StringBuilder?

Класс _**String**_ является неизменяемым (immutable) - модифицировать объект такого класса нельзя, можно лишь заменить его созданием нового экземпляра.

Класс _**StringBuffer**_ изменяемый - использовать StringBuffer следует тогда, когда необходимо часто модифицировать содержимое. Потокобезопасный. Синхронизированные методы работают медленнее не сихнронизированных. 

Класс _**StringBuilder**_ был добавлен в Java 5 и он во всем идентичен классу StringBuffer за исключением того, что он не синхронизирован и поэтому его методы выполняются значительно быстрей.

Класс _**StringJoiner**_ используется, чтобы создать последовательность строк, разделенных разделителем с возможностью присоединить к полученной строке префикс и суффикс:
```java
StringJoiner joiner = new StringJoiner(\".\", \"prefix-\", \"-suffix\"); 

for (String s : \"Hello the brave world\".split(\" \")) { 

    joiner.add(s); 

} 

System.out.println(joiner); //prefix-Hello.the.brave.world-suffix
```
> В Java ключевое слово synchronized может использоваться для объявления синхронизированных методов. Синхронизированный метод в Java обеспечивает монопольный доступ к методу одному потоку в определенный момент времени, блокируя другим потокам доступ к этому методу до его завершения.

> Когда метод объявляется с модификатором synchronized, он становится связанным с монитором объекта, на котором он вызывается. В каждом объекте Java есть внутренний монитор (также известный как мьютекс), который используется для синхронизации доступа к синхронизированным методам и блокам кода.

> Когда поток пытается вызвать синхронизированный метод, он должен сначала получить монитор объекта, на котором вызывается метод. Если монитор заблокирован другим потоком, ожидающий поток переходит в состояние ожидания до тех пор, пока монитор не будет освобожден. Когда монитор становится доступным, ожидающий поток получает его и начинает выполнение синхронизированного метода.

> Синхронизированные методы полезны в случаях, когда несколько потоков могут одновременно обращаться к общим данным объекта и необходимо гарантировать, что только один поток выполняет метод в данный момент времени. Это помогает предотвратить состояние гонки (race condition) и обеспечивает согласованность данных при работе с многопоточностью.

[к оглавлению](#Процедурная-Java)

## Существуют ли в Java многомерные массивы?

Да, смотря как понимать понятие, пусть многомерный массив в Джава - массив в массиве (зубчатый массив), могут раскиданы по памяти, влияет на производительность.

Да, в Java существуют многомерные массивы. Многомерный массив представляет собой массив, элементы которого сами являются массивами. В Java можно создавать массивы с любым количеством измерений.

В Java существуют различные виды массивов, включая одномерные, многомерные и зубчатые массивы. Вот краткое описание каждого из них:

1. Одномерные массивы: Одномерный массив представляет собой последовательность элементов одного типа, расположенных в одной линии. Они являются наиболее простым видом массивов в Java. Для объявления одномерного массива используется следующий синтаксис:

   ```java
   тип_элементов[] имя_массива = new тип_элементов[размер];
   ```

   Например:

   ```java
   int[] numbers = new int[5];
   ```

2. Многомерные массивы: Многомерный массив представляет собой массив, элементы которого сами являются массивами. Они позволяют организовать данные в форме таблицы с несколькими измерениями. Например, двумерный массив представляет собой таблицу с рядами и столбцами. Для объявления многомерного массива используется следующий синтаксис:

   ```java
   тип_элементов[][] имя_массива = new тип_элементов[размер1][размер2];
   ```

   Например:

   ```java
   int[][] matrix = new int[3][3];
   ```

3. Зубчатые массивы (Jagged Arrays): Зубчатый массив представляет собой массив массивов, где каждый подмассив может иметь различную длину. Это отличается от обычных многомерных массивов, где все подмассивы имеют одинаковую длину. Для объявления зубчатого массива используется следующий синтаксис:

   ```java
   тип_элементов[][] имя_массива = new тип_элементов[размер1][];
   имя_массива[индекс] = new тип_элементов[размер2];
   ```

   Например:

   ```java
   int[][] jaggedArray = new int[3][];
   jaggedArray[0] = new int[2];
   jaggedArray[1] = new int[3];
   jaggedArray[2] = new int[4];
   ```

   В этом примере `jaggedArray` является зубчатым массивом, где первый подмассив имеет длину 2, второй - длину 3, а третий - длину 4.

Зубчатые массивы полезны, когда количество элементов в каждом подмассиве может быть разным или изменчивым. Они предоставляют гибкость при работе с данными, которые не соответствуют регулярной таблице с постоянными размерами подмассивов.

[к оглавлению](#Процедурная-Java)

## Какими значениями инициируются переменные по умолчанию?

Числа инициализируются 0 или 0.0; 

char — \u0000; 

boolean — false; 

Объекты (в том числе String) — null.

Локальные переменные должны инициализироваться явно, по умолчанию у них нет значений. В Java локальные переменные (то есть переменные, объявленные внутри методов или блоков кода) должны быть инициализированы явно перед их использованием. В отличие от полей объектов или статических полей, для которых могут быть значения по умолчанию, локальные переменные не получают автоматических значений.

Если вы попытаетесь использовать значение локальной переменной до того, как она была инициализирована, компилятор Java выдаст ошибку компиляции. Это обеспечивает более предсказуемое и безопасное поведение программы.

[к оглавлению](#Процедурная-Java)

## Что такое сигнатура метода?

Объявление (спецификация) метода - это весь код, который описывает метод.

`public String methodName(double a, int b) throws IOException`

модификатор_доступа + тип_возвращаемого_значения + имя_метода(список_параметров) + исключения

Сигнатура - название метода и типы параметров в определенном порядке. methodName(double, int)

Контракт метода - сигнатура метода, в сочетании с типом возвращаемого значения. В контракт также входят типы возбуждаемых методом исключений.

`String methodName(double a, int b) throws IOException`

Насколько я понимаю модификатор доступа ни куда не входит.

[к оглавлению](#Процедурная-Java)

## Расскажите про метод main?

Является, как правило, точкой входа в программу и вызывается JVM. Как только заканчивается выполнение метода main(), так сразу же завершается работа самой программы. 

static – чтобы JVM смогла загрузить его во время компиляции. 

public static void и сигнатура – обязательное декларирование. 

Мэйнов может быть много и может не быть вообще. 

Может быть перегружен.

Если местами поменять паблик и статик – все норм запуститься? можно запускать без маина прогу.
Можно поменять, да запуститься.

Можно было запустить в Java 6 и более ранних версиях статическим блоком с exit(). Теперь нет. манифест (2 метода маин)

В Java программа должна иметь метод `main` в качестве точки входа. Это требование определено в спецификации языка Java. Когда вы запускаете программу на Java, виртуальная машина Java (JVM) ищет метод `main` с точно такой же сигнатурой в классе, указанном в качестве точки входа. Если метод `main` не найден, JVM не сможет запустить программу.

Метод `main` является обязательным, потому что он определяет, с какого места начнется выполнение программы. Внутри метода `main` вы можете разместить код, который будет выполняться при запуске программы. Это может быть любая последовательность операторов, которая реализует требуемую логику вашей программы.

Вот пример минимальной программы на Java с методом `main`:

```java
public class MyProgram {
    public static void main(String[] args) {
        System.out.println("Hello, world!");
    }
}
```

В этом примере метод `main` выводит строку "Hello, world!" на консоль при запуске программы.

Таким образом, метод `main` является неотъемлемой частью любой Java-программы и не может быть опущен.

Да, в Java вы можете перегрузить метод `main`. Перегрузка методов позволяет создавать несколько методов с одинаковыми именами, но с разными параметрами. Когда вы вызываете метод с перегруженным именем, компилятор Java определяет, какой из перегруженных методов должен быть вызван, основываясь на типах аргументов.

Однако, при запуске программы JVM ищет метод `main` с точно такой же сигнатурой, как указано ниже:

```java
public static void main(String[] args)
```

То есть, точка входа в программу должна быть методом `main` с аргументом типа `String` массива (`String[]`). Если вы перегружаете метод `main` с другими параметрами, JVM не сможет использовать его в качестве точки входа при запуске программы.

Однако, вы можете создавать перегруженные версии метода `main` с другими параметрами для использования внутри вашей программы. Это может быть полезно, если вам нужно вызывать различные варианты метода `main` с разными наборами параметров в разных ситуациях.

Вот пример перегрузки метода `main`:

```java
public class MyProgram {
    public static void main(String[] args) {
        System.out.println("Hello, world!");
    }

    public static void main(String arg) {
        System.out.println("Hello, " + arg + "!");
    }
}
```

В этом примере определены две версии метода `main`. Первая версия принимает массив строк в качестве аргумента и выводит "Hello, world!" на консоль. Вторая версия принимает строку в качестве аргумента и выводит "Hello, " с переданной строкой на консоль.

Вы можете вызывать эти версии метода `main` внутри вашей программы, но JVM будет использовать только первую версию с массивом строк в качестве точки входа при запуске программы.

Метод `main` является точкой входа в программу на языке Java. Это особый метод, который выполняется при запуске программы и определяет начало выполнения программного кода. Он имеет следующую сигнатуру:

```java
public static void main(String[] args) {
    // Код программы
}
```

Некоторые ключевые особенности метода `main`:

1. Название и сигнатура: Метод должен называться `main` и принимать один параметр типа `String[]` или `String... args`. Этот параметр представляет аргументы командной строки, переданные программе при ее запуске.

2. Модификаторы доступа: Метод `main` должен быть объявлен как `public` (доступен извне) и `static` (принадлежит классу, а не экземпляру объекта).

3. Возвращаемый тип: Метод `main` должен иметь возвращаемый тип `void`, что означает, что он не возвращает значение.

4. Точка входа: При запуске программы, JVM ищет метод `main` в классе, указанном в командной строке, и начинает выполнение программы с этого метода.

Отсутствие метода `main` в классе приведет к ошибке во время выполнения программы. Таким образом, для того чтобы программа могла быть запущена, она должна содержать метод `main`. Если класс не содержит метода `main`, JVM не сможет найти точку входа и выполнение программы не будет начато.

В некоторых случаях, например, при создании библиотеки или приложения, которое является расширением для другого приложения, метод `main` может быть опущен, поскольку запуск программы будет осуществляться через другие механизмы, предоставляемые средой выполнения или фреймворком. Однако, для самостоятельного исполняемого приложения метод `main` является обязательным.

[к оглавлению](#Процедурная-Java)

## Каким образом переменные передаются в методы, по значению или по ссылке? 

Java передает параметры по значению. Всегда.
```java
int х = 3;

int у = х;
```
Скопировать значение внутри х и записать эту копию в у.
```java
Cat A = new Cat();

Cat B = A;
```
Ссылка А копируется в ссылку B. К объекту это не относится — у нас по-прежнему всего один объект. Но теперь есть две ссылки (оригинальная и копия, т.е. они одинаковые, просто их две), контролирующие один и тот же объект Cat.

[к оглавлению](#Процедурная-Java)
