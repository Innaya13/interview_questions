# Stream API

+ [Что такое Stream API? Для чего нужны стримы?](#что-такое-stream-api-для-чего-нужны-стримы)
+ [Почему Stream называют ленивым?](#почему-stream-называют-ленивым)
+ [Какие существуют способы создания стрима?](#какие-существуют-способы-создания-стрима)
+ [Как из коллекции создать стрим?](#как-из-коллекции-создать-стрим)
+ [Какие промежуточные методы в стримах вы знаете?](#какие-промежуточные-методы-в-стримах-вы-знаете)
+ [Методы конвейерные](#методы-конвейерные)
+ [Методы терминальные](#методы-терминальные)
+ [Методы числовых стримов](#методы-числовых-стримов)
+ [Расскажите про класс Collectors и его методы.](#расскажите-про-класс-collectors-и-его-методы)
+ [Расскажите о параллельной обработке в Java 8](#расскажите-о-параллельной-обработке-в-java-8)
+ [Что такое IntStream и DoubleStream?](#что-такое-intstream-и-doublestream)

## Что такое Stream API? Для чего нужны стримы?

https://youtu.be/RzEiCguFZiY

Инструмент языка Java, который позволяет использовать функциональный стиль при работе с разными структурами данных (аналогия КОНВЕЙЕР).

<img width="577" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/e2264635-5c9f-42f4-af95-4d7bcbcc7dbe">

Документация: Классы для поддержки операций функционального стиля над потоками элементов, таких как преобразование map-reduce в коллекциях.

Ключевой абстракцией, представленной в пакете java.util.stream является ПОТОК. Конструкция языка представляющая последовательность элементов, потенциально бесконечная, с возможность применять к ней, сложные, поэтапные преобразования без цикла и условного оператора. Рекомендую видео Тагира Валеева https://youtu.be/vxikpWnnnCU

<img width="1183" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/a8db4c99-e5cc-4920-918f-26b65e841abe">

Stream не может быть использованы повторно. Как только была вызвана терминальная операция, stream закрывается.

<img width="1116" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/3f8a81fc-e592-4e09-ad5e-96ce3b84f305">

Интерфейс java.util.Stream представляет собой последовательность элементов, над которой можно производить различные операции.

Нужны для упрощения работы с наборами данных, в частности, упростить операции фильтрации, сортировки и другие манипуляции с данными.

IntStream.of(50, 60, 70, 80, 90, 100, 110, 120).filter(x -> x < 90).map(x -> x + 10).limit(3).forEach(System.out::print);

Cоздаем экземпляр Stream 

+ Пустой стрим: Stream.empty()
+ Стрим из List: list.stream()
+ Стрим из Map: map.entrySet().stream()
+ Стрим из массива: Arrays.stream(array)
+ Стрим из указанных элементов: Stream.of(\"1\", \"2\", \"3\")
+ Стрим из BufferedReader с помощью метода lines (); нужно закрывать close ().
  
Промежуточные (“intermediate”, “lazy”) — обрабатывают поступающие элементы и возвращают стрим. Может быть много, а может и не быть ни одной.
Терминальные (“terminal”, ещё называют “eager”) — обрабатывают элементы и завершают работу стрима, может быть только один.

**Важные моменты:**

+ Обработка не начнётся до тех пор, пока не будет вызван терминальный оператор. list.stream().filter(s -> s > 5) (не возьмёт ни единого элемента из списка);
+ Экземпляр стрима нельзя использовать более одного раза;

Кроме универсальных объектных существуют особые виды стримов для работы с примитивными типами данных int, long и double: IntStream, LongStream и DoubleStream. Эти примитивные стримыработают так же, как и обычные объектные, но со следующими отличиями:
+ используют специализированные лямбда-выражения, например, IntFunction или IntPredicate вместо Function и Predicate;
+ поддерживают дополнительные конечные операции sum(), average(), mapToObj()

[к оглавлению](#stream-api)

## Почему Stream называют ленивым?

Ленивое программирование - технология, которая позволяет вам отсрочить вычисление кода до тех пор, пока не понадобится его результирующее значение.

Блок обработки – промежуточные операции не выполняются, пока не вызовется терминальная.

Ленивая инициализация - приём в разработке, когда ресурсоемкая операция выполняется только тогда, когда нужен ее результат. Для оптимизации производительности.

Stream API так и работает: мы указываем промежуточные операции, которые нам необходимо произвести и в конце следует завершающая или терминальная операция, которая запускает все вычисления.

<img width="1134" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/95dc7d6f-8f13-486d-b6f3-ca57a956bf46">

[к оглавлению](#stream-api)

## Какие существуют способы создания стрима?

+ Из коллекции: Stream<String> fromCollection = Arrays.asList("x", "y", "z").stream();
+ Из набора значений: Stream<String> fromValues = Stream.of("x", "y", "z");
+ Из массива: Stream<String> fromArray = Arrays.stream(new String[]{"x", "y", "z"});
+ Из файла (каждая строка в файле будет отдельным элементом в стриме): Stream<String> fromFile = Files.lines(Paths.get("input.txt"));
+ Из строки: IntStream fromString = "0123456789".chars();
+ С помощью Stream.builder(): Stream<String> fromBuilder = Stream.builder().add("z").add("y").add("z").build();
+ С помощью Stream.iterate() (бесконечный): Stream<Integer> fromIterate = Stream.iterate(1, n -> n + 1);
+ С помощью Stream.generate() (бесконечный): Stream<String> fromGenerate = Stream.generate(() -> "0");

<img width="1120" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/a2aa5128-5943-4913-9dff-2e3317e21850">

[к оглавлению](#stream-api)

## Как из коллекции создать стрим?
```java
Collection<String> collection = Arrays.asList("f5", "b6", "z7");
collection.stream();
```
[к оглавлению](#stream-api)

## Какие промежуточные методы в стримах вы знаете?

<img width="1013" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/6ca1dc93-52a7-48b7-90ee-4082973f47ad">

`concat(Stream<? extends T> a, Stream<? extends T> b)`: объединяет два потока.

`distinct()`: возвращает поток, в котором имеются только уникальные данные с типом T (“особый” возвращает только ункальные элементы в виде потока).

`dropWhile(Predicate<? super T> predicate)`: пропускает элементы, которые соответствуют условию в predicate, пока не попадется элемент, который не соответствует условию. Выбранные элементы возвращаются в виде потока. 

`filter(Predicate<? super T> predicate)`: фильтрует элементы в соответствии с условием в предикате. 

`limit(long maxSize)`: оставляет в потоке только maxSize элементов. 

`map(Function<? super T,? extends R> mapper)`: преобразует элементы типа T в элементы типа R и возвращает поток с элементами R.  

Отображение или маппинг позволяет задать функцию преобразования одного объекта в другой, то есть получить из элемента одного типа элемент другого типа. Принимает Function.
```java
<R> Stream<R> map(Function<? super T, ? extends R> mapper);

map(n -> n.toString())
```

`flatMap(Function<? super T, ? extends Stream<? extends R>> mapper)`: позволяет преобразовать элемент типа T в несколько элементов типа R и возвращает поток с элементами R.

Плоское отображение выполняется тогда, когда из одного элемента нужно получить несколько.
```java
Stream

    .of("H e l l o", "w o r l d !")
    .flatMap((p) -> Arrays.stream(p.split(" ")))
    .toArray(String[]::new);//["H", "e", "l", "l", "o", "w", "o", "r", "l", "d", "!"]
```
Например, в примере выше мы выводим название телефона и его цену. Но что, если мы хотим установить для каждого телефона цену со скидкой и цену без скидки. То есть из одного объекта Phone нам надо получить два объекта с информацией, например, в виде строки. Дляэтого применим flatMap:
```java
Stream<Phone> phoneStream = Stream.of(new Phone("iPhone 6 S", 54000), new Phone("Lumia 950", 45000),new Phone("Samsung Galaxy S 6", 40000));

phoneStream
    .flatMap(p->Stream.of(String.format("название: %s  цена без скидки: %d", p.getName(), p.getPrice()), String.format("название: %s  цена со скидкой: %d", p.getName(), p.getPrice()-(int)(p.getPrice()*0.1))))
    .forEach(s->System.out.println(s));
```

**Чем отличаются методы map() и flatMap().**: разница заключается в том, что операция map() создает одно выходное значение для каждого входного значения, тогда как операция flatMap() создает произвольное число (ноль или больше) значений для каждого входного значения.

`skip(long n)`: возвращает поток, в котором отсутствуют первые n элементов. 

`sorted()`: возвращает отсортированный поток. 

Для простой сортировки по возрастанию применяется метод sorted(). Подходит только для сортировки тех объектов, которые реализуют интерфейс Comparable.

Если же у нас классы объектов не реализуют этот интерфейс или мы хотим создать какую-то свою логику сортировки, то мы можем использовать другую версию метода sorted(), которая в качестве параметра принимает компаратор.

`sorted(Comparator<? super T> comparator)`: возвращает отсортированный в соответствии с компаратором поток. 

`takeWhile(Predicate<? super T> predicate)`: выбирает из потока элементы, пока они соответствуют условию в predicate. Выбранные элементы возвращаются в виде потока.

[к оглавлению](#stream-api)

## Методы конвейерные

То же, что и промежуточные

<img width="1129" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/9d405b0e-9309-4c19-978e-47b7e5b43c6b">

В Java 8 и более поздних версиях была добавлена поддержка функционального программирования через Stream API. Stream представляет собой последовательность элементов, которые могут быть обработаны в функциональном стиле. Два из методов, которые вы упомянули - это `map` и `peek`, - используются для преобразования элементов в потоке, но они выполняют разные функции.

1. **map**:
Метод `map` применяет заданную функцию к каждому элементу в потоке и возвращает новый поток, содержащий результаты применения этой функции. Сигнатура метода `map` следующая:
```java
<R> Stream<R> map(Function<? super T, ? extends R> mapper)
```
Здесь `T` - тип элементов в исходном потоке, `R` - тип элементов в новом потоке, а `mapper` - функция, которая преобразует элементы из типа `T` в тип `R`.

Пример:
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
List<Integer> squaredNumbers = numbers.stream()
                                      .map(x -> x * x)
                                      .collect(Collectors.toList());
// squaredNumbers: [1, 4, 9, 16, 25]
```

2. **peek**:
Метод `peek` позволяет выполнить заданную операцию над каждым элементом потока, но в отличие от `map`, `peek` не создает новый поток с преобразованными элементами. Сигнатура метода `peek` следующая:
```java
Stream<T> peek(Consumer<? super T> action)
```
Здесь `T` - тип элементов в потоке, а `action` - действие (Consumer), которое будет выполнено над каждым элементом, но элементы в потоке останутся без изменений.

Пример:
```java
List<String> words = Arrays.asList("apple", "banana", "cherry");
List<String> upperCaseWords = words.stream()
                                   .map(String::toUpperCase)
                                   .peek(System.out::println) // Выводит в верхнем регистре исходные слова
                                   .collect(Collectors.toList());
// upperCaseWords: ["APPLE", "BANANA", "CHERRY"]
```

Таким образом, различие между `map` и `peek` заключается в том, что `map` преобразует элементы и создает новый поток с преобразованными значениями, а `peek` позволяет выполнять операции над элементами, но не изменяет сами элементы и не создает новый поток.

[к оглавлению](#stream-api)

## Методы терминальные

Терминальные методы - это методы, которые завершают выполнение последовательности операций над потоком и возвращают результат. Они представляют конечную точку в потоке, после которой нельзя выполнять промежуточные операции. Терминальные методы запускают выполнение всего потока и обрабатывают элементы.

Метод reduce() выполняет функцию callback один раз для каждого элемента, присутствующего в массиве, за исключением пустот, принимая четыре аргумента: начальное значение (или значение от предыдущего вызова callback ), значение текущего элемента, текущий индекс и массив, по которому происходит итерация.

<img width="1128" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/fb9a194b-c0a0-4d93-bc62-a50a1fa69b35">

collect собирает элементы стрима в новое хранилище, например список

Эта функция представляет объект Collector, который определен в пакете java.util.stream. Java уже предоставляет ряд встроенных функций, определенных в классе Collectors:

+ toList(): преобразование к типу List
+ toSet(): преобразование к типу Set
+ toMap(): преобразование к типу Map
+ groupingBy() - разделяет коллекцию на несколько частей и возвращает Map<N, List<T>>;
+ summingInt(), summingDouble(), summingLong() - возвращает сумму;

Метод `groupingBy()` из Java Stream API используется для группировки элементов потока по определенному критерию и создания Map, где ключами будут значения, по которым происходила группировка, а значениями - списки элементов, удовлетворяющих этому критерию. Вот пример использования метода `groupingBy()`:

Предположим, у нас есть список объектов класса `Person`:

```java
class Person {
    String name;
    int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }
}
```

И мы хотим сгруппировать эти объекты по возрасту. Вот как можно это сделать с использованием `groupingBy()`:

```java
import java.util.*;
import java.util.stream.Collectors;

public class Main {
    public static void main(String[] args) {
        List<Person> people = Arrays.asList(
            new Person("Alice", 25),
            new Person("Bob", 30),
            new Person("Charlie", 25),
            new Person("David", 30)
        );

        Map<Integer, List<Person>> peopleByAge = people.stream()
            .collect(Collectors.groupingBy(Person::getAge));

        System.out.println(peopleByAge);
    }
}
```

В этом примере мы использовали метод `groupingBy()` для группировки объектов класса `Person` по их возрасту. Результатом будет `Map<Integer, List<Person>>`, где ключами будут значения возраста, а значениями будут списки объектов `Person` с соответствующим возрастом. Вывод программы будет примерно таким:

```java
{25=[Person{name='Alice', age=25}, Person{name='Charlie', age=25}],
 30=[Person{name='Bob', age=30}, Person{name='David', age=30}]}
```

Обратите внимание, что `groupingBy()` позволяет группировать элементы по любому критерию. В данном примере использовано поле `age` класса `Person`, но вы можете адаптировать этот код для группировки по другим критериям.
```java
List<String> filteredPhones = phones.stream()

                .filter(s->s.length()<10)

                .collect(Collectors.toList());
```

reduce позволяет выполнять какое-то действие на всей коллекции и возвращать один результат вычислим произведение набора чисел:
```java
Stream<Integer> numbersStream = Stream.of(1,2,3,4,5,6);

        Optional<Integer> result = numbersStream.reduce((x,y)->x*y);

        System.out.println(result.get()); // 720
```
[к оглавлению](#stream-api)

## Методы числовых стримов

Это специальные методы, которые работают только со стримами с числовыми примитивами.

<img width="1112" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/22cf2e8b-a377-49f0-9668-13d3c1ba0026">

В Java для числовых стримов существует несколько специфических методов, которые не применимы к обычным стримам объектов. Эти методы позволяют работать с числовыми данными более эффективно и удобно. Вот некоторые из таких методов, которые используются только в числовых стримах:

1. **sum()**: Вычисляет сумму всех числовых элементов стрима.

   ```java
   int sum = intStream.sum();
   long sum = longStream.sum();
   ```

2. **average()**: Вычисляет среднее значение числовых элементов стрима.

   ```java
   OptionalDouble average = doubleStream.average();
   ```

3. **min() / max()**: Находят минимальное и максимальное значение числовых элементов стрима.

   ```java
   OptionalInt min = intStream.min();
   OptionalLong max = longStream.max();
   OptionalDouble max = doubleStream.max();
   ```

4. **mapToInt() / mapToLong() / mapToDouble()**: Преобразуют элементы стрима в числовой тип.

   ```java
   IntStream intStream = someStream.mapToInt(element -> /* convert to int */);
   LongStream longStream = someStream.mapToLong(element -> /* convert to long */);
   DoubleStream doubleStream = someStream.mapToDouble(element -> /* convert to double */);
   ```

5. **summaryStatistics()**: Возвращает статистическую информацию о числовых элементах стрима, такую как количество элементов, сумма, минимум, максимум, среднее и др.

   ```java
   IntSummaryStatistics statistics = intStream.summaryStatistics();
   LongSummaryStatistics statistics = longStream.summaryStatistics();
   DoubleSummaryStatistics statistics = doubleStream.summaryStatistics();
   ```

6. **boxed()**: Преобразует числовой стрим в стрим объектов. Это полезно, если вы хотите использовать общие операции стримов для числовых данных.

   ```java
   Stream<Integer> objectStream = intStream.boxed();
   Stream<Long> objectStream = longStream.boxed();
   Stream<Double> objectStream = doubleStream.boxed();
   ```

Это некоторые из основных методов, доступных только для числовых стримов в Java. Они позволяют упростить работу с числами и выполнить разнообразные операции над ними с помощью функционального подхода, предоставляемого стримами.

Еще можно добавить 
asDoubleStream(), asLongStream() (у самого лонга только метод double, у doubleStream вообще таких методов нет)

mapToDouble(IntToDoubleFunction mapper) - Returns a DoubleStream consisting of the results of applying the given function to the elements of this stream.

mapToLong(IntToLongFunction mapper) - Returns a LongStream consisting of the results of applying the given function to the elements of this stream.

[к оглавлению](#stream-api)

## Расскажите про класс Collectors и его методы.

https://www.youtube.com/watch?v=HOQpQWK9u28

`public final class Collectors extends Object`

Реализации интерфейса Collector, реализующие различные полезные операции редукции, такие как накопление элементов в коллекции, суммирование элементов по различным критериям и т. д. Методы этого класса значительно упрощают использование аккумулирующих терминальных методов. Рассмотрим методы по группам.

Методы для сбора коллекций. Предназначены для сбора элементов потока в ту или иную реализацию интерфейса Collector.

<img width="1116" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/14a76a4b-3d2e-4769-9ab4-9205441528ff">

<img width="1141" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/7e63ce16-6147-44dc-8ff8-e8a42799e388">

**Методы для сбора элементов потока в Map**

Три вида Map можем получить:
+	Обычную изменяемую карту (первые три метода)
+	Неизменяемая карта (следующие два метода)
+	Поток безопасная карта (следующие три метода)

<img width="1125" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/b3240b70-59c8-4914-a3b7-48b3a7ccdc5c">

<img width="1130" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/cfe94020-d68a-48ee-9c9b-a5b23b0a7ba5">

<img width="1113" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/6595c6cd-92bc-4cca-8643-f205668ee464">

<img width="1131" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/e4a4d10e-5150-4dbb-a6ae-3e3f75a22566">

<img width="1132" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/26b0d7ae-4126-4791-8381-0bfc2b13f0be">

<img width="1127" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/9dc93c83-2870-4257-842b-c191760c5515">

<img width="1143" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/b36d3be9-9830-493a-bb0c-d2782879462b">

Метод `joining()` является частью класса `Collectors` из Java Stream API и позволяет объединить элементы потока в одну строку, используя заданный разделитель (delimiter). Этот метод часто используется для создания текстовых представлений коллекций элементов или объектов.
```java
import java.util.*;
import java.util.stream.Collectors;

public class Main {
    public static void main(String[] args) {
        List<String> fruits = Arrays.asList("apple", "banana", "cherry", "date");

        String greetingWithFruits = fruits.stream()
            .collect(Collectors.joining(", ", "Hello ", "!"));

        System.out.println(greetingWithFruits);
    }
}
```

В данном примере, метод `joining()` объединяет элементы списка `fruits` с использованием запятой и пробела в качестве разделителя. Префиксом объединенной строки является "Hello ", а суффиксом - "!". Результат будет следующим:

```java
Hello apple, banana, cherry, date!
```

Здесь "Hello " добавляется перед списком фруктов, а восклицательный знак "!" добавляется после всего списка.

В Java 8 в классе Collectors реализовано несколько распространённых коллекторов:

+ toList(), toCollection(), toSet() - представляют стрим в виде списка, коллекции или множества;
+ toConcurrentMap(), toMap() - позволяют преобразовать стрим в Map;
+ averagingInt(), averagingDouble(), averagingLong() - возвращают среднее значение;
+ summingInt(), summingDouble(), summingLong() - возвращает сумму;
+ summarizingInt(), summarizingDouble(), summarizingLong() - возвращают SummaryStatistics сразными агрегатными значениями;
+ partitioningBy() - разделяет коллекцию на две части по соответствию условию и возвращает их как Map<Boolean, List>;
+ groupingBy() - разделяет коллекцию на несколько частей и возвращает Map<N, List<T>>;
+ mapping() - дополнительные преобразования значений для сложных Collector-ов.

Так же существует возможность создания собственного коллектора через Collector.of():
```java
Collector<String, List<String>, List<String>> toList = Collector.of(

    ArrayList::new,
    List::add,
    (l1, l2) -> { l1.addAll(l2); return l1; }

);
```
[к оглавлению](#stream-api)

## Расскажите о параллельной обработке в Java 8.

Стримы могут быть последовательными и параллельными. Операции над последовательными стримами выполняются в одном потоке процессора, над параллельными — используя несколько потоков процессора. Параллельные стримы используют общий ForkJoinPool доступный через статический ForkJoinPool.commonPool() метод. При этом, если окружение не является многоядерным, то поток будет выполняться как последовательный. Фактически применение параллельных стримов сводится к тому, что данные в стримах будут разделены на части, каждая часть обрабатывается на отдельном ядре процессора, и в конце эти части соединяются, и над ними выполняются конечные операции.

`ForkJoinPool` - это специальный вид пула потоков в Java, предназначенный для выполнения задач, которые могут быть разделены на более мелкие подзадачи (рекурсивное разделение и объединение). Он представляет собой реализацию пула потоков, оптимизированную для выполнения такого типа задач.

`ForkJoinPool` был представлен в Java 7 как часть пакета `java.util.concurrent`, и он предоставляет механизм для параллельного выполнения задач с использованием принципа "разделяй и властвуй". Этот механизм позволяет автоматически распределять подзадачи между потоками и эффективно использовать доступные ядра процессора.

Главные особенности `ForkJoinPool`:

1. **Рекурсивное разделение**: Задачи в пуле разделяются на более мелкие подзадачи до достижения определенного порога. Это позволяет эффективно использовать ресурсы процессора и уровень параллельности.

2. **Работающие потоки**: `ForkJoinPool` динамически управляет количеством потоков в пуле, основываясь на доступных ресурсах процессора и нагрузке. Это позволяет избежать создания избыточного количества потоков.

3. **Work-Stealing**: Это особенность, которая позволяет не занятым потокам "украсть" задачи из очереди других потоков. Это помогает балансировать нагрузку между потоками и увеличивает эффективность пула потоков.

Пример использования `ForkJoinPool` может включать в себя реализацию задачи, которая делится на подзадачи и выполняется параллельно:

```java
import java.util.concurrent.*;

public class ForkJoinExample extends RecursiveTask<Integer> {
    private static final int THRESHOLD = 10;

    private final int[] array;
    private final int start;
    private final int end;

    public ForkJoinExample(int[] array, int start, int end) {
        this.array = array;
        this.start = start;
        this.end = end;
    }

    @Override
    protected Integer compute() {
        if (end - start <= THRESHOLD) {
            int sum = 0;
            for (int i = start; i < end; i++) {
                sum += array[i];
            }
            return sum;
        } else {
            int middle = (start + end) / 2;
            ForkJoinExample leftTask = new ForkJoinExample(array, start, middle);
            ForkJoinExample rightTask = new ForkJoinExample(array, middle, end);
            leftTask.fork();
            int rightResult = rightTask.compute();
            int leftResult = leftTask.join();
            return leftResult + rightResult;
        }
    }

    public static void main(String[] args) {
        int[] array = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        ForkJoinPool pool = new ForkJoinPool();
        ForkJoinExample task = new ForkJoinExample(array, 0, array.length);
        int result = pool.invoke(task);
        System.out.println("Sum: " + result);
    }
}
```

В этом примере задача разбивается на подзадачи рекурсивно, и каждая подзадача выполняется в параллельном потоке `ForkJoinPool`. Когда подзадачи завершаются, их результаты объединяются в итоговый результат.

Для создания параллельного потока из коллекции можно также использовать метод parallelStream() интерфейса Collection.

Чтобы сделать обычный последовательный стрим параллельным, надо вызвать у объекта Stream метод parallel(). Метод isParallel() позволяет узнать является ли стрим параллельным.

С помощью, методов parallel() и sequential() можно определять какие операции могут быть параллельными, а какие только последовательными. Так же из любого последовательного стрима можно сделать параллельный и наоборот:
```java
collection.stream()

.peek(...) // операция последовательна

.parallel()

.map(...) // операция может выполняться параллельно,

.sequential()

.reduce(...) // операция снова последовательна 
```
Как правило, элементы передаются в стрим в том же порядке, в котором они определены в источнике данных. При работе с параллельными стримами система сохраняет порядок следования элементов.

Исключение составляет метод forEach(), который может выводить элементы в произвольном порядке. И чтобы сохранить порядок следования, необходимо применять метод forEachOrdered().

Критерии, которые могут повлиять на производительность в параллельных стримах:

+ Размер данных - чем больше данных, тем сложнее сначала разделять данные, а потом их соединять.
+ Количество ядер процессора. Теоретически, чем больше ядер в компьютере, тем быстрее программа будет работать. Если на машине одно ядро, нет смысла применять параллельные потоки.
+ Чем проще структура данных, с которой работает поток, тем быстрее будут происходить операции. Например, данные из ArrayList легко использовать, так как структура данной коллекции предполагает последовательность несвязанных данных. А вот коллекция типа LinkedList - нелучший вариант, так как в последовательном списке все элементы связаны с предыдущими/последующими. И такие данные трудно распараллелить.
+ Над данными примитивных типов операции будут производиться быстрее, чем над объектами классов.
+ Крайне не рекомендуется использовать параллельные стримы для скольких-нибудь долгих операций (например, сетевых соединений), так как все параллельные стримы работают c одним ForkJoinPool, то такие долгие операции могут остановить работу всех параллельных стримов в JVM из-за отсутствия доступных потоков в пуле, т.е. параллельные стримы стоит использовать лишь для коротких операций, где счет идет на миллисекунды, но не для тех где счет может идти на секунды и минуты;
+ Сохранение порядка в параллельных стримах увеличивает издержки при выполнении и если порядок не важен, то имеется возможность отключить его сохранение и тем самым увеличить производительность, использовав промежуточную операцию unordered():
```java
collection.parallelStream()

    .sorted()
    .unordered()
    .collect(Collectors.toList());
```

В Java бывают еще и параллельные стримы, обрабатывающие свои элементы одновременно в нескольких потоках.

Рассмотрим несколько полезных методов, которые помогают управлять последовательными и параллельными стримами — как минимум быстро их определять.

<img width="1126" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/fc289edd-0f3c-4827-9dbb-e591af9973e7">

Стримы могут быть последовательными и параллельными. Первые выполняются в текущем потоке, вторые используют общий пул ForkJoinPool.commonPool()

В параллельном стриме элементы разделяются на группы. Их обработка проходит в каждом потоке по отдельности. Затем они снова объединяются, чтобы вывести результат. С помощью методов parallel и sequential можно явно указать, что нужно сделать параллельным, а что — последовательным.

Не рекомендуется применять параллельность для выполнения долгих операций (например, извлечения данных из базы), потому что все стримы работают с общим пулом. Долгие операции могут остановить работу всех параллельных стримов в Java Virtual Machine из-за того, что в пуле не останется доступных потоков.

Чтобы избежать такой проблемы, используйте параллельные стримы только для коротких операций, выполнение которых занимает миллисекунды, а не секунды и тем более минуты.

В Stream API по умолчанию скрыта работа с поток небезопасными коллекциями, разделение на части и объединение элементов. Это отличное решение. Разработчику остается только выбирать нужные методы и следить за тем, чтобы не было зависимостей от внешних факторов.

[к оглавлению](#stream-api)

## Что такое IntStream и DoubleStream?

Кроме универсальных объектных существуют особые виды стримов для работы с примитивными типами данных int, long и double: IntStream, LongStream и DoubleStream. Эти примитивные стримы работают так же, как и обычные объектные, но со следующими отличиями:
+ используют специализированные лямбда-выражения, например, IntFunction или IntPredicate вместо Function и Predicate;
+ поддерживают дополнительные конечные операции sum(), average(), mapToObj()

Существуют специализированные stream-ы: IntStream, LongStream, DoubleStream.

У них есть все методы, что и в обычном Stream, но также существуют дополнительные методы: average, sum, min, max, range и другие.

Эти stream-ы специально созданы для примитивных типов, так как обычный Stream работает с объектами, а значит, в нем будут накладные расходы на автоупаковку и автораспаковку. Специализированные stream-ы есть только для int, long и double. Для других примитивных типов специализированных stream-ов нет.

<img width="1126" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/b910f80a-9ca7-44e1-9791-00412a13e15f">

<img width="1126" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/c5303440-efd1-40e6-8b07-69b390512006">

[к оглавлению](#stream-api)
