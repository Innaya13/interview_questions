# Дженерики

+ [Что такое дженерики?](#что-такое-дженерики)
+ [Для чего нужны дженерики?](#для-чего-нужны-дженерики)
+ [Что такое сырые типы (raw type)?](#что-такое-сырые-типы-raw-type)
+ [Что такое вайлдкарды?](#что-такое-вайлдкарды)
+ [Расскажите про принцип PECS](#расскажите-про-принцип-pecs)

## Что такое дженерики?

Дженерики — это типы с параметром.

В дженериках используются термины "параметр" и "аргумент", их значения следующие:

Параметр в дженериках (generic parameter) - это обобщенный тип данных, который задается при объявлении класса, интерфейса или метода. Параметр позволяет создать обобщенный код, который может работать с разными типами данных без явного указания конкретного типа.

Аргумент в дженериках (generic argument) - это конкретный тип данных, который передается при создании экземпляра обобщенного класса или при вызове обобщенного метода. Аргумент используется для замены параметра типа на конкретный тип данных во время компиляции. 

Таким образом, параметр типа задается при объявлении, аргумент типа используется при создании экземпляра или вызове метода, чтобы указать конкретный тип данных, с которым будет работать обобщенный код.

При создании дженерика ты указываешь не только его тип, но и тип данных, с которыми он должен работать.

Generics - набор свойств языка позволяющих определять и использовать обобщенные типы и методы.

Обобщенные типы или методы отличаются от обычных тем, что имеют типизированные параметры (T – параметр в котором могут быть разные объекты).
```java
ArrayList<Integer> list = new ArrayList<Integer>();
```
Свойства Generics:
+ Строгая типизация.
+ Единая реализация.
+ Отсутствие информации о типе.

Ограничения: 
+ в <> могут быть только ссылочные типы, можно String, Integer, а также массивы, например, int [];
+ внутри класса или метода нельзя создать экземпляр класса, массив или использовать метод equals, так как внутри класса не известно о самом классе – компилятор не может понять тип
+ ограничение наследования. Пусть у нас есть тип Foo, который является подтипом Bar, и еще G - наследник Коллекции. То `G<Foo>` не является наследником `G<Bar>`.
+ не может быть параметром статического класса
+ Не может Создать, Поймать, или Бросить Объекты Параметризованных Типов
```java
class MathException<T> extends Exception { /* ... */ }  // compile-time error
```
У class не может быть двух перегруженных методов, у которых будет та же самая сигнатура после стирания типа.
```java
public class Example {

  public void print(Set<String> strSet) { }

  public void print(Set<Integer> intSet) { }

}
```
Примером использования обобщенных типов может служить Java Collection Framework.

Так, класс LinkedList<E> - типичный обобщенный тип. Он содержит параметр E, который представляет тип элементов, которые будут храниться в коллекции.

Создание объектов обобщенных типов происходит посредством замены параметризированных типов реальными типами данных. Вместо того, чтобы просто использовать LinkedList, ничего не говоря о типе элемента в списке, предлагается использовать точное указание типа LinkedList<String>, LinkedList<Integer> и т.п.

В Java дженерики — это механизм, который позволяет создавать обобщенные классы, интерфейсы и методы. Они позволяют параметризовать типы данных, которые используются внутри этих конструкций, чтобы достичь большей гибкости и безопасности во время компиляции.

Дженерики позволяют создавать классы и методы, которые могут работать с различными типами данных, не указывая конкретный тип в самом коде. Вместо этого типы передаются в виде параметров, которые указываются в угловых скобках (`<>`).

Преимущества использования дженериков включают:

1. Безопасность типов: Дженерики позволяют обнаруживать ошибки типов на этапе компиляции, что помогает предотвратить ошибки времени выполнения.
2. Повышение переиспользуемости: Дженерики позволяют создавать обобщенные алгоритмы и структуры данных, которые могут быть использованы с различными типами данных.
3. Улучшение читаемости кода: Использование дженериков позволяет программистам указывать намерения и ожидания относительно типов данных, с которыми работает код.

Пример использования дженериков в Java:

```java
public class Box<T> {
    private T value;

    public void setValue(T value) {
        this.value = value;
    }

    public T getValue() {
        return value;
    }
}

// Использование дженериков
Box<Integer> integerBox = new Box<>();
integerBox.setValue(10);
int value = integerBox.getValue();
```

В приведенном примере `Box` является обобщенным классом с параметром типа `T`. Параметр типа `T` может быть заменен на конкретный тип данных при создании объекта `Box`. В данном случае `Box<Integer>` будет работать только с объектами типа `Integer`.

[к оглавлению](#дженерики)

## Для чего нужны дженерики?

Позволяет осуществлять проверку на правильность написания кода во время компиляции, а не в Runtime. Возможность создавать универсальные алгоритмы и структуры данных.

Сделали использование Java Collection Framework проще, удобнее и безопаснее.

С их помощью можно объявлять классы, интерфейсы и методы, где тип данных указан в виде параметра. generics (обобщенные типы и методы) позволяют нам уйти от жесткого определения используемых типов.

Компилятор стирает все дженерики. В Runtime дженериков практически нет. Компилятор использует кастование 

Дженерики в Java имеют несколько важных применений:

1. Безопасность типов: Дженерики позволяют обнаруживать ошибки типов на этапе компиляции, что помогает предотвратить ошибки времени выполнения. Компилятор проверяет соответствие типов данных во время компиляции, и если типы не совпадают, будет выдана ошибка. Это помогает исключить ошибки, связанные с неправильным использованием типов данных.

2. Повышение переиспользуемости: Дженерики позволяют создавать обобщенные алгоритмы и структуры данных, которые могут быть использованы с различными типами данных. Например, обобщенные коллекции, такие как `ArrayList<T>` или `HashMap<K, V>`, могут работать с любыми типами данных, что делает их универсальными и переиспользуемыми.

3. Улучшение читаемости кода: Использование дженериков позволяет программистам указывать намерения и ожидания относительно типов данных, с которыми работает код. Это делает код более ясным и понятным для других разработчиков, которые могут использовать или поддерживать этот код в будущем.

4. Избежание приведения типов: Дженерики позволяют избежать необходимости явного приведения типов данных. Когда объекты извлекаются из обобщенных коллекций или возвращаются из обобщенных методов, типы данных сохраняются и не требуют дополнительных приведений типов.

5. Повышение производительности: Дженерики могут помочь повысить производительность, поскольку избегаются ненужные приведения типов данных. Вместо использования общего типа `Object`, дженерики позволяют работать с конкретными типами данных, что может улучшить производительность программы. - спорный момент, так как компилятор все равно делает кастование (из-за стирания типов).

В целом, дженерики предоставляют мощный инструмент для создания гибкого и безопасного кода. Они позволяют программистам указывать намерения относительно типов данных, с которыми работает код, и предотвращают ошибки типов на этапе компиляции, что упрощает разработку и поддержку программного обеспечения.

[к оглавлению](#дженерики)

## Что такое сырые типы (raw type)?

Сырые типы (raw types) в Java - это необобщенные версии обобщенных типов данных (generics). Они представляют собой типы данных, в которых не указаны параметры типа. Сырые типы были введены в язык Java для обратной совместимости с предыдущими версиями, которые не поддерживали обобщения.

Когда обобщенный тип используется без указания параметра типа, компилятор предупреждает о использовании сырого типа и рекомендует использовать параметризованный тип. Однако, если игнорировать это предупреждение и использовать сырой тип, компилятор не будет выполнять проверку типов для объектов, связанных с этим типом, что может привести к ошибкам времени выполнения.

Например, у нас есть обобщенный класс `List<E>`, представляющий список элементов типа `E`. Если мы используем сырой тип `List` вместо `List<String>`, компилятор не будет выполнять проверку типов при добавлении или извлечении элементов из списка. Это может привести к ошибкам времени выполнения, если мы попытаемся извлечь элемент как `String`, когда на самом деле это будет другой тип.

Использование сырых типов не рекомендуется, поскольку они нарушают безопасность типов, которую обеспечивают обобщения. Вместо этого рекомендуется использовать параметризованные типы, чтобы получить преимущества безопасности типов и повысить читаемость и поддерживаемость кода.

Сырые типы — это дженерики (обобщенные) типы без указания \"уточненения\" в фигурных скобках.

Нужны чтобы поддерживать старый код (обратная совместимость). Рекомендуется использовать хоть какие-то параметризованные типы (в современном коде; иначе какой смысл тогда в дженериках).

Также Diamond синтаксис связан с понятием \"Type Inference\", или же выведение типов. Ведь компилятор, видя справа <> смотрит на левую часть, где расположено объявление типа переменной, в которую присваивается значение. И по этой части понимает, каким типом типизируется значение справа. 
```java
List<String> list = new ArrayList<>(); 
```
На самом деле, если в левой части указан дженерик, а справа не указан <>, компилятор сможет вывести тип. Однако это будет смешиванием нового стиля с дженериками и старого стиля без них - вы теряете безопасность (типобезопасность) типов (может добавляться какой угодно тип в список, а не то что надо. Когда будет доставаться – то может быть сюрприз)))
```java
ArrayList<String> strings = new ArrayList<>(); // parameterized type

ArrayList arrayList = new ArrayList(); // raw type

arrayList = strings; // Ok

strings = arrayList; // Unchecked assignment (назначение)

arrayList.add(1); //unchecked call
```
[к оглавлению](#дженерики)

## Что такое вайлдкарды?

https://ru.stackoverflow.com/questions/1128951/java-generics-%D0%92-%D1%87%D0%B5%D0%BC-%D1%80%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D0%B0-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-wildcard-%D0%B8-parameterized-typest

https://stackoverflow.com/questions/3486689/java-bounded-wildcards-or-bounded-type-parameter

https://www.youtube.com/watch?v=ns8T7-nI_Ec

Языковая конструкция внутри даймонд-оператора, позволяющая сделать код более универсальным.

Решает проблему наследования типов в дженериках. (коллекция `<Integer>` не наследник коллекции `<Number>`)
```java
Может быть 3-х типов: инвариантность, upper и lower

Class: Cat / Dog -> Pet -> Animal -> Object

<? extends Animal> - тип ? является любой наследник Animal (Upper Bounded (ограничение сверху) Wildcards)

<? super Cat> - тип ? является любой родитель Cat, включая Cat (Lower Bounded Wildcards). Dog не подходит
```

Вайлдкарды (wildcards) в Java - это механизм, который позволяет создавать более гибкие обобщенные типы данных. Они представляют символ вопросительного знака `?`, который может быть использован в качестве аргумента типа при объявлении обобщенного типа, метода или подстановочного типа (wildcard type).

Вайлдкарды используются для работы с неизвестными типами данных или для ограничения типовых параметров. Они позволяют создавать обобщенные типы, которые могут работать с различными типами данных, не указывая конкретный тип. Вайлдкарды могут быть ограничены верхней границей (upper bound), нижней границей (lower bound) или без границы.

Существуют три вида вайлдкардов в Java:

1. `?` - неограниченный вайлдкард (unbounded wildcard): Обозначается символом `?` без указания верхней или нижней границы. Это позволяет использовать любой тип данных вместо вайлдкарда.

2. `? extends Тип` - вайлдкард с верхней границей (wildcard with upper bound): Обозначается символом `?`, за которым следует ключевое слово `extends` и указание типа. Это означает, что вайлдкард может быть любым типом, который является подтипом указанного типа или самим указанным типом.

3. `? super Тип` - вайлдкард с нижней границей (wildcard with lower bound): Обозначается символом `?`, за которым следует ключевое слово `super` и указание типа. Это означает, что вайлдкард может быть любым типом, который является супертипом указанного типа или самим указанным типом.

Вайлдкарды позволяют создавать гибкие обобщенные типы, которые могут работать с различными типами данных. Они особенно полезны при работе с коллекциями, когда требуется гибкость в типах элементов.

[к оглавлению](#дженерики) 

## Расскажите про принцип PECS

The Get and Put Principle или PECS (Producer Extends Consumer Super) Get and Put Principe

Из одного типа переменных можно только читать, в другой — только вписывать (исключением является возможность записать null для extends и прочитать Object для super). 

<?> Запись вида Collection < ? > равносильна Collection < ? extends Object > , а значит — коллекция может содержать объекты любого класса, так как все классы в Java наследуются от Object – поэтому подстановка называется неограниченной.

+ Ковариация - Если мы объявили wildcard с extends, то это producer. Он только «продюсирует», предоставляет элемент из контейнера, а сам ничего не принимает.
+ Контрвариация - Если же мы объявили wildcard с super — то это consumer. Он только принимает, а предоставить ничего не может.

Если метод имеет аргументы с параметризованным типом (например, Collection или Predicate), то в случае, если аргумент - производитель (producer), нужно использовать ? extends T, а если аргумент - потребитель (consumer), нужно использовать ? super T.

Eсли метод читает данные из аргумента, то этот аргумент - производитель. 

Метод передаёт данные в аргумент, то аргумент является потребителем.

Важно заметить, что определяя производителя или потребителя, мы рассматриваем только данные типа T.

Ковариантность — это сохранение иерархии наследования исходных типов в производных типах в том же порядке

Множество<Животные> = Множество<Кошки>

Контравариантность — это обращение иерархии исходных типов на противоположную в производных типах

Множество<Кошки> = Множество<Животные>

Принцип PECS (Producer Extends, Consumer Super) - это руководящий принцип, связанный с использованием вайлдкардов в Java для обеспечения безопасности типов при работе с обобщенными коллекциями.

Принцип PECS гласит:

- Если вы только берете элементы из коллекции (т.е. используете их только в качестве источника данных), то используйте верхнюю границу (`? extends Тип`) для обеспечения безопасности типов.

- Если вы только кладете элементы в коллекцию (т.е. используете их только в качестве приемника данных), то используйте нижнюю границу (`? super Тип`) для обеспечения безопасности типов.

Этот принцип помогает определить, какой вайлдкард следует использовать в различных ситуациях.

Когда вы берете элементы из коллекции, вы не знаете точный тип элементов, которые будут возвращены, но вы знаете, что они являются подтипами определенного типа. В этом случае следует использовать вайлдкард с верхней границей (`? extends Тип`), чтобы обеспечить безопасность типов. Например, `List<? extends Number>` означает, что список может содержать элементы, которые являются подтипами `Number`.

Когда вы кладете элементы в коллекцию, вы хотите, чтобы коллекция могла принимать элементы любого типа или его супертипа. В этом случае следует использовать вайлдкард с нижней границей (`? super Тип`), чтобы обеспечить безопасность типов. Например, `List<? super Integer>` означает, что список может принимать элементы типа `Integer` или его супертипы.

Применение принципа PECS позволяет более безопасно работать с обобщенными коллекциями, предотвращая ошибки типов и обеспечивая гибкость в использовании различных типов элементов.

В контексте программирования Java, PECS означает Producer-Extends, Consumer-Super. Это концепция, связанная с использованием дженериков (generics) в Java для обеспечения безопасности типов.

PECS указывает на правила использования дженериков в разных ситуациях:

1. Producer-Extends (производитель-наследник): Если вы хотите использовать коллекцию только для чтения элементов, то используйте ключевое слово `extends`. Например:

```java
public void printList(List<? extends Number> list) {
    for (Number n : list) {
        System.out.println(n);
    }
}
```

В этом примере метод `printList` принимает список, содержащий элементы, которые являются наследниками класса `Number`. Вы можете передать список `List<Integer>`, `List<Double>` или любой другой список, содержащий элементы `Number`. Однако, вы не можете добавлять элементы в такую коллекцию, потому что неизвестно, какой конкретный тип наследников `Number` может быть передан.

2. Consumer-Super (потребитель-родитель): Если вы хотите использовать коллекцию только для добавления элементов, то используйте ключевое слово `super`. Например:

```java
public void addNumbers(List<? super Integer> list) {
    list.add(10);
    list.add(20);
}
```

В этом примере метод `addNumbers` принимает список, в который можно добавлять элементы типа `Integer` или его супертипы. Вы можете передать список `List<Integer>`, `List<Number>`, `List<Object>` и добавлять в него элементы типа `Integer`. Однако, вы не можете читать элементы из такой коллекции, потому что неизвестно, какой конкретный тип может быть передан.

Таким образом, PECS предоставляет рекомендации по использованию дженериков в зависимости от того, являетесь ли вы производителем (только для чтения) или потребителем (только для записи) элементов коллекции.

-------------------------
Помимо ошибок при компиляции:

+ Что будет, если я начну писать в коллекцию List<? extends Animal>? 

В коллекцию смогут попасть объекты и типа Dog, и типа Cat.

+ Что произойдет, если я начну читать из коллекции List<? super Dog>?

Будут ошибки из-за отсутствия кастования (вроде бы). 

[к оглавлению](#дженерики) 
