# Spring

+ [1.	Из каких основных сущностей состоит Spring-приложение?](#1из-каких-основных-сущностей-состоит-spring-приложение)
+ [2.	Что такое инверсия контроля (IoC) и внедрение зависимостей (DI)?](#2что-такое-инверсия-контроля-ioc-и-внедрение-зависимостей-di)
+ [3.	Как эти принципы реализованы в Spring?](#3как-эти-принципы-реализованы-в-spring)
+ [4.	Что такое IoC контейнер?](#4что-такое-ioc-контейнер)
+ [5.	Что такое Bean в спринге?](#5что-такое-bean-в-спринге)
+ [6.	Расскажите про аннотацию @Bean?](#6расскажите-про-аннотацию-bean)
+ [7.	Расскажите про аннотацию @Component?](#7-расскажите-про-аннотацию-component)
+ [8.	Чем отличаются аннотации @Bean и @Component?](#8чем-отличаются-аннотации-bean-и-component)
+ [9.	Расскажите про аннотации @Service и @Repository. Чем они отличаются?](#9расскажите-про-аннотации-service-и-repository-чем-они-отличаются)
+ [10.	Расскажите про аннотацию @Autowired](#10расскажите-про-аннотацию-autowired)
+ [11.	Расскажите про аннотацию @Resource](#11расскажите-про-аннотацию-resource)
+ [12.	Расскажите про аннотацию @Inject](#12расскажите-про-аннотацию-inject)
+ [13.	Расскажите про аннотацию @Lookup](#13расскажите-про-аннотацию-lookup)
+ [14.	*Как работает инъекция прототипа в синглтон?](#14как-работает-инъекция-прототипа-в-синглтон)
+ [15.	Можно ли вставить бин в статическое поле? Почему?](#15можно-ли-вставить-бин-в-статическое-поле-почему)
+ [16.	Расскажите про аннотации @Primary и @Qualifier](#16расскажите-про-аннотации-primary-и-qualifier)
+ [17.	Как заинжектить примитив?](#17как-заинжектить-примитив)
+ [18.	Как заинжектить коллекцию?](#18как-заинжектить-коллекцию)
+ [19.	Расскажите про аннотацию @Conditional](#19расскажите-про-аннотацию-conditional)
+ [20.	Расскажите про аннотацию @Profile](#20расскажите-про-аннотацию-profile)
+ [21.	Расскажите про ApplicationContext и BeanFactory, чем отличаются? В каких случаях что стоит использовать?](#21расскажите-про-applicationcontext-и-beanfactory-чем-отличаются-в-каких-случаях-что-стоит-использовать)
+ [22.	Расскажите про жизненный цикл бина, аннотации @PostConstruct и @PreDestroy](#22расскажите-про-жизненный-цикл-бина-аннотации-postconstruct-и-predestroy)
+ [23.	Расскажите про скоупы бинов? Какой скоуп используется по умолчанию?](#23расскажите-про-скоупы-бинов-какой-скоуп-используется-по-умолчанию)
+ [24.	Что изменилось в пятом спринге?](#24что-изменилось-в-пятом-и-шестом-спринге)
+ [25.	Расскажите про аннотацию @ComponentScan](#25расскажите-про-аннотацию-componentscan)
+ [26.	Как спринг работает с транзакциями?](#26как-спринг-работает-с-транзакциями)
+ [27.	Расскажите про аннотацию @Transactional](#27расскажите-про-аннотацию-transactional)
+ [28.	Расскажите про аннотации @Controller и @RestController. Чем они отличаются?](#28расскажите-про-аннотации-controller-и-restcontroller-чем-они-отличаются)
+ [29.	Как вернуть ответ со своим статусом (например, 213)?](#29как-вернуть-ответ-со-своим-статусом-например-213)
+ [30.	Что такое ViewResolver?](#30что-такое-viewresolver)
+ [31.	Чем отличаются Model, ModelMap и ModelAndView?](#31чем-отличаются-model-modelmap-и-modelandview)
+ [32.	Расскажите про паттерн MVC, как он реализован в Spring?](#32расскажите-про-паттерн-mvc-как-он-реализован-в-spring)
+ [33.	Расскажите про паттерн Front Controller, как он реализован в Spring?](#33расскажите-про-паттерн-front-controller-как-он-реализован-в-spring)
+ [34.	Что такое AOP? Как реализовано в спринге?](#34что-такое-aop-как-реализовано-в-спринге)
+ [35.	PROXY что это, для чего и как применяется в Spring](#35proxy-что-это-для-чего-и-как-применяется-в-spring)
+ [36.	В чем разница между Filters, Listeners and Interceptors?](#36в-чем-разница-между-filters-listeners-and-interceptors)
+ [37.	Можно ли передать в запросе один и тот же параметр несколько раз? Как?](#37-можно-ли-передать-в-запросе-один-и-тот-же-параметр-несколько-раз-как)
+ [38.	Как работает Spring Security? Как сконфигурировать? Какие интерфейсы используются?](#38как-работает-spring-security-как-сконфигурировать-какие-интерфейсы-используются)
+ [39.	Что такое SpringBoot? Какие у него преимущества? Как конфигурируется? Подробно.](#39что-такое-springboot-какие-у-него-преимущества-как-конфигурируется-подробно)
+ [40.	Какие задачи решает Spring Data?](#40какие-задачи-решает-spring-data)
+ [41.	Какова иерархия интерфейсов/классов репозитория в Spring Data JPA?](#41какова-иерархия-интерфейсовклассов-репозитория-в-spring-data-jpa)
+ [42.	*Как преодолеть проблему блокирующих вызовов?](#42как-преодолеть-проблему-блокирующих-вызовов)
+ [43.	Как вызвать транзакционный метод из того же класса?](#43как-вызвать-транзакционный-метод-из-того-же-класса)
+ [44.	*Когда отрабатывает @Autowired а когда @Transactional? почему?](#44когда-отрабатывает-autowired-а-когда-transactional-почему-почему-нельзя-отработать-transactional-в-другом-методе)
+ [45.	Почему нельзя отработать @Transactional в другом методе?](#44когда-отрабатывает-autowired-а-когда-transactional-почему-почему-нельзя-отработать-transactional-в-другом-методе)
+ [46.	Структура HTTP запроса, ответа](#46структура-http-запроса-ответа)
+ [47.	HTTP методы](#47http-методы)
+ [48.	Ключевое отличие методов POST и GET](#48ключевое-отличие-методов-post-и-get)
+ [49.	REST стиль](#49rest-стиль)
+ [50.	Идемпотентность: что это такое, методы](#50идемпотентность-что-это-такое-методы)
+ [51.	Как метод пост сделать идемпотентным?](#51как-метод-пост-сделать-идемпотентным)
+ [Дополнительные вопросы из интернета](#дополнительные-вопросы-из-интернета)


## 1.	Из каких основных сущностей состоит Spring-приложение?

<img width="932" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/302f600e-b5eb-4716-bd8e-354e26a9cab0">

https://m-dev.space/notes/%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5-%D1%81%D1%83%D1%89%D0%BD%D0%BE%D1%81%D1%82%D0%B8-Spring-Framework

Почему ApplicationContext, а не BeanFactory - https://stackoverflow.com/questions/243385/beanfactory-vs-applicationcontext



Bean – объект бизнес-логики в терминологии Spring Framework. 
 
BeanDefinition – декларация, описание того, как создавать бин. Объект хранит его тип, метаинформацию, набор параметров для конструктора. 
 
BeanFactory – главная точка входа в DI-контейнер. Хранит BeanDefinition-ы, умеет создавать по ним экземпляры бинов, или выдавать существующие, в зависимости от области видимости Scope.   
 
BeanPostProcessor – до-настраивает только что созданные бины, ПЕРЕД тем как положить их в контейнер. Типичное место, чтобы оборачивать бины в прокси.  
Также с помощью такого постпроцессора внедряются @Autowired зависимости. Постпроцессоры бинов живут внутри экземпляра BeanFactory. 
 
BeanFactoryPostProcessor – тоже пост-обработчик, но для деклараций бинов 
(BeanDefinition). Обычно используется для модификации параметров или класса, из которых будут строиться бины. 
 
Для создания определений бинов в основном применяются классы и интерфейсы *BeanDefinitionReader. Некоторые из них вызываются прямо из контекста приложения, другие реализуют BeanFactoryPostProcessor. Один такой пост-процессор, например, отвечает за добавление определений бинов по аннотациям @Component и @Configuration. 

Реализация интерфейса ApplicationContext – основное хранилище конфигурации Spring-приложения (или его части). Контекст неизменяем, но может быть целиком перезагружен. Xml-файл конфигурации на старте приложения превращается в объект *XmlApplicationContext.  

Для конфигурации на аннотациях создастся AnnotationConfigApplicationContext. Контекст выполняет четыре разных обязанности: 
 
1.DI-контейнер. ApplicationContext функционирует как специальная реализация BeanFactory. Он также производит и хранит бины, но, в отличие от обычных фабрик, контексты в приложении составляют иерархию. Определения бинов из дочерних контекстов перекрывают родительские. 
 
2.Загрузка ресурсов. Под интерфейсом ResourceLoader контекст занимается загрузкой в память приложения файлов, как из classpath, так и из остальной файловой системы. 
 
3.Публикация событий приложения. Контекст распространяет в приложении «события» – наследники ApplicationEvent. Любой бин, которому нужно получать уведомления об этих событиях, просто реализует интерфейс ApplicationListener.  

Таким образом реализуется паттерн наблюдатель.   
 
Интернационализация. По коду, набору аргументов и локали, через интерфейс контекста MessageSource можно получать локализованные текстовые сообщения для пользователей. 


------------------------
В Spring-приложении встречаются несколько основных классов и интерфейсов, которые играют важную роль в его структуре и функционировании. Вот некоторые из них:

1. **ApplicationContext (Контекст приложения)** 🌱: ApplicationContext представляет контейнер Spring, который управляет созданием, настройкой и внедрением зависимостей бинов. Он предоставляет функциональность для управления всеми компонентами приложения.

2. **BeanFactory (Фабрика бинов)** 🏭: BeanFactory является базовым интерфейсом для всех реализаций контейнера бинов в Spring. Он предоставляет механизм для создания и получения бинов из контейнера.

3. **BeanFactoryPostProcessor** - это еще один важный интерфейс в Spring, который позволяет вам изменять метаданные бинов до их реального создания в контейнере. Этот интерфейс дает возможность настройки контекста приложения и бинов перед их инициализацией.

4. **BeanPostProcessor (Постпроцессор бинов)** 🔧: BeanPostProcessor - это интерфейс, который позволяет вам взаимодействовать с бинами до и после их инициализации. С его помощью вы можете настраивать и изменять бины перед их использованием в приложении.

5. **BeanDefinition (Определение бина)** 📄: BeanDefinition представляет метаданные для создания бинов. Он содержит информацию о классе бина, его области, жизненном цикле, зависимостях и других настройках.

6. **ApplicationEvent (Событие приложения)** 📢: ApplicationEvent - это базовый класс для всех событий, которые могут быть опубликованы в Spring-приложении. Он позволяет компонентам приложения обмениваться информацией и реагировать на события.


Вот некоторая информация о BeanFactoryPostProcessor:

1. **Цель BeanFactoryPostProcessor** 🎯: Главная цель BeanFactoryPostProcessor заключается в изменении метаданных бинов до их создания в контексте приложения. Он предоставляет возможность модифицировать и настроить конфигурацию бинов на уровне контейнера.

2. **Время выполнения** ⏳: BeanFactoryPostProcessor выполняется до создания любого бина в контейнере. Он применяется к метаданным бинов и может менять их на основе определенных правил или логики.

3. **Задачи BeanFactoryPostProcessor** 🛠️: BeanFactoryPostProcessor обычно используется для выполнения таких задач, как перенастройка или изменение метаданных бинов, добавление дополнительных настроек или валидация конфигурации бинов. Некоторые распространенные примеры использования BeanFactoryPostProcessor включают установку значений по умолчанию или замену свойств бинов.

4. **Пример использования** 💡: Один из популярных примеров использования BeanFactoryPostProcessor - это PropertyPlaceholderConfigurer, который позволяет заменить значения свойств бинов из внешних источников, таких как файлы свойств или переменные окружения, перед созданием бинов.

5. **Зарегистрирование BeanFactoryPostProcessor** 📝: Чтобы использовать BeanFactoryPostProcessor в вашем приложении, вы должны зарегистрировать его в контексте приложения. Это можно сделать путем реализации интерфейса BeanFactoryPostProcessor и добавления его экземпляра в контекст приложения или путем использования аннотации `@Bean` или XML-конфигурации для указания BeanFactoryPostProcessor в контексте.

BeanFactoryPostProcessor предоставляет мощный механизм для настройки и изменения конфигурации бинов в Spring-приложениях. Он дополняет функциональность BeanPostProcessor, который работает с уже созданными бинами, позволяя вам влиять на процесс создания бинов до их фактического создания.


[к оглавлению](#spring)

## 2.	Что такое инверсия контроля (IoC) и внедрение зависимостей (DI)?

Dependency Injection (DI) – это ЧАСТЬ Inversion of Control (IoC), не взаимозаменяемы! 

<img width="988" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/e3cd00b1-f94f-4287-9cac-2b6fbd4784ae">

Инверсия контроля (inversion of control, IoC) – принцип проектирования, по которому контроль над потоком управления передается фреймворку. Управляющий и прикладной код разделяются. При разработке модуля этот подход избавляет от необходимости знать о других модулях программы и деталях их взаимодействия. Такой код становится более пере-используемым и модульным, уменьшает связность. 
 
Внедрение зависимостей (Dependency Injection, DI) – одна из реализаций IoC.  
 
При взаимодействии с другими модулями, программа оперирует высокоуровневыми абстракциями, тогда как конкретная её реализация поставляется фреймворком. 
 
Стандартная реализация DI – фреймворк инстанциирует все сервисы, и складывает их в IoC-контейнер. При этом специальная сущность, Service Locator, занимается поиском соответствия реализаций абстракциям и их внедрением. 

-----------
Центральной частью Spring является подход Inversion of Control, который позволяет конфигурировать и управлять объектами Java с помощью рефлексии. Вместо ручного внедрения зависимостей, фреймворк забирает ответственность за это посредством контейнера. Контейнер отвечает за управление жизненным циклом объекта: создание объектов, вызов методов инициализации и конфигурирование объектов путём связывания их между собой.

Объекты, создаваемые контейнером, также называются управляемыми объектами (beans).Объекты могут быть получены одним из двух способов:
+ Dependency Lookup (поиск зависимости) — шаблон проектирования, в котором вызывающий объект запрашивает у объекта-контейнера экземпляр объекта с определённым именем или определённого типа.
+ Dependency Injection (внедрение зависимости) — шаблон проектирования, в котором контейнер передает экземпляры объектов по их имени другим объектам с помощью конструктора, свойства или фабричного метода.

Под DI понимают то Dependency Inversion (инверсию зависимостей, то есть попытки не делать жестких связей между вашими модулями/классами, где один класс напрямую завязан на другой), то Dependency Injection (внедрение зависимостей, это когда объекты котиков создаете не вы в main-е и потом передаете их в свои методы, а за вас их создает спринг, а вы ему просто говорите что-то типа "хочу сюда получить котика" и он вам его передает в ваш метод). Мы чаще будем сталкиваться в дальнейших статьях со вторым.

Внедрение зависимости (Dependency injection, DI) — процесс, когда один объект реализует свой функционал через другой. Является специфичной формой «инверсии управления» (Inversion of control, IoC), когда она применяется к управлению зависимостями. В полном соответствии с принципом единой обязанности объект отдаёт заботу о построении требуемых ему зависимостей внешнему, специально предназначенному для этого общему механизму.

К достоинствам применения DI можно отнести:
+ Сокращение объема связующего кода. Одним из самых больших плюсов DI является возможность значительного сокращения объема кода, который должен быть написан для связывания вместе различных компонентов приложения. Зачастую этот код очень прост — при создании зависимости должен создаваться новый экземпляр соответствующего объекта.
+ Упрощенная конфигурация приложения. За счет применения DI процесс конфигурирования приложения значительно упрощается. Для конфигурирования классов, которые могут быть внедрены в другие классы, можно использовать аннотации или XML-файлы.
+ Возможность управления общими зависимостями в единственном репозитории. При традиционном подходе к управлению зависимостями в общих службах, к которым относятся, например, подключение к источнику данных, транзакция, удаленные службы и т.п., вы создаете экземпляры (или получаете их из определенных фабричных классов) зависимостей там, где они нужны — внутри зависимого класса. Это приводит к распространению зависимостей по множеству классов в приложении, что может затруднить их изменение. В случае использования DI вся информация об общих зависимостях содержится в единственном репозитории (в Spring есть возможность хранить эту информацию в XML-файлах или Java классах), что существенно упрощает управление зависимостями и снижает количество возможных ошибок.
+ Улучшенная возможность тестирования. Когда классы проектируются для DI, становится возможной простая замена зависимостей. Это особенно полезно при тестировании приложения.
+ Стимулирование качественных проектных решений для приложений. Вообще говоря, проектирование для DI означает проектирование с использованием интерфейсов. Используя Spring, вы получаете в свое распоряжение целый ряд средств DI и можете сосредоточиться на построении логики приложения, а не на поддерживающей DI платформе.

Как реализуется DI в Spring Framework?

Реализация DI в Spring основана на двух ключевых концепциях Java — компонентах JavaBean и интерфейсах. При использовании Spring в качестве поставщика DI вы получаете гибкость определения конфигурации зависимостей внутри своих приложений разнообразными путями (т.е. внешне в XML-файлах, с помощью конфигурационных Java классов Spring или посредством аннотаций Java в коде). 

Компоненты JavaBean (также называемые POJO (Plain Old Java Object — простой старый объект Java)) предоставляют стандартный механизм для создания ресурсов Java, которые являются конфигурируемыми множеством способов. За счет применения DI объем кода, который необходим при проектировании приложения на основе интерфейсов, снижается почти до нуля. Кроме того, с помощью интерфейсов можно получить максимальную отдачу от DI, потому что бины могут использовать любую реализацию интерфейса для удовлетворения их зависимости.

К типам реализации внедрения зависимостей в Spring относят:
+ Constructor Dependency Injection — это тип внедрения зависимостей, при котором зависимости компонента предоставляются ему в его конструкторе (или конструкторах). Рекомендуется как основной способ, т.к. даже без спринга внедрение зависимостей будет работать корректно.
+ Setter Dependency Injection — контейнер IoC внедряет зависимости компонента в компонент через методы установки в стиле JavaBean. В основном через сеттеры. При модификации не создает новые экземпляры, в отличии от конструктора. Он при каждой модификации создаёт новый экземпляр.

--------------
🔄 Инверсия контроля (IoC) означает, что контроль над потоком выполнения программы переходит от нашего кода ко внешнему фреймворку или контейнеру. Вместо того, чтобы мы явно вызывали компоненты или зависимости, фреймворк берет на себя эту ответственность и автоматически управляет созданием, связыванием и уничтожением объектов.

⚙️ Внедрение зависимостей (DI) является конкретным подходом для реализации IoC. Оно заключается в передаче зависимостей объекту извне, а не создании их непосредственно внутри объекта. То есть, объект не сам создает или управляет своими зависимостями, а получает их извне.

🔌 DI позволяет нам создавать слабо связанные и переиспользуемые компоненты, так как зависимости можно легко заменить или модифицировать без изменения самого объекта.

🏭 В итоге, использование IoC и DI способствует созданию более гибкого и расширяемого кода, упрощает тестирование и повышает его качество.

[к оглавлению](#spring)

## 3.	Как эти принципы реализованы в Spring?

Spring – набор различных библиотек. DI реализуется одной из основных – Spring IoC. 
 
Сущности бизнес-логики в Spring, как и в JavaEE называются beans.  
 
Бины объявляются различными способами, корни большинства из них лежат в понятии Configuration. В качестве контейнера бинов выступает ApplicationContext.  
 
Чтобы передать инициализацию зависимости контексту, она помечается аннотацией @Autowired. 

<img width="1191" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/2428f70c-f1ea-4e21-aadb-41750fb53f97">

-----------------
В Spring принципы инверсии контроля (IoC) и внедрения зависимостей (DI) реализуются с помощью контейнера Spring IoC. 

IoC означает, что контроль над созданием и управлением объектов переходит от разработчика к контейнеру. Вместо того, чтобы явно создавать объекты через оператор new, вы объявляете их зависимости и конфигурацию в контейнере, который затем берет на себя создание и управление объектами. Таким образом, объекты получают свои зависимости автоматически.

DI означает, что зависимости объектов внедряются в них извне, а не создаются внутри самих объектов. В Spring DI реализуется способами:

1. Конструкторная инъекция зависимостей: Вы можете объявить зависимости в конструкторе класса. Когда контейнер Spring создает экземпляр класса, он автоматически внедряет требуемые зависимости через конструктор.

2. Инъекция зависимостей через сеттеры: Вы можете объявить сеттеры для зависимостей в классе. Контейнер Spring вызывает эти сеттеры и внедряет зависимости при создании экземпляра класса.

3. Инъекция зависимостей через поля: Вы можете пометить поля класса аннотацией `@Autowired` и контейнер Spring автоматически внедрит зависимости без использования сеттеров или конструкторов.

Spring также предоставляет аннотации, которые упрощают конфигурацию зависимостей, такие как `@Component`, `@Service`, `@Repository`, `@Controller`, которые помечают классы как компоненты, аннотацию `@Autowired`, которая указывает контейнеру Spring внедрить зависимости, и многое другое.

Для использования DI и IoC в Spring необходимо настроить контейнер Spring IoC и объявить конфигурации зависимостей, например, с использованием XML-файлов или аннотаций. Когда контейнер Spring создает бины (экземпляры классов), он внедряет требуемые зависимости на основе объявленных конфигураций, что позволяет разработчику сосредоточиться на бизнес-логике своего приложения, а не на управлении зависимостями.

[к оглавлению](#spring)

## 4.	Что такое IoC контейнер?

В Spring Framework контейнер отвечает за создание, настройку и сборку объектов, известных как бины, а также за управление их жизненным циклом.  

Контейнер представлен интерфейсом ApplicationContext. 

Контейнер IoC «под капотом» является ассоциативным массивом (набором пар элементов), где ключом является String идентификатор, а значением является объект. Этот объект вызывается бином (т.е. создаётся IoC с помощью Reflection API вызовом конструктора бина с последующим внедрением зависимостей). 

Spring Framework предоставляет несколько реализаций интерфейса ApplicationContext:  
+ ClassPathXmlApplicationContext и FileSystemXmlApplicationContext для автономных приложений 
+ WebApplicationContext для веб-приложений 
+ AnnotationConfigApplicationContext - для обычной Java-конфигурации, в качестве аргумента которому передается класс, либо список классов с аннотацией @Configuration, либо с любой другой аннотацией JSR-330, в том числе и @Component.  

Контейнер получает инструкции о том, какие объекты создавать, настраивать и собирать, через метаданные конфигурации, которые представлены в виде XML, Java-аннотаций или Java-кода:  

+ XML:
метаданные считываются из файла с расширением .xml  Атрибут id представлен String, строкой, которая идентифицирует бин-компонент.  
Атрибут class определяет ТИП bean-компонента и использует полное имя класса. 

<img width="818" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/a5249dac-2c25-4150-9954-bb59eddf10c6">

+ Java-аннотации: в Spring 2.5 появилась поддержка метаданных конфигурации на основе аннотаций, которая использует данные байт-кода для подключения компонентов.  
Вместо того, чтобы использовать XML-файл для описания связывания компонентов, разработчик перемещает конфигурацию в сам класс компонента, используя аннотации к соответствующему классу, методу или полю.

При этом, сам XML-файл с базовыми настройками остаётся. Контейнер считывает аннотации ПЕРЕД считыванием XML, поэтому, если бин конфигурируется через аннотации + XML-файл, то настройки XML переопределят настройки аннотаций.  

+ Java-код начиная со Spring 3.0, используя Java-код, а не файлы XML, можно определять настройки в специальном классе, помеченном аннотацией @Configuration. Появились аннотации @Configuration, @Bean, @Import и @DependsOn и т.д.
 
Этапы инициализации контекста с примерами тут: https://habr.com/ru/post/222579/  

-------
IoC (Inversion of Control) контейнер - это инструмент, который обеспечивает механизм инверсии управления в приложении. Вместо того, чтобы явно создавать и связывать зависимости в коде, IoC контейнер предоставляет средства для автоматического создания и управления объектами и их зависимостями.

Когда разработчик создает приложение, обычно требуется создание и связывание объектов, необходимых для его работы. В классическом подходе это делается явным образом в коде приложения. Однако это может привести к проблемам в поддержке и тестировании кода, а также усложнить добавление новых зависимостей.

[к оглавлению](#spring)

## 5.	Что такое Bean в спринге?

Bean – это объект, управляемый спрингом.  
В Spring – все бины (и сервисы, и DAO, и контроллеры (группы сервлетов)). 

<img width="1093" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/9d0add11-064a-4a91-9cc4-4ad25b2c2fa0">

[к оглавлению](#spring)

## 6.	Расскажите про аннотацию @Bean?

В Spring объекты, образующие основу приложения и управляемые контейнером Spring IoC, называются бинами.  

Бин — это объект, который создается, собирается и управляется контейнером Spring IoC.  

Бины и их зависимости отражаются в метаданных конфигурации, используемых контейнером. 

@Bean – это аннотация Spring Framework, она используется НАД МЕТОДОМ для указания того, что этот метод создает, настраивает и инициализирует новый объект, управляемый Spring IoC контейнером.  

Методы с аннотацией @Bean можно использовать как в КЛАССАХ с аннотацией @Configuration, так и в классах с аннотацией @Component (или её наследниках).  

Позволяет дополнительно определить у бина:  
+ name - имя (уникальный идентификатор) бина 
+ initMethod - имя метода для вызова во время инициализации бина 
+ destroyMethod - имя метода для вызова во время удаления бина из контекста 
+ autowireCandidate - является ли этот бин кандидатом на автоматическое внедрение в другой бин 

Классы, аннотированные @Configuration, проксируются через CGLib.  

Классы @Component или обычные классы не проксируются и не перехватывают вызовы методов с аннотациями @Bean, что означает, что вызовы не будут маршрутизироваться через контейнер и каждый раз будет возвращаться новый экземпляр бина. (https://habr.com/ru/articles/597797/)

Также методы бинов, вызывая друг друга в таких классах, не будут создавать бины, а будет просто выполняться код метода, т.к. они отработают не через прокси.  
CGLib (Code Generation Library) – это библиотека инструментария байтов, используемая во многих средах Java, таких как Hibernate или Spring. Инструментарий байт-кода позволяет манипулировать или создавать классы «на лету» после фазы компиляции программы.  

Hibernate использует cglib для генерации динамических прокси. Например, он не вернет полный объект, хранящийся в БД, но вернет инструментальную версию хранимого класса, которая лениво загружает значения из базы данных по требованию.  

Прокси — это шаблон проектирования. Создаем и используем его для добавления и изменения функционала УЖЕ существующих классов.  

В таком случае, прокси-объект применяется вместо исходного. Обычно он использует тот же метод, что и оригинальный, и в Java прокси-классы расширяют исходные. 

---------------------
Аннотация `@Bean` является одной из ключевых аннотаций во фреймворке Spring, которая используется при конфигурировании и создании объектов в контексте приложения.

📝 Когда вы помечаете метод в классе аннотацией `@Bean`, вы сообщаете Spring, что этот метод должен быть использован для создания и инициализации объекта. Возвращаемое значение этого метода становится экземпляром объекта, который Spring будет управлять в своем контексте.

🔄 Аннотация `@Bean` также может принимать различные аргументы и параметры, которые позволяют настраивать создаваемые объекты, например, указать имя бина, задать область видимости (scope), определить зависимости и т. д.

🌿 Важно отметить, что использование аннотации `@Bean` связано с конфигурацией Spring и представляет собой один из способов внедрения зависимостей и настройки компонентов в приложении.

[к оглавлению](#spring)

## 7. Расскажите про аннотацию @Component? 
 
@Component – простой способ сделать объявление класса объявлением Spring-бина.  Этой аннотацией помечаем КЛАСС, если хотим, чтобы из этого класса был создан бин. 
Из всех компонентов, которые попали в сканирование (о которых знает @ComponentScan), будут созданы декларации бинов Bean Definition. 
 
Аннотации @Service, @⁠	⁠Repository и @Controller⁠	 – это алиасы аннотации @Component. Сами по себе они не добавляют поведения, и технически в рамках ядра Spring Framework работают так же. 
 
Эти аннотации называют «Stereotype annotations». Их главное отличие – семантика, логическая роль компонентов: 
 
@Service⁠	 – реализация бизнес-логики 
 
@Repository⁠	 – хранилище данных: «репозиторий» из Domain-Driven Design или DAO; 
 
@Controller⁠	 – обработка веб-запросов (методы @RequestMapping) 

Сторонние компоненты могут пользоваться этой семантикой. Например, трансляция исключений Persistence API работает именно на компонентах стереотипа @Repository.  

В отдельных случаях кроме семантики может меняться и поведение кода библиотек. Для маппинга (связывания) с URL для всего класса или для конкретного метода обработчика используется аннотация @RequestMapping.

[к оглавлению](#spring)

## 8.	Чем отличаются аннотации @Bean и @Component?

@Component (как и @Service и @Repository) используется для АВТОМАТИЧЕСКОГО обнаружения и автоматической настройки бинов в ходе сканирования путей к классам. 
 
@Bean используется для ЯВНОГО объявления бина, а не для того, чтобы Spring делал это автоматически в ходе сканирования путей к классам: 
 
+ прописываем вручную метод для создания бина 
+ возможно объявить бин независимо от объявления класса, что позволяет использовать классы из сторонних библиотек, у которых не можем указать аннотацию @Component 
+ с аннотацией @Bean можно настроить initMethod, destroyMethod, autowireCandidate, делая создание бина более гибким 

-------------
+ Если я поставлю аннотацию @Bean не над методом, а над классом, то что будет? Исключение?

Если вы поместите аннотацию `@Bean` над классом вместо метода, то такой код может успешно скомпилироваться, но во время создания контекста приложения Spring Framework не будет создан бин для этого класса. Вместо этого, Spring будет регистрировать экземпляры класса в качестве бинов на основе конструкторов и методов-фабрик, а не на основе самого класса с аннотацией `@Bean`.

+ Если я поставлю аннотацию @Component не над классом, а над методом, то что будет? Исключение?

Если вы поместите аннотацию @Component над методом вместо класса, то будет сгенерировано исключение во время запуска приложения. Сообщение об ошибке будет указывать на то, что аннотация @Component может быть применена только к классам, а не к методам.

--------------------
Да, методы с аннотацией `@Bean` можно использовать как в классах с аннотацией `@Configuration`, так и в классах с аннотацией `@Component` или их наследниках, таких как `@Service`, `@Repository` и т.д.

Когда вы помещаете метод с аннотацией `@Bean` в класс с аннотацией `@Configuration`, это указывает Spring Framework'у на то, что этот метод должен быть использован для создания бинов. Конфигурационный класс с аннотацией `@Configuration` предоставляет Spring контексту информацию о том, как создавать и настраивать бины.

С другой стороны, при использовании аннотации `@Component` или её наследников, класс становится компонентом, управляемым Spring Framework. Если вы поместите метод с аннотацией `@Bean` в такой класс, Spring Framework также будет создавать бины, используя этот метод.

Пример кода:

```java
@Configuration
public class MyConfiguration {

    @Bean
    public MyBean myBean() {
        return new MyBean();
    }
}
```

```java
@Component
public class MyComponent {

    @Bean
    public AnotherBean anotherBean() {
        return new AnotherBean();
    }
}
```

В этом примере, `myBean()` метод в классе `MyConfiguration` и `anotherBean()` метод в классе `MyComponent` оба используют аннотацию `@Bean` и будут распознаны и использованы Spring Framework'ом для создания соответствующих бинов.

[к оглавлению](#spring)

## 9.	Расскажите про аннотации @Service и @Repository. Чем они отличаются?

@Service и @Repository являются частными случаями аннотации @Component.  Технически они одинаковы, но используются их для разных целей. 
 
@Service указывает, что используем сервис-слой, отвечающий за бизнес-логику.  Аннотация Spring @Repository указывает на то, что класс предоставляет механизм для CRUD операций: для хранения, извлечения, поиска, обновления и удаления операций с объектами. Этот слой отвечает за доступ к данным. 
 
Абстракция @Repository Spring Data позволяет значительно сократить объем шаблонного кода для реализации уровней доступа к данным для различных хранилищ сохраняемости. 
 
Задача @Repository заключается также в том, чтобы отлавливать определенные исключения персистентности (Persistence Exception) и пробрасывать их как одно непроверяемое исключение Spring Framework. Для этого в контекст должен быть добавлен класс PersistenceExceptionTranslationPostProcessor. 

Аннотация @Repository используется для обозначения классов в слое доступа к данным. Она не только служит индикатором для Spring, но и предоставляет дополнительные преимущества, такие как перехват исключений и преобразование их в Spring DataAccessException.

Например, когда исключение возникает в @Repository, для этого исключения обычно есть обработчик, и нет необходимости добавлять блоки try catch в класс DAO. Используется вместе с PersistenceExceptionTranslationPostProcessor

----------
PersistenceExceptionTranslationPostProcessor - это класс из фреймворка Spring, который является постпроцессором бинов и предоставляет механизм обработки исключений, возникающих при работе с хранилищем данных.

Зачем нужен PersistenceExceptionTranslationPostProcessor?
Когда мы используем Spring с JPA (Java Persistence API) или Hibernate для работы с базой данных, мы можем использовать аннотации, такие как `@Repository`, `@Transactional` и другие, для упрощения кода и обеспечения управляемости транзакций. Однако, если возникают исключения при работе с базой данных, они обычно бросаются в виде низкоуровневых исключений, специфичных для JPA или Hibernate.

Примеры таких исключений:
- HibernateException
- PersistenceException
- DataAccessException
- SQLException
- и другие

PersistenceExceptionTranslationPostProcessor предоставляет решение для преобразования этих низкоуровневых исключений в исключения, специфичные для Spring, такие как DataAccessException. Такое преобразование исключений позволяет нам сосредоточиться на использовании и обработке исключений в Spring-ориентированном стиле, что снижает зависимость кода от конкретных реализаций хранилищ данных и упрощает переход на другие реализации.

Подробнее об использовании PersistenceExceptionTranslationPostProcessor:
1. Добавление Maven зависимостей и настройка контекста Spring
   В вашем проекте должны быть добавлены зависимости на фреймворки Spring и Hibernate или JPA. Также необходимо настроить контекст Spring.

2. Аннотирование репозиториев
   Отметьте интерфейсы репозиториев, которые используются для работы с базой данных, аннотацией `@Repository`. Например:

   ```java
   import org.springframework.stereotype.Repository;

   @Repository
   public interface UserRepository {
       User findById(Long id);
       void save(User user);
   }
   ```

3. Создание бина PersistenceExceptionTranslationPostProcessor
   В контексте Spring, определите бин `PersistenceExceptionTranslationPostProcessor` для автоматической обработки исключений. Например, в файле XML-конфигурации:

   ```xml
   <bean class="org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor"/>
   ```

   Либо используя JavaConfig:

   ```java
   @Configuration
   public class AppConfig {
       @Bean
       public PersistenceExceptionTranslationPostProcessor exceptionTranslation() {
           return new PersistenceExceptionTranslationPostProcessor();
       }
   }
   ```

4. Обработка исключений
   Теперь, когда мы выполняем операции с базой данных через наши репозитории, все исключения, брошенные Hibernate или JPA, будут автоматически обернуты в исключения, специфичные для Spring (DataAccessException).

   ```java
   import org.springframework.dao.DataAccessException;

   @Service
   public class UserService {
       private UserRepository userRepository;

       @Autowired
       public UserService(UserRepository userRepository) {
           this.userRepository = userRepository;
       }

       @Transactional
       public User findUserById(Long id) throws DataAccessException {
           try {
               return userRepository.findById(id);
           } catch (DataAccessException ex) {
               // Обработка исключения
           }
       }
   }
   ```

   Теперь мы можем сосредоточиться на обработке исключений в стиле Spring, используя исключения, такие как `org.springframework.dao.DataAccessException` вместо специфичных для JPA или Hibernate исключений.

   ```java
   catch (DataAccessException ex) {
       // Обработка исключения в стиле Spring
   }
   ```

Это позволяет нам использовать механизмы Spring для объединения транзакций, аспектов и других функций фреймворка.

[к оглавлению](#spring)

## 10.	Расскажите про аннотацию @Autowired

Этой аннотацией помечают конструктор, поле, сеттер-метод или метод конфигурации, сигнализируя, что им обязательно требуется внедрение зависимостей. 

<img width="1074" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/298572ec-6bed-4f15-99e9-17dc385d2b91">

За обработку @Autowired отвечает BeanPostProcessor (соответствует этапу ЖЦ бина).  
 
То есть фактическое внедрение выполняется через BeanPostProcessor, что, в свою очередь, означает, что нельзя использовать @Autowired для внедрения ссылок в типы BeanPostProcessor или BeanFactoryPostProcessor.  
 
По умолчанию проверяет наличие аннотации @Autowired класс AutowiredAnnotationBeanPostProcessor. 

<img width="1050" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/5a2fb44b-711f-4dda-a40a-2e616a378c12">

<img width="1030" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/95e19195-2884-4c58-b817-47c776737fa1">

Аннотация @Autowired также принимает необязательный логический аргумент с именем required. По умолчанию его значение равно true. Можно явно установить для него значение false, для которого Spring не будет генерировать исключение при сбое автоматического подключения: @Autowired(required = false). 
 
По умолчанию Spring распознает объекты для вставки по ТИПУ. Если в контейнере доступно более одного бина одного и того же типа, будет выброшено исключение.  
 
Для избежания этого можно указать аннотацию Spring Framework @Qualifier("название поля"), где название fooFormatter — это имя (Id) одного из нескольких бинов одного типа, находящихся в контейнере и доступных для внедрения

<img width="390" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/978c0713-bb2a-4391-ad1b-083027f05bc6">
 
При выборе между несколькими бинами при автоматическом внедрении используется имя поля. Это поведение по умолчанию, если нет других настроек.  

<img width="1044" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/c872e03b-5f9e-40a7-a685-f23b5d6abf4a">

[к оглавлению](#spring)

## 11.	Расскажите про аннотацию @Resource

Аннотация `@Resource` является частью Java-спецификации для управления зависимостями и внедрения ресурсов в Java-приложениях. Она предоставляет механизм для инициализации переменных-ресурсов в Java-объектах без явной их инициализации в коде.

Spring также поддерживает внедрение зависимостей с помощью аннотации @Resource из JSR-250 (javax.annotation.Resource) для полей или сеттеров свойств бина. Это распространенный шаблон в Java EE: например, в JSF-управляемых бинах и конечных точках JAX-WS. Spring поддерживает этот шаблон и для объектов, управляемых Spring.

Java-аннотация @Resource может применяться к конструкторам, полям и методам.  В общем, также как и @Autowired.

Она пытается получить зависимость:  
+ сначала по имени 
+ затем по типу 
+ затем по описанию @Qualifier 

Имя извлекается из имени аннотируемого сеттера или поля, либо берется из параметра name. При аннотировании классов имя не извлекается из имени класса по умолчанию, поэтому оно должно быть указано явно.  

Указав данную аннотацию у полей или методов с аргументом name, в контейнере будет произведен поиск компонентов с данным именем, и в контейнере должен быть бин с таким именем 

<img width="595" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/f61460f5-82cf-4e42-b8c7-d8b8785916fc">

Если указать её без аргументов, то Spring Framework поможет найти бин по типу. Если в контейнере несколько бинов-кандидатов на внедрение, то нужно использовать @Qualifier 

<img width="915" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/cd0de536-faf0-4020-840e-435d0ca41563">
 
Разница с @Autowired:  
+ ищет бин сначала по имени, а потом по типу 
+ не нужна дополнительная аннотация для указания имени конкретного бина 
+ @Autowired позволяет отметить место вставки бина как необязательное @Autowired(required = false) 
+ при замене Spring Framework на другой фреймворк, менять @Resource не нужно 

[к оглавлению](#spring)

## 12.	Расскажите про аннотацию @Inject

Java-аннотация @Inject входит в пакет javax.inject и, чтобы её использовать, нужно добавить зависимость 

<img width="555" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/2d382bf6-84f2-44f7-9072-09a91ffbeb63">
 
Размещается над полями, методами, и конструкторами с аргументами.  

@Inject, как и @Autowired в первую очередь пытается подключить зависимость по типу, затем по описанию и только потом по имени. Это означает, что даже если имя переменной ссылки на класс отличается от имени компонента, но они одинакового типа, зависимость все равно будет разрешена: 

<img width="732" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/be812dc2-1c66-4aa9-99ac-1d02c87746da">
 
отличается от имени компонента, настроенного в контексте приложения 

<img width="1092" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/193bd8ae-4f6b-4d7f-883e-7b504d53b67e">

Разность имён injectDependency и fieldInjectDependency не имеет значения, зависимость будет подобрана по типу ArbitraryDependency. 

Если в контейнере несколько биновкандидатов на внедрение, то нужно использовать аннотацию @Qualifier

<img width="530" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/fb56e0eb-2465-4fc4-b6be-8b8f92681aec">

При использовании конкретного имени (Id) бина используем @Named (см. ниже)

<img width="782" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/8bdaecca-1480-4e42-94b2-869ec8565639">

В @Inject, в отличие от @Autowired, нет параметра required, ир есть мы не можем как в @Autowired установить required = false и не загружать бин, в случае, если он не был найден. Если бин не будет найден, будет исключение.

--------------------
Верное уточнение: в Java-контейнере внедрения зависимостей (DI) с использованием аннотации `@Inject`, если ненайденный бин имеет **необязательную зависимость**, то вместо него будет вставлено значение `null`.
По умолчанию, если бин не найден, при использовании `@Inject` в Spring Framework будет выброшено исключение `NoSuchBeanDefinitionException`. Однако можно настроить поведение DI-контейнера, чтобы он позволял необязательные зависимости, т.е. если бин не найден, вместо него будет вставлено значение `null`.
В Spring Framework для этого можно использовать аннотацию `@Nullable`. Например:
```java
@Inject
@Nullable
private YourBean yourBean;
```
В этом случае, если бин `YourBean` не найден, в поле `yourBean` будет вставлено значение `null`.

@Nullable появилась в 5 спринге.

----------------
When I looked under the hood I determined that the ‘@Autowired’ and ‘@Inject’ annotation behave identically. Both of these annotations use the ‘AutowiredAnnotationBeanPostProcessor’ to inject dependencies. ‘@Autowired’ and ‘@Inject’ can be used interchangeable to inject Spring beans. However the ‘@Resource’ annotation uses the ‘CommonAnnotationBeanPostProcessor’ to inject dependencies. Even though they use different post processor classes they all behave nearly identically. Below is a summary of their execution paths.

@Autowired and @Inject

+ Matches by Type
+ Restricts by Qualifiers
+ Matches by Name

@Resource

+ Matches by Name
+ Matches by Type
+ Restricts by Qualifiers (ignored if match is found by name)

------------
Внедрение зависимостей по имени и с использованием квалификаторов (qualifiers) являются двумя разными подходами к указанию конкретной зависимости при использовании Dependency Injection.

Внедрение зависимостей по имени (Injection by Name) основывается на именовании зависимостей с помощью строковых значений. Когда вам требуется внедрить конкретную зависимость, вы указываете имя зависимости, и Dependency Injection контейнер ищет зависимость с соответствующим именем. Этот подход часто используется с аннотацией `@Named` (JSR-330), например, с помощью `@Inject` и `@Named("myBean")`:

```java
@Inject
@Named("myBean")
private MyDependency myDependency;
```

Внедрение зависимостей с использованием квалификаторов (Injection by Qualifiers) позволяет создавать пользовательские аннотации-квалификаторы для именования зависимостей. Квалификаторы являются аннотациями, которые ассоциируются с конкретными зависимостями для указания их особых свойств или характеристик. Например, вы можете создать пользовательский квалификатор `@MyQualifier` и использовать его для внедрения зависимости:

```java
@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface MyQualifier {
}

...

@Autowired
@MyQualifier
private MyDependency myDependency;
```

В этом случае Dependency Injection контейнер ищет зависимость, помеченную пользовательским квалификатором `@MyQualifier`.

Главное отличие между внедрением зависимостей по имени и с использованием квалификаторов состоит в способе указания и передачи информации о зависимости. Внедрение по имени требует явного указания имени зависимости в коде, а внедрение с использованием квалификаторов позволяет определить специальные аннотации-квалификаторы, которые могут быть использованы для идентификации или характеризации зависимостей. Это предоставляет большую гибкость и расширяемость при работе с зависимостями.

[к оглавлению](#spring)

## 13.	Расскажите про аннотацию @Lookup

Метод, аннотированный @Lookup, сообщает Spring, чтобы он возвращал экземпляр типа возвращаемого значения метода, когда мы его вызываем.  
 
По сути, Spring переопределит аннотированный метод и будет использовать тип возвращаемого значения и параметры метода в качестве аргументов для BeanFactory 
#getBean. 
                    
Обычно бины в приложении Spring являются синглтонами, и для внедрения зависимостей используют конструктор или сеттер. 
 
Но бывает и другая ситуация: имеется бин Car — синглтон (singleton bean), и ему требуется каждый раз новый экземпляр бина Passenger (каршеринг). 
 
То есть Car – синглтон, а Passenger – так называемый прототип-бин (prototype bean).  
 
Жизненные циклы бинов разные. Бин Car создается контейнером только раз, а бин Passenger создается каждый раз новый – допустим, это происходит каждый раз при вызове какого-то метода бина Car.  
 
Вот здесь то и пригодится внедрение бина с помощью Lookup метода.  
 
Оно происходит не при инициализации контейнера, а позднее: каждый раз, когда вызывается метод. 
 
Создаётся метод-заглушка в бине Car и помечается специальным образом – аннотацией 
@Lookup. Этот метод должен возвращать бин Passenger, каждый раз новый.  
 
Контейнер Spring под капотом создаст подкласс и переопределит этот метод и будет выдавать новый экземпляр бина Passenger при каждом вызове аннотированного метода. Даже если в заглушке он возвращает null (а так и надо делать, все равно этот метод будет переопределен). 
 
Пример использования: 

<img width="1022" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/2a26244e-9262-4823-ba0a-afa647b9bd7a">

Внедрение зависимости с помощью 	Lookup	 метода в коде встречается нечасто, но это хороший способ внедрить бин- прототип в бин-синглтон.	 
 
Пример и код тут: https://sysout.ru/kak-ispolzovat-annotatsiyu-lookup/  

При использовании @Lookup следует учитывать некоторые нюансы:

+ Метод с аннотацией @Lookup не может быть приватным.
+ Метод не должен иметь аргументов.
+ Метод должен возвращать тип, являющийся интерфейсом прототипного бина или его супертипом.

Использование @Lookup может быть полезным тогда, когда требуется получить новый экземпляр прототипного бина в каждом вызове метода, а не разово получить ссылку на него.

----------
Аннотация @Lookup является частью Spring Framework и используется для автоматического разрешения зависимостей при создании прототипных бинов. Она позволяет получить новый экземпляр прототипного бина каждый раз, когда он запрашивается из контекста.

Основное отличие между аннотациями @Lookup и @Autowired заключается в следующем:
- @Autowired используется для внедрения зависимостей в существующий бин. Он разрешает зависимости один раз при создании бина и сохраняет полученный экземпляр для дальнейшего использования.
- @Lookup используется для получения нового экземпляра прототипного бина каждый раз, когда он требуется.

Давай рассмотрим пример, чтобы лучше понять, как работает аннотация @Lookup:

```java
public abstract class PrototypeBean {
    public void doSomething() {
        System.out.println("Я прототипный бин!");
    }
}

@Component
public class SingletonBean {
    @Lookup
    public PrototypeBean getPrototypeBean() {
        return null;
    }

    public void usePrototypeBean() {
        PrototypeBean prototype = getPrototypeBean();
        prototype.doSomething();
    }
}
```

В этом примере мы имеем два класса: `SingletonBean` (одиночный) и `PrototypeBean` (прототипный). С помощью аннотации @Lookup мы объявляем метод `getPrototypeBean()` в `SingletonBean`, используя его для получения нового экземпляра `PrototypeBean` при каждом вызове. Мы вызываем этот метод в `usePrototypeBean()`, чтобы использовать прототипный бин.

На самом деле, аннотация @Lookup работает на основе прокси-объектов и методов. Когда Spring видит @Lookup на методе бина, он создает специальный прокси-объект, который перехватывает вызовы этого метода и возвращает новый экземпляр каждый раз.

Вот как использовать аннотацию @Lookup в различных ситуациях:
- Если вам нужны разные экземпляры прототипного бина внутри одного синглтона, используйте @Lookup.
- Если вам нужен только один экземпляр бина для использования во всем приложении, используйте @Autowired.

В заключение, аннотация @Lookup полезна, когда вам нужно получить новую копию прототипного бина каждый раз, когда он требуется. Она позволяет реализовать динамическую зависимость, которую вы не можете достичь с помощью @Autowired.

-------------------
the container will generate runtime subclasses of the method's containing class via CGLIB, which is why such lookup methods can only work on beans that the container instantiates through regular constructors (i.e. lookup methods cannot get replaced on beans returned from factory methods where we can't dynamically provide a subclass for them).

[к оглавлению](#spring)

## 14.	*Как работает инъекция прототипа в синглтон?

Вопрос касается также различия области видимости (скоупов) singleton и prototype в Spring Framework. Допустим ситуацию, когда в singleton-компонент внедряется зависимость со scope prototype – когда будет создан её объект? 

В Spring Framework по умолчанию бины с областью видимости Singleton создаются при создании контекста приложения. Это означает, что все зависимости, внедряемые в Singleton-компонент, также будут созданы вместе с ним при создании контекста.
 
Если просто добавить к определению бина аннотацию @Scope(SCOPE_PROTOTYPE), и использовать этот бин в синглтоне через аннотацию @Autowired – будет создан только один объект. Потому что синглтон создается только однажды, и обращение к прототипу случится тоже однажды при его создании (при внедрении зависимости). 
 
Примитивный способ получать новый объект при каждом обращении – отказаться от @Autowired, и доставать его из контекста вручную, вызывая context.getBean(MyPrototype.class) 
 
Воспользоваться автоматическим внедрением зависимостей можно через внедрение метода (паттерн «Команда»). Внедряется не сам объект, а производящий его метод. 
 
Команда (Command) — поведенческий шаблон проектирования, используемый при ООП, для обработки команды в виде объекта и представляющий ДЕЙСТВИЕ. То есть Объект команды заключает в себе само действие и его параметры. 
 
Более красивый декларативный способ – правильно настроить определение бина. В аннотации @Scope кроме самого scopeName доступен параметр – proxyMode. 

По умолчанию его значение NO – прокси не создается. Но если указать INTERFACES или TARGET_CLASS, то под @Autowired будет внедряться не сам объект, а сгенерированный фреймворком прокси. 
И когда проксируемый бин имеет скоуп prototype, то объект внутри прокси будет пересоздаваться при каждом обращении.

<img width="661" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/9afde0be-bda2-4dc6-a046-82c652c9ac53">

-------------
В Spring Framework инъекция прототипа в синглтон невозможна напрямую. По умолчанию, когда вы создаете бин (компонент) в Spring и не указываете явно область видимости, то она считается синглтоном. Это означает, что Spring создаст только один экземпляр объекта и будет использовать его для всех запросов внедрения зависимости.

Однако, если вы хотите внедрить прототипный экземпляр в синглтон, есть несколько способов, которые можно использовать.

1. Использование `ObjectFactory`:
   Вы можете внедрить `ObjectFactory` или `Provider` из пакета `javax.inject` в ваш синглтон, а затем использовать его для получения нового экземпляра прототипного бина при каждом вызове.
   
   Пример:
   ```java
   @Component
   public class SingletonComponent {
       @Autowired
       private ObjectFactory<PrototypeComponent> prototypeComponentFactory;

       public PrototypeComponent getPrototypeComponent() {
           return prototypeComponentFactory.getObject();
       }
   }
   ```

2. Использование `@Lookup`:
   Вы можете аннотировать метод в вашем синглтоне с `@Lookup`, чтобы Spring автоматически сгенерировал код для получения нового экземпляра прототипного бина. При каждом вызове такого метода будет создаваться новый экземпляр прототипного бина.
   
   Пример:
   ```java
   @Component
   public class SingletonComponent {
       @Lookup
       public PrototypeComponent getPrototypeComponent() {
           // Spring автоматически сгенерирует реализацию этого метода
           return null;
       }
   }
   ```
   
Оба этих подхода позволяют достичь внедрения прототипного экземпляра в синглтон. Здесь важно помнить, что каждый раз, когда вызывается метод для получения прототипного экземпляра, будет создаваться новый объект-прототип.

---------------------

Инъекция прототипа в синглтон возможна с помощью использования аннотации @Lookup в Spring Framework.

Когда вы определяете бин с аннотацией `@Component`, по умолчанию его область действия является синглтоном (одиночным). Это означает, что Spring будет создавать только один экземпляр этого бина и использовать его для всех запросов.

Однако, если вам нужно внедрить прототипный бин в синглтон, вы можете использовать аннотацию `@Lookup`. Рассмотрим следующий пример:

```java
public abstract class PrototypeBean {
    public void doSomething() {
        System.out.println("Я прототипный бин!");
    }
}

@Component
public class SingletonBean {
    @Lookup
    public PrototypeBean getPrototypeBean() {
        return null;
    }

    public void usePrototypeBean() {
        PrototypeBean prototype = getPrototypeBean();
        prototype.doSomething();
    }
}
```

В этом примере у нас есть два класса: `SingletonBean` (синглтон) и `PrototypeBean` (прототип). Метод `getPrototypeBean()` в `SingletonBean` помечен аннотацией `@Lookup`, чтобы получить новый экземпляр `PrototypeBean` каждый раз при его вызове.

При выполнении метода `usePrototypeBean()` в `SingletonBean` вызывается метод `getPrototypeBean()`, и Spring создает динамический прокси-объект, который перехватывает этот вызов. Прокси-объект проксирует вызов к контейнеру Spring, который создает новый экземпляр `PrototypeBean` и возвращает его обратно.

Таким образом, каждый раз, когда `getPrototypeBean()` вызывается в `SingletonBean`, мы получаем новый экземпляр прототипного бина. Это позволяет нам внедрять прототипы в синглтоны и использовать их в каждом вызове метода.

Однако важно отметить, что аннотация `@Lookup` работает только с прототипами и не может быть использована с другими типами бинов, такими как синглтон или запрос. Если вам нужно разрешить зависимость на основе другой области видимости, вам придется использовать другие методы или подходы, предоставляемые Spring Framework.

[к оглавлению](#spring)

## 15.	Можно ли вставить бин в статическое поле? Почему?

<img width="963" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/230b432e-5f2e-409f-a654-a2bb51a4073c">

https://mkyong.com/spring/spring-inject-a-value-into-static-variables/   

Spring не позволяет внедрять бины напрямую в статические поля. Это связано с тем, что когда загрузчик классов загружает статические значения, контекст Spring ещё не загружен. (?)

Чтобы исправить это, создайте нестатический сеттер-метод:
```java
@Component

public class TestDataInit {

     private static OrderItemService orderItemService;

    @Autowired
    public void setOrderItemService(OrderItemService orderItemService) {

        TestDataInit.orderItemService = orderItemService;

    }

}
```
Неокончательное значение означает, что вы можете изменить значение поля, что для статического поля подразумевает обработку одновременного выполнения потоков — то есть «боль в стеке».
То есть вот такие не финальные статические поля могут привести к ошибкам при многопоточности.

Spring не позволяет внедрять бины в статические поля класса по ряду причин:

1. **Жизненный цикл бинов**: Бины, управляемые Spring, создаются и управляются контейнером Spring. Они предназначены для инициализации, обработки зависимостей и уничтожения контейнером. Статические поля класса существуют на уровне всего класса и не привязаны к экземпляру бина. Это означает, что Spring не будет иметь контроль над их жизненным циклом и не сможет обеспечить их создание, внедрение зависимостей и уничтожение в правильное время.

2. **Потокобезопасность**: Статические поля класса являются общими для всех экземпляров и всех потоков, работающих с классом. Если бины внедряются в статические поля, может возникнуть состояние гонки (race condition), где несколько потоков пытаются одновременно модифицировать одно и то же статическое поле.

3. **Тестирование**: Внедрение зависимостей в статические поля усложняет тестирование, поскольку такие поля общие для всех экземпляров класса и оказывают влияние на все экземпляры. Это затрудняет изолирование и контроль зависимостей при тестировании отдельных частей кода.

Использование статических полей для внедрения бинов противоречит концепции управления зависимостями и жизненным циклом объектов, которую пропагандирует Spring Framework. Вместо этого, Spring рекомендует использовать внедрение зависимостей в нестатические поля экземпляров класса или через конструкторы/сеттеры. Это позволяет Spring контролировать жизненный цикл бинов и обеспечивает более гибкое и тестируемое приложение.

[к оглавлению](#spring)

## 16.	Расскажите про аннотации @Primary и @Qualifier

@Primary используется, чтобы отдавать предпочтение бину, когда есть несколько бинов одного типа. Эта аннотация полезна, когда нужно указать, какой компонент определенного типа должен внедряться по умолчанию. 

Аннотация @Primary применяется к бину в Spring-контексте и указывает, что данный бин является первичным для своего типа. Если существует несколько бинов одного типа, аннотация @Primary указывает, какой из них будет использован по умолчанию при внедрении зависимостей. Например, если у вас есть два бина типа DataSource, вы можете пометить один из них с аннотацией @Primary, чтобы указать, что именно он будет использован в качестве основного.

Одновременное использование аннотаций @Primary и @Qualifier может быть полезным в случаях, когда вы хотите указать основной бин по умолчанию, но по-прежнему предоставлять возможность выбора другого бина с помощью квалификатора.
 
Когда есть несколько бинов одного типа, подходящих для внедрения, аннотация @Qualifier позволяет указать в качестве аргумента имя конкретного бина, который следует внедрить.  
 
Стоит отметить, что если присутствуют ОБЕ аннотации @Qualifier и @Primary, то аннотация @Qualifier будет иметь приоритет.  
 
По сути, @Primary определяет значение по умолчанию, в то время как @Qualifier более специфичен: определяет приоритет внедрения. 
По умолчанию Spring распознает объекты для вставки по ТИПУ. Если в контейнере доступно более одного бина одного и того же типа, будет выброшено исключение.  
 
Для избежания этого можно указать аннотацию Spring Framework @Qualifier("название поля"), где название fooFormatter — это имя (Id) одного из нескольких бинов одного типа, находящихся в контейнере и доступных для внедрения 

<img width="498" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/c5fc1071-d04c-4767-9a62-f2a242f6bff8">
 
При выборе между несколькими бинами при автоматическом внедрении используется имя поля. Это поведение по умолчанию, если нет других настроек.  

<img width="1191" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/66c9bcd6-c7cb-4202-933f-a8fb298a1c44">

Другой пример @Qualifier

<img width="1181" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/f10c2dfa-52c3-434f-9982-6bbd4fab248c">

Если при использовании @Autowired подходящих по типу бинов больше одного, то выбрасывается исключение. Предотвратить выброс данного исключения можно, конкретно указав, какой бин должен быть внедрён. Используют аннотацию @Qualifier 

-------------
Если в аннотации `@Component` не указано явное имя бина, Spring будет использовать имя класса с некоторыми стандартными конверсиями для определения имени бина. В большинстве случаев это имя будет сгенерировано с некоторыми правилами преобразования и будет соответствовать имени класса с некоторыми изменениями.

Например, если у вас есть класс с именем `MyBean`, и вы не указали явное имя бина в аннотации `@Component`, то Spring будет генерировать имя бина на основе имени класса с некоторыми стандартными правилами преобразования. В данном случае сгенерированное имя бина будет "myBean". 

Если в вашем контексте присутствуют несколько бинов с одним типом, и вы пытаетесь внедрить зависимость с помощью `@Autowired`, то Spring будет искать бин по типу и по имени. Если найдено несколько бинов с требуемым типом, и имя бина не указано явно, то будет сгенерировано исключение `NoUniqueBeanDefinitionException`, так как Spring не сможет однозначно определить, какой бин внедрить.

Чтобы избежать этой ошибки, рекомендуется явно указывать имена бинов в аннотации `@Component` или использовать альтернативные подходы, такие как использование квалификаторов (`@Qualifier`) или использование аннотации `@Primary` для указания предпочтительного бина при неоднозначности.

-----------------
Имя, по которому бин будет зарегистрирован в контейнере, обычно указывается с помощью аннотации `@Named` или `@Component` (в случае использования Spring Framework). 

Аннотация `@Qualifier` используется вместе с другими квалификаторами для разрешения конфликтов при внедрении зависимостей. Она не предназначена для явного указания имени бина. 

Вот пример:

```java
@Component
@Qualifier("myBean")
public class MyBean implements MyDependency {
    // ...
}
```

В данном примере мы используем аннотацию `@Qualifier` для создания квалификатора `myBean`. Затем мы аннотируем класс `MyBean` аннотацией `@Component`, чтобы он был зарегистрирован в контейнере. Когда мы внедряем зависимость `MyDependency`, мы можем использовать этот квалификатор `myBean`:

```java
@Autowired
@Qualifier("myBean")
private MyDependency myDependency;
```

Таким образом, аннотация `@Qualifier` в данном случае служит для указания конкретного квалификатора (`myBean`), который должен быть использован для разрешения зависимости `MyDependency`.


[к оглавлению](#spring)

## 17.	Как заинжектить примитив?

**@Value**
 
Внедрить в поле примитив можно с помощью аннотации @Value на уровне параметров поля или конструктора/метода. 
 
Понадобится файл свойств (*.properties), чтобы определить значения, которые нужно внедрить аннотацией @Value.  

<img width="543" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/215c4d72-9c81-48fb-bcbe-cfe83a733dc3">
 
Сначала в классе конфигурации нужно указать аннотацию @PropertySource с именем файла свойств. 
 
Содержимое файла values.properties: 

<img width="527" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/ae562cf7-2ea7-453e-8c01-cbaf806e6cff">

Внедряем значение value.from.file, равное “Value got from the file”: 

<img width="483" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/4c05e9d0-f6b0-4a01-8c57-f69bf1b24037">
 
Если из файла не подтянутся значения по тем или иным причинам, то можно указать значения, которые будут внедрены по умолчанию.  

В данном примере, если не будет доступен value.from.file, то внедрится значение “some default”: 

<img width="536" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/4363884a-ed3d-4c48-a1fb-991ced0d7490">

Если нужно внедрить несколько значений, то можно их определить в файле *.properties через запятую и Spring  внедрит их как массив: 

<img width="404" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/020025b0-9067-4c12-8d43-0084d2845c12">

**@Value with SpEL**
 
Кроме того, для внедрения значений можно использовать язык SpEL (Spring Expression Language)  

<img width="575" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/b954393f-85ef-4263-ba89-44c210168623">
 
… или со значениями по умолчанию: 
 
<img width="885" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/2f1108b5-cc57-4b3a-bef6-c298a691aaa3">
 
Можно использовать значение поля из другого бина.  Предположим, есть бин с именем someBean с полем someValue, равным 10. Тогда в этом примере в поле будет записано число 10: 

<img width="476" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/c6e94e8d-9f9b-4315-9700-74555fdcddd8">
 
Можно манипулировать свойствами, чтобы получить список значений. В следующем примере получаем список строковых значений A, B и C: 

<img width="586" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/bb87f032-37e3-493c-87f0-2c1b03063276">

**@Value with Map**
 
Можно использовать аннотацию @Value для добавления свойств в Map. Для начала нужно определить свойство в формате {key: ‘value '} в файле свойств: 
 
<img width="436" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/a2aeed48-4495-4edd-9158-4470501d43fa">
 
Теперь можно вставить это значение из файла свойств в виде карты: 

<img width="389" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/a413c3b4-3570-4fab-b04b-a0b08088323b">
 
Можно просто внедрить значение по ключу: 

<img width="309" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/23a45a2f-3b00-42b5-bc2d-bd7c94c7200b">
 
Если не уверены, содержит ли Map определенный ключ, неоходимо выбрать более безопасное выражение, которое не будет генерировать исключение, а установит значение в null, если ключ не найден: 

<img width="387" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/f17e3d22-4519-4e3c-9d09-3d79af475fc0">
 
Также можно установить значения по умолчанию для свойств или ключей, которые могут не существовать: 

<img width="494" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/8e281946-bdf4-412d-9472-7d57872ec11d">
 
Записи карты также могут быть отфильтрованы перед внедрением.  Предположим, нужно получить только те записи, значения которых больше единицы: 

<img width="411" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/69ff2b2b-6353-4bee-b862-fcf4b34a88fa">
 
Также можно использовать аннотацию @Value для добавления всех текущих системных свойств:

<img width="401" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/8e3fa063-50b0-47eb-a561-2b4741f40d3c">

**@Value with Constructor**
 
Можно внедрять значения в конструкторе, если оно не найдено, то будет внедрено значение по умолчанию: 

<img width="656" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/08e9b6d0-1341-4554-997e-1e3fd4338fff">

**@Value with Setter**

В приведенном коде использовано выражение SpEL для добавления списка значений в метод setValues

<img width="695" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/1158e4f3-4d21-4f3f-a677-19786e3de167">

----------------
Для инъекции примитивных значений в Spring вы можете использовать аннотацию `@Value` или `@ConfigurationProperties`.

Использование `@ConfigurationProperties`:

```java
@Component
@ConfigurationProperties(prefix = "my")
public class MyComponent {
    private int property;
    
    public int getProperty() {
        return property;
    }
    
    public void setProperty(int property) {
        this.property = property;
    }
    
    // ...
}
```

В этом примере префикс `my` указывает на префикс свойств, которые должны быть связаны с компонентом. Значение свойства, например, `my.property`, будет автоматически связано с примитивной переменной `property`.

Затем вы можете использовать компонент `MyComponent`, и примитивное значение будет автоматически инъецировано.

Внедрение примитивов в Spring очень удобно и может быть полезным для внедрения конфигурационных значений или других параметров в вашу приложение.

Пожалуйста, обратите внимание, что для использования аннотации `@Value` необходимо убедиться, что у вас есть настроенный источник свойств, такой как `PropertySourcesPlaceholderConfigurer` или `@PropertySource`. Использование `@ConfigurationProperties` требует, чтобы ваш класс был помечен аннотацией `@EnableConfigurationProperties` либо имел его конфигурацию.

Разница между аннотацией `@ConfigurationProperties` и `@Value`, а также соответствующие случаи их использования:

1. `@ConfigurationProperties`:

   - Используется для связывания значений из файла свойств (например, application.properties) с полями класса.
   - Для использования `@ConfigurationProperties` необходимо создать POJO (Plain Old Java Object) класс с геттерами и сеттерами для свойств.
   - Обычно удобно использовать `@ConfigurationProperties`, когда вам нужно связать несколько свойств с одним объектом или когда у вас есть иерархическая структура свойств.
   - Позволяет настраивать свойства с помощью префикса и связывать их со свойствами класса.
   - Неявно выполняет преобразование типов значений свойств в соответствующие типы полей класса.

   Пример использования `@ConfigurationProperties`:
   ```java
   @Component
   @ConfigurationProperties(prefix = "my")
   public class MyComponent {
       private int property;
       // геттеры и сеттеры
       // ...
   }
   ```
   
2. `@Value`:

   - Используется для инъекции конкретного значения свойства в поле класса.
   - Может быть использована для связывания примитивных типов данных (например, числовых значений, строк и т.д.) или для связывания одиночных свойств.
   - Подходит для случаев, когда вам нужно инъецировать небольшое количество отдельных свойств.
   - Позволяет использовать выражения SpEL (Spring Expression Language) для вычисления значения свойства.
   - Неявно выполняет преобразование типов значений свойств в соответствующие типы полей класса.

   Пример использования `@Value`:
   ```java
   @Component
   public class MyComponent {
       @Value("${my.property}")
       private int myProperty;
       // ...
   }
   ```

В итоге, вы можете использовать `@ConfigurationProperties`, когда нужно связать множество свойств с одним объектом и иметь иерархическую структуру, а `@Value` - когда нужно инъецировать конкретное значение свойства или для независимых примитивных типов данных.

Аннотация `@EnableConfigurationProperties` указывает Spring Boot на использование классов, помеченных аннотацией `@ConfigurationProperties` в качестве настроек приложения.

Когда вы помечаете свой класс с аннотацией `@ConfigurationProperties`, Spring Boot будет автоматически считывать значения свойств из файла `application.properties` (или `application.yml`) и связывать их с полями вашего класса.

Однако, для активации этого механизма связывания, вам нужно либо:

1. Пометить конфигурационный класс вашего приложения (класс, содержащий точку входа приложения) аннотацией `@EnableConfigurationProperties`, чтобы включить автоматическое связывание настроек.

или

2. Пометить любой другой конфигурационный класс, который импортируется в основной конфигурационный класс, с аннотацией `@EnableConfigurationProperties`.

Это гарантирует, что Spring будет искать классы с аннотацией `@ConfigurationProperties` и применять автоматическое связывание настроек.

Примеры:

```java
@EnableConfigurationProperties(MyProperties.class)
@SpringBootApplication
public class YourApplication {
    // ...
}
```

или

```java
@Configuration
@EnableConfigurationProperties(MyProperties.class)
public class AppConfig {
    // ...
}
```

где `MyProperties` - это класс, помеченный аннотацией `@ConfigurationProperties`.


[к оглавлению](#spring)

## 18.	Как заинжектить коллекцию?

https://habr.com/ru/companies/otus/articles/487750/

Можно внедрять массивы примитивов и ссылочных типов. Со всеми массивами и коллекциями используем внедрение через: 
+ поля 
+ конструкторы 
+ методы-сеттеры 

Array Injection / Collections Injection 

<img width="999" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/a13fb3be-54fd-44e8-a362-a92dd2ff303d">

Коллекции бинов одного типа 
 
Также можно собрать все бины одного типа, находящиеся в контейнере, и внедрить их в коллекцию или массив: 
 
<img width="549" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/3c499ff8-3a18-43c9-a8cb-7b365fbba91b">

Если необходимо внедрить вышеупомянутые бины RefBean в Map, то значениями Map будут сами бины, а ключами будут имена бинов:

<img width="527" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/0d4ea554-dace-4268-ad73-40e143d336b2">

**Использование @Qualifier**

Методы класса JavaConfig (те, которые аннотированы @Bean) могут быть объявлены с определенным квалифицирующим типом, используя @Qualifier. 
 
Например, использован параметр 'name' у аннотации @Bean, чтобы указать конкретный классификатор для бина.  
 
Элемент 'name' является идентификатором бина, который должен быть уникальным, потому что все бины хранятся в контейнере в Map. 
 
В случае с коллекцией необходимо, чтобы несколько бинов имели одно и то же имя квалификатора @Qualifier, чтобы их можно было внедрить в одну коллекцию с одним и тем же квалификатора.  
 
В этом случае необходимо использовать аннотацию @Qualifier вместе с @Bean вместо элемента name. 

<img width="405" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/f707519b-b4ba-4177-b179-661b66d28b1a">

Только бины с именами refBean2 и refBean3 попадут в коллекцию, так как у них одинаковые квалификаторы - myRefBean. 
 
Упорядочивание элементов массивов / списков 
 
Бины могут быть упорядочены, когда они вставляются в СПИСОК (не Set или Map) или массив.  
 
Поддерживаются как аннотация @Order, так и интерфейс Ordered.  
 
Пример кода:

<img width="499" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/3d45a585-6abe-40ee-8ebb-6c6469b77100">
 
Массив строк будет выглядеть так:  [my string 2, my string 3, my string 1]

<img width="984" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/43122eea-c9fe-42c4-9c33-31c1b5168155">

Также можно объявить бин-коллекцию и внедрять её в другие бины: 

<img width="479" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/754262eb-4b3c-456f-8595-710d513e9a38">

[к оглавлению](#spring)

## 19.	Расскажите про аннотацию @Conditional

Часто бывает полезно включить или отключить весь класс @Configuration, @Component или отдельные методы @Bean в зависимости от каких-либо условий. 
 
Аннотация @Conditional указывает, что компонент имеет право на регистрацию в контексте только тогда, когда все условия соответствуют. Может применяться: 
 
+ над классами прямо или косвенно аннотированными @Component, включая классы @Configuration 
+ над методами @Bean 
+ как мета-аннотация при создании наших собственных аннотаций-условий 
 
Условия проверяются непосредственно перед тем, как должно быть зарегистрировано BeanDefinition компонента, и они могут помешать регистрации данного BeanDefinition. 
Поэтому нельзя допускать, чтобы при проверке условий мы взаимодействовали с бинами (которых еще не существует), с их BeanDefinition -ами можно. 
 
Условия определяются в специально создаваемых классах, которые должны имплементировать функциональный интерфейс Condition с одним единственным методом, возвращающим true или false: 
`boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {} `
 
Создав свой класс и переопределив в нем метод matches() с нашей логикой, необходимо передать этот класс в аннотацию @Conditional в качестве параметра: 

<img width="500" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/3c03379e-0219-48f5-83ff-c41ccf67dcaa">
 
Для того, чтобы проверить несколько условий, можно передать в @Conditional несколько классов с условиями: 

<img width="852" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/fad8ae1a-a57f-4366-b9ce-9e302bcf722f">
 
Если класс @Configuration помечен как @Conditional, то на все методы @Bean, аннотации @Import и аннотации @ComponentScan, связанные с этим классом, также будут распространяться указанные условия. 
 
Для более детальной настройки классов, аннотированных @Configuration, предлагается использовать интерфейс ConfigurationCondition. 
 
В одном классе – одно условие. Для создания более сложных условий можно использовать классы AnyNestedCondition, AllNestedConditions и NoneNestedConditions. 
 
В Spring Framework имеется множество готовых аннотаций (и связанных с ними классамиусловиями, имплементирующими интерфейс Condition), которые можно применять совместно над одним определением бина: 

<img width="1030" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/68575be3-bc3f-45ac-b78a-f0161dfbfa17">

------------------
Аннотация `@Conditional` - это механизм в Spring Framework, который позволяет определять, должен ли быть компонент или конфигурация загруженной и зарегистрированной в контексте приложения, на основе определенных условий.

Как это работает? 🤔

Когда вы помечаете класс или метод аннотацией `@Conditional`, вы указываете Spring, чтобы он выполнил условие, связанное с этой аннотацией, перед тем, как зарегистрировать компонент или применить конфигурацию. Если условие выполняется, компонент будет создан и зарегистрирован; если условие не выполняется, компонент будет пропущен.

Например, предположим, что у вас есть две конфигурации, `DevelopmentConfig` и `ProductionConfig`, и вы хотите, чтобы только одна из них была загружена в зависимости от активного профиля. Вы можете использовать аннотацию `@Conditional` и предоставить свой собственный условный класс, основанный на профиле:

```java
@Configuration
@Conditional(DevelopmentProfileCondition.class)
public class DevelopmentConfig {
    // Конфигурация для разработки
}

@Configuration
@Conditional(ProductionProfileCondition.class)
public class ProductionConfig {
    // Конфигурация для продакшена
}
```

Классы условий, `DevelopmentProfileCondition` и `ProductionProfileCondition`, реализуют интерфейс `Condition` из Spring и определяют, должны ли загружаться соответствующие конфигурации в зависимости от активного профиля.

```java
public class DevelopmentProfileCondition implements Condition {
    @Override
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
        return "development".equals(context.getEnvironment().getProperty("spring.profiles.active"));
    }
}

public class ProductionProfileCondition implements Condition {
    @Override
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
        return "production".equals(context.getEnvironment().getProperty("spring.profiles.active"));
    }
}
```

Таким образом, при запуске приложения и активации профиля "development" будет использоваться `DevelopmentConfig`, а при активации профиля "production" - `ProductionConfig`.

[к оглавлению](#spring)

## 20.	Расскажите про аннотацию @Profile

Профили — это ключевая особенность Spring Framework, позволяющая относить бины к разным профилям (логическим группам), например, dev, test, prod.  
 
Можно активировать разные профили в разных средах, чтобы загрузить только те бины, которые нам нужны. Используя аннотацию @Profile, относим бин к конкретному профилю. Эту аннотацию можно применять на уровне класса или метода.  
 
Аннотация @Profile принимает в качестве аргумента имя одного или нескольких профилей. Она фактически реализована с помощью гораздо более гибкой аннотации @Conditional. 
 
Рассмотрим базовый сценарий. Имеем бин, который должен быть активным только во время разработки, но не должен использоваться в продакшене. Аннотируем этот компонент с профилем «dev», и он будет присутствовать в контейнере только во время разработки, а во время продакшена профиль dev просто НЕ будет активен:

<img width="472" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/4a687adb-92e3-42c4-a814-6366fae67946">

В качестве быстрого обозначения имена профилей также могут начинаться с оператора NOT, например «!dev», чтобы исключить их из профиля. В приведенном примере компонент активируется, только если профиль «dev» не активен

<img width="419" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/d9b4ec5f-06f8-4d9b-804c-c74cba797eca">

Следующим шагом является активация нужного профиля для того, чтобы в контейнере были зарегистрированы только бины, соответствующие данному профилю. Одновременно могут быть активны несколько профилей.

По умолчанию, если профиль бина не определен, то он относится к профилю “default”. Spring также предоставляет способ установить профиль по умолчанию, когда другой профиль не активен, используя свойство «spring.profiles.default». 

В Spring Boot есть возможность иметь один файл настроек application.properties, в котором будут основные настройки для всех профилей, и иметь по файлу настроек для каждого профиля application-dev.properties и application-prod.properties, содержащие свои собственные дополнительные настройки. 

[к оглавлению](#spring)

## 21.	Расскажите про ApplicationContext и BeanFactory, чем отличаются? В каких случаях что стоит использовать?

BeanFactory — это интерфейс, который предоставляет механизм конфигурации, способный управлять объектами любого типа, предоставляет инфраструктуру конфигурации и основные функциональные возможности. Это центральный игрок, отвечает за создание и хранение всех объектов (синглтонов). 
 
ApplicationContext расширяет BeanFactory и полностью реализует его функционал, добавляя больше специфических функций: предоставляет информацию о конфигурации приложения и услуги транзакций, АОП, является источником сообщений для интернационализации (i18n) и обработки событий в приложениях.  
 
Он доступен только для чтения во время выполнения. 

<img width="1232" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/5dc809e8-1bfa-44c6-98f7-ca9f7720b5c5">

ApplicationContext предоставляет:

+ Фабричные методы бина для доступа к компонентам приложения 
+ Возможность загружать файловые ресурсы в общем виде 
+ Возможность публиковать события и регистрировать обработчики на них 
+ Возможность работать с сообщениями с поддержкой интернационализации 
+ Наследование от родительского контекста 

<img width="819" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/d6142059-4d6a-4ae8-9fbc-35f9caee3c6f">

<img width="811" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/70893b28-cd0e-4ca7-b49f-46083f637f1d">

-------
В Spring Framework есть два основных интерфейса для управления и настройки компонентов приложения: `ApplicationContext` и `BeanFactory`. Они оба предоставляют контейнеры для хранения и доступа к бинам (компонентам) в приложении, но есть некоторые отличия между ними.

1. **BeanFactory**: 
   - `BeanFactory` является базовым интерфейсом для внедрения зависимостей и управления бинами.
   - BeanFactory предоставляет базовые функции поиска и резолвинга бинов, а также поддержку жизненного цикла бинов.
   - Он работает по принципу "ленивой инициализации", т.е. бины создаются и инициализируются только при первом обращении к ним. Это может быть полезно в случаях, когда требуется минимизировать начальные затраты ресурсов.
   - Примеры реализаций `BeanFactory`: `DefaultListableBeanFactory`, `XmlBeanFactory`.

2. **ApplicationContext**: 
   - `ApplicationContext` является расширением `BeanFactory` и включает все его функции.
   - ApplicationContext предоставляет дополнительные возможности, такие как поддержка межбиновых связей, событий приложения, межнациональные сообщения и многое другое.
   - Он предварительно создает и предварительно инициализирует все бины, которые должны быть созданы, при старте приложения.
   - ApplicationContext также предоставляет дополнительную настройку и конфигурацию через аспекты, аннотации и XML-конфигурации.
   - Примеры реализаций `ApplicationContext`: `ClassPathXmlApplicationContext`, `AnnotationConfigApplicationContext`, `FileSystemXmlApplicationContext`, `WebApplicationContext` и др.
   
Таким образом, основное различие между BeanFactory и ApplicationContext заключается в их функциональности и времени инициализации бинов. Если вам нужны базовые возможности IoC (внедрение зависимостей) и вы хотите максимизировать производительность, вы можете использовать BeanFactory. Если вам требуется более полный контейнер приложения с дополнительными возможностями, такими как обработка событий и межбиновые связи, то стоит использовать ApplicationContext.

[к оглавлению](#spring)

## 22.	Расскажите про жизненный цикл бина, аннотации @PostConstruct и @PreDestroy

<img width="719" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/19ffb406-668d-411d-8b07-ff9c94922e51">

Bean – центральный объект заботы Spring Framework.  

За кулисами фреймворка с ними происходит множество процессов. Во многие из них можно вмешаться, добавив собственную логику в разные этапы жизненного цикла.  

<img width="943" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/fc5de064-bf11-4168-9781-04a0883c4c0e">

<img width="971" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/3f5e239e-827a-434c-9e11-c2c7203586c5">

Для кого-то эта картинка более понятна 

<img width="969" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/9b0b6d61-1d83-4d72-a2ef-a0bbbdde9a6f">

Создание и настройка Бина по Евгению Борисову (Спринг потрошитель) 

<img width="1105" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/1ffc4425-02ff-40e7-8a18-30bcaaf62dd2">

Через следующие этапы проходит КАЖДЫЙ отдельно взятый бин: 
1.Инстанцирование объекта (создание экземпляра класса): техническое начало жизни бина, работа конструктора его класса. 
 
2.Установка свойств из конфигурации бина, внедрение зависимостей.   
 
3.Нотификация aware*-интерфейсов: BeanNameAware, BeanFactoryAware и других. Технически, выполняется системными подтипами BeanPostProcessor, и совпадает с п.4; 

*Aware

*Маркерный интерфейс Aware служит родителем большому количеству интерфейсов с именами .  
Каждый из них, при реализации, доставляет бину какую-то специфичную для себя сущность. Так, например, компонент, которому нужно обратиться к контексту приложения, должен реализовывать ApplicationContextAware. 
 
Технически, сами интерфейсы ничего не делают. Интерфейс FooAware обычно объявляет единственный метод void setFoo(Foo value). Через этот метод связанный с интерфейсом BeanPostProcessor передаст в бин нужную сущность. 
 
Если бин реализует ServletContextAware, то в процессе инициализации бина к нему придет 
ServletContextAwareProcessor, и вызовет setServletContext с контекстом сервлета в качестве параметра. 
 
4.Пре-инициализация – метод postProcessBeforeInitialization() интерфейса BeanPostProcessor; 
 
5. Инициализация. Разные способы применяются в таком порядке: Метод бина с аннотацией @PostConstruct из стандарта JSR-250 (рекомендуется этот) 
 
Метод afterPropertiesSet() бина под интерфейсом InitializingBean 
 
Init-метод для отдельного бина его имя устанавливается в параметре определения initMethod. В xml-конфигурации можно установить для всех бинов сразу, с помощью default-init-method. 
 
6. Пост-инициализация – метод postProcessAfterInitialization() интерфейса BeanPostProcessor. 

Когда IoC-контейнер завершает свою работу, мы можем кастомизировать этап штатного уничтожения бина. Как со всеми способами финализации в Java, при жестком выключении (kill -9) гарантии вызова этого этапа нет.  

Три альтернативных способа «де-инициализации» вызываются в том же порядке, что симметричные им методы инициализации: 
+ Метод с аннотацией @PreDestroy 
+ Метод с именем, которое указано в свойстве destroyMethod определения бина (или в глобальном default-destroy-method)
+ Метод destroy() интерфейса DisposableBean. 

Не следует путать жизненный цикл отдельного бина с жизненным циклом контекста и этапами подготовки фабрик бинов. О них отдельно. 

<img width="1192" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/49426300-713a-467a-9352-bcedebd45453">

[к оглавлению](#spring)

## 23.	Расскажите про скоупы бинов? Какой скоуп используется по умолчанию?

<img width="1088" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/52aa7899-d538-4404-bc4b-09edd99f246e">

Request, session, global session действительны только в контексте WEB-ориентированного Spring ApplicationContext. 
 
<img width="1139" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/629235c4-fa4a-40af-8f92-9ee45689215c">
 
В Spring Framework во всех определениях бизнес-сущностей (bean) явно или неявно присутствует атрибут scope. В Java-конфигурации он передается в аннотации @Scope, в xml – в атрибуте scope тега <bean>. 
 
Атрибут scope – это строка-идентификатор, которая ставит бину в соответствие экземпляр класса org.springframework.beans.factory.config.Scope.  

Скоуп – реализация паттерна «стратегия» для фабрик бинов, инструкция по созданию бизнес-объектов. 
 
В простейшем Spring-приложении всегда существует два скоупа: 
+ singleton – объект создается однажды, при последующих внедрениях переиспользуется. Полезен для большинства случаев: различные сервисы, объекты без состояния, неизменяемые объекты.  

Это скоуп по умолчанию. 
+ prototype – при каждом внедрении фабрика бинов создает новый объект. Нужен для изменяемых бинов с состоянием. 

Spring Web добавляет 4 дополнительных скоупа, которые делают бин синглтоном в пределах обработки одного сетевого запроса (request), клиентской сессии (session), контекста сервлета (application) и вебсокет-сессии (websocket). 
 
Разработчик может добавлять собственные скоупы.  
Пример реализации одного можно найти в самих исходниках Spring: SimpleThreadScope, который делает бин тред-локальным.  
Для использования его, как и пользовательские скоупы, нужно сначала зарегистрировать в BeanFactory. 

<img width="990" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/a331c64b-f9a0-4dd1-969c-24c2f23f06a0">

**СИНГЛТОН «под капотом»**

<img width="771" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/068673e8-cd36-4338-99d5-62a1897c177c">
 
Управляется только один общий экземпляр одноэлементного компонента, и все запросы компонентов с идентификатором или идентификаторами, совпадающими с определением этого компонента, приводят к тому, что контейнер Spring возвращает этот конкретный экземпляр компонента. 
 
Иными словами, когда вы определяете определение bean-компонента и оно ограничено областью действия синглтона, контейнер Spring IoC создает ровно один экземпляр объекта, определенного этим определением bean-компонента.  
 
Этот единственный экземпляр хранится в кэше таких одноэлементных компонентов, и все последующие запросы и ссылки для этого именованного компонента возвращают кэшированный объект. 
 
**ПРОТОТАЙП «под капотом»**

<img width="942" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/32cdf68b-f537-4e46-8faf-7e8e5fcf0fc7">
 
Не одноэлементная, prototype scope развертывания компонента приводит к созданию нового экземпляра компонента каждый раз, когда делается запрос на этот конкретный компонент.  

То есть компонент вводится в другой компонент или вы запрашиваете его через вызов метода getBean() в контейнере. Как правило, используйте область прототипа для всех bean-компонентов с 
состоянием и область singleton для beanкомпонентов без сохранения состояния.

Следующая диаграмма иллюстрирует область действия прототипа Spring. Объект доступа к данным (DAO) обычно не настраивается в качестве прототипа, поскольку типичный DAO не поддерживает никакого диалогового состояния; 
просто автору было проще повторно использовать ядро одноэлементной диаграммы.

<img width="1105" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/13f971d0-a541-47d1-bbe3-30765764cf90">

----------------------
Концепция скоупов бинов является ключевым аспектом в управлении зависимостями и жизненным циклом объектов в контейнере инверсии управления (IoC), таком как Spring Framework. Скоупы определяют, как и когда создаются объекты-бины и как они взаимодействуют с остальными компонентами в приложении. Рассмотрим подробнее различные скоупы бинов.

1. Singleton (по умолчанию):
   - Все обращения к бину возвращают один и тот же экземпляр объекта.
   - Контейнер создает и инициализирует экземпляр объекта-бина только один раз при первом запросе и повторно использует его для последующих запросов.
   - Это наиболее распространенный скоуп и подходит для большинства случаев использования.
   - Может быть потенциальным источником проблем, если бин имеет изменяемое состояние и параллельное использование в разных потоках.

2. Prototype:
   - При каждом обращении к бину создается новый экземпляр объекта.
   - Контейнер создает новый экземпляр объекта-бина для каждого запроса.
   - Использование прототипного скоупа может привести к созданию большого количества объектов, поэтому рекомендуется осторожно применять его в целях производительности и использования ресурсов.

3. Request:
   - Контекст бина ограничен одним HTTP-запросом (для веб-приложений).
   - Каждый раз, когда обрабатывается новый запрос, создается новый экземпляр объекта-бина.
   - Этот скоуп полезен для бинов, которые содержат данные, специфичные для каждого HTTP-запроса (например, данные пользовательской сессии).

4. Session:
   - Контекст бина ограничен одной пользовательской сессией (для веб-приложений).
   - Каждый раз, когда пользователь запускает новую сессию или подключается к существующей, создается новый экземпляр объекта-бина.
   - Этот скоуп полезен для бинов, которые содержат данные, специфичные для каждой пользовательской сессии (например, данные корзины покупателя).

5. Global Session:
   - Аналогично скоупу Session, но используется в случае использования портала или веб-приложения, поддерживающего глобальную сессию.
   - Обычно используется в среде портлетов (portlet environment).

Портлеты - это небольшие компоненты пользовательского интерфейса, которые могут быть встроены в веб-страницы или порталы. Они предоставляют модульный и переносимый способ добавления функциональности и контента на веб-страницы. Портлеты могут быть независимыми и многократно используемыми, что делает их удобными для создания сложных веб-приложений.

6. Application:
   - Контекст бина ограничен жизненным циклом приложения.
   - Создается и инициализируется один экземпляр объекта-бина при запуске приложения и используется до его остановки.
   - Этот скоуп полезен для бинов, которые должны быть доступными на протяжении всего жизненного цикла приложения.

7. WebSocket:
   - Контекст бина ограничен жизненным циклом WebSocket-соединения.
   - Создается новый экземпляр объекта-бина для каждого WebSocket-соединения.
   - Этот скоуп полезен для бинов, которые имеют состояние, специфичное для каждого WebSocket-соединения.

WebSocket-соединения - это технология, которая обеспечивает постоянное и двустороннее (full-duplex) соединение между клиентом и сервером через одно TCP-соединение. В отличие от традиционных HTTP-запросов, которые являются односторонними и требуют повторного установления соединения для каждого запроса, WebSocket-соединения позволяют отправлять данные в режиме реального времени как от клиента к серверу, так и от сервера к клиенту.

https://stackoverflow.com/questions/49819633/spring-singleton-scope-vs-application-scope - чем скоуп  application отличается от синглтона?

Вы можете иметь несколько контейнеров IoC в одном и том же контейнере сервлетов, поэтому вы можете иметь несколько одноэлементных bean-компонентов одного и того же типа, но только один bean-компонент в области приложения каждого типа.

[к оглавлению](#spring)

## 24.	Что изменилось в пятом (и шестом) спринге?

https://www.youtube.com/watch?v=1I03BB2gteU

<img width="1022" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/58eeb304-813e-4aa3-8e46-8ee6c5118f9c">

<img width="1190" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/144345ab-86c9-4481-a9ea-5e02c237e828">

Что нового в 6 спринг - https://www.youtube.com/watch?v=hZlOBmXmq5g

[к оглавлению](#spring)

## 25.	Расскажите про аннотацию @ComponentScan

Благодаря аннотации @ComponentScan происходит сканирование бин-компонентов. 
Если необходимо, чтобы Spring использовал только определенный набор классов компонентов, то нужно использовать аннотацию @ComponentScan, которая будет указывать на конкретное расположение классов beanкомпонентов, которые Spring должен будет проинициализировать. 

<img width="675" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/6f955f94-34fe-4bea-b438-89803cb783b3">
 
Эту аннотацию можно использовать с параметрами или без них.  
 
Без параметров Spring будет сканировать текущий пакет и его подпакеты, а при параметризации сообщит Spring, где именно искать пакеты. 

По умолчанию классы, аннотированные @Component, @Repository, @Service, @Controller  регистрируются как Spring bean -компоненты. То же самое касается классов, аннотированных пользовательской аннотацией с помощью @Component   

Есть возможность расширить это поведение, используя параметры includeFilters и excludeFilters аннотации @ComponentScan 

Для ComponentScan.Filter доступно пять типов фильтров: 

<img width="1129" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/5b47e815-f8e4-42b8-8e39-2414ad4b7d95">

Примеры кода и статья по ссылке →  https://www.baeldung.com/spring-componentscan-filter-type  

<img width="1171" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/9ea5a88c-7773-43e4-9f28-7f4a09de3f2a">

Вот пример, как можно использовать `@ComponentScan` с фильтром для исключения классов с определенными аннотациями:

```java
@Configuration
@ComponentScan(basePackages = "com.example",
        excludeFilters = @ComponentScan.Filter(type = FilterType.ANNOTATION, value = MyAnnotation.class))
public class AppConfig {
    // Конфигурационный класс
}
```

В приведенном выше примере аннотация `@ComponentScan` используется с атрибутом `excludeFilters`, чтобы исключить классы, имеющие аннотацию `MyAnnotation`, из процесса сканирования и загрузки компонентов.

Заметьте, что вместо использования @ComponentScan вы также можете использовать явное указание компонентов с помощью аннотации @Bean, чтобы регистрировать их в Spring-контексте вручную.

Аннотация @ComponentScan является одним из инструментов автоматической конфигурации в Spring, который существенно упрощает разработку и внедрение зависимостей в приложении.

----------
@ComponentScan - это аннотация Spring, которая указывает контейнеру Spring на сканирование и автоматическую регистрацию компонентов, таких как классы-компоненты, бины, сервисы и другие аннотированные классы, в контексте приложения. При использовании @ComponentScan вы можете указать пакеты, которые должны быть просканированы, и Spring автоматически найдет и зарегистрирует все компоненты в этих пакетах.

Если у вас нет сложной структуры компонентов или если вы регистрируете их вручную с помощью других аннотаций, например, @Configuration и @Bean, то использование @ComponentScan может не понадобиться. Однако в больших проектах с множеством компонентов и зависимостей использование @ComponentScan может упростить конфигурирование и сделать ваш код более модульным и поддерживаемым.

[к оглавлению](#spring)

## 26.	Как спринг работает с транзакциями?

Эффективное управление транзакциями в Spring - https://habr.com/ru/companies/otus/articles/431508/

Управление транзакциями в Spring: @Transactional в деталях - https://habr.com/ru/articles/682362/

*Здесь не рассматриваются распределенные транзакции или реактивные транзакции, хотя общие принципы применимы. Вспомним, что такое транзакции и принципы ACID т.к. Spring использует принципы JDBC  Транзакция – это единица работы в рамках соединения с базой данных.  Для запуска необходимо подключение к базе данных. 
 
Имеет ДВА состояния: 
+ Выполняется полностью – commit 
+ Откатывается полностью – rollback 

<img width="773" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/bca2eeb6-383a-4484-91a4-3188343bcf14">

Вот так Spring устанавливает уровни изоляции для соединения с базой данных: 

<img width="935" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/d3c866ae-4546-49c5-b2a6-bea3c5d21452">

Вложенные транзакции в Spring — это просто точки сохранения JDBC / базы данных.  Поддержка Savepoints (точек сохранения) зависит от драйвера JDBC. 
 
Метод Connection.setSavepoint устанавливает объект Savepoint в текущей транзакции. Метод Connection.rollback перегружен, чтобы принимать аргумент точки сохранения. 
 
В то время как в обычном JDBC есть только один способ управлять транзакциями, setAutocommit(false), Spring предлагает множество различных, более удобных способов добиться того же самого. 
 
ПРОГРАММНЫЙ способ определения транзакций в Spring (редко используется) 
 
+ либо через транзакционный шаблон TransactionTemplate 
+ либо непосредственно через PlatformTransactionManager 
 
<img width="1222" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/e32117ae-8f79-46ab-a97f-064a191e5057">
 
ДЕКЛАРАТИВНЫЙ  
 
Управление транзакциями с помощью XML – это устаревший способ, поскольку он был вытеснен гораздо более простой аннотацией @Transactional (современный способ). 

-------------
🌱 Spring Framework предлагает мощную поддержку для управления транзакциями в приложениях Java. Он основан на применении аннотаций и конфигурационных файлов для определения транзакционного поведения. Рассмотрим основные подходы, которые применяются в Spring для работы с транзакциями.

1️⃣ Декларативный подход:
Spring поддерживает декларативное управление транзакциями с использованием аннотаций. Вы можете просто аннотировать методы, которые должны выполняться в рамках транзакции, определенной Spring. Некоторые из основных аннотаций, используемых для управления транзакциями, включают:

- `@Transactional`: Аннотация, которая указывает, что метод должен быть выполнен в рамках транзакции. Можно применять к классам или методам.

- `@Transactional(propagation)`: Позволяет настроить распространение транзакции, например, `REQUIRED`, `REQUIRES_NEW`, `NESTED` и другие.

- `@Transactional(isolation)`: Устанавливает уровень изоляции транзакции, такой как `READ_COMMITTED`, `SERIALIZABLE`, `REPEATABLE_READ` и другие.

- `@Transactional(readOnly)`: Указывает, что транзакция только для чтения и не должна вносить изменения в базу данных.

Пример использования аннотаций для управления транзакциями:

```java
@Transactional
public void performTransactionalOperation() {
    // Логика операции
}
```

2️⃣ Программный подход:
Spring также предоставляет программный API для управления транзакциями. Вы можете использовать `TransactionTemplate` для явного управления началом, фиксацией и откатом транзакций. Этот подход обычно применяется в случаях, когда требуется более гибкое управление транзакциями.

Пример использования программного API для управления транзакциями:

```java
@Autowired
private PlatformTransactionManager transactionManager;

public void performTransactionalOperation() {
    TransactionTemplate transactionTemplate = new TransactionTemplate(transactionManager);
    transactionTemplate.execute(status -> {
        // Логика операции
        return null;
    });
}
```

[к оглавлению](#spring)

## 27.	Расскажите про аннотацию @Transactional

Мы можем использовать @Transactional для включения метода в транзакцию БД. 
 
Это позволяет нам установить условия распространения, изоляции, тайм-аута, только для чтения и отката для транзакции. Мы также можем указать менеджера транзакций. 
 
Детали реализации: 
Spring создает прокси или манипулирует байт-кодом класса для управления созданием, фиксацией и откатом транзакции.  
 
В случае прокси Spring игнорирует @Transactional  во внутренних вызовах методов. Если у нас есть такой метод, как callMethod , и мы помечаем его как @Transactional, Spring обернет некоторый код управления транзакциями вокруг вызываемого метода @Transactional

<img width="391" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/07967be7-feb4-4e29-b99e-16c26ab39dd6">
 
Декларативное управление транзакциями, Declarative Transaction Management. 
 
Для работы с транзакциями Spring Framework использует AOP-прокси: 

<img width="980" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/485cc889-e81a-4305-ae86-47837d1b5da6">

Для включения возможности управления транзакциями первым делом нужно разместить аннотацию @EnableTransactionManagement у класса-конфигурации @Configuration  
 
Это означает, что классы, помеченные @Transactional, должны быть обернуты АСПЕКТОМ транзакций. Однако, если используем Spring Boot и имеем зависимости spring-data-* или spring-tx, то управление транзакциями будет включено по умолчанию. 
 
@EnableTransactionManagement отвечает за регистрацию необходимых компонентов Spring, таких как TransactionInterceptor и советы прокси (proxy advices- набор инструкций, выполняемых на точках среза - Pointcut).  
 
Регистрируемые компоненты помещают перехватчик в стек вызовов при вызове методов @Transactional. 
 
Spring создает прокси для всех классов, помеченных @Transactional (либо если любой из методов класса помечен этой аннотацией). Прокси-объекты позволяют Spring Framework вводить транзакционную логику до и после вызываемого метода - главным образом для запуска и коммита / отката транзакции. 

<img width="1114" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/cdcaffcf-06be-43df-a9e5-d1cc030fcd99">

UserService проксируется на лету, и прокси управляет транзакциями для вас.  Но НЕ сам прокси управляет всем этим транзакционным состоянием (открыть, зафиксировать, закрыть), прокси делегирует эту работу менеджеру транзакций. 
 
Spring предлагает интерфейс PlatformTransactionManager / TransactionManager, который по умолчанию поставляется с парой удобных реализаций. Одна из них – это менеджер транзакций источника данных. 
 
Менеджер транзакций источника данных использует «под капотом» при управлении транзакциями точно такой же код, который мы использовали в разделе JDBC. 

<img width="1092" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/1221d4c8-0f05-4915-a942-a2ea7afe00fa">

<img width="1004" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/7dd1aeed-3ac4-4b79-98f8-b572aefb9d07">

+ Физические транзакции: это фактические транзакции JDBC. 
+ Логические транзакции: это (потенциально вложенные) аннотированные @Transactional методы Spring

Spring теперь должен быть достаточно умным, чтобы две логические транзакции (invoice()/createPdf()) отображались на две разные физические транзакции базы данных:

<img width="1134" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/d7f900f0-e18a-4423-87d7-6ce8da11a80b">

**What are @Transactional Propagation Levels used for?**
 
Изучая код Spring, вы найдете множество уровней или режимов распространения, которые можно подключить к методу @Transactional. 

https://www.baeldung.com/spring-transactional-propagation-isolation  

<img width="587" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/6c0bffb9-b545-444b-93b6-53d49d018db1">

<img width="1003" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/a194f225-3f61-4342-8b2d-22eb80aba111">

<img width="1002" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/064e8865-c20e-434a-9e93-77b265482a34">

Большинство режимов, уровней распространения Propagation Levels не имеют ничего общего с базой данных или JDBC, но больше с тем, как вы структурируете свою программу со Spring: КАК, ГДЕ и КОГДА Spring ожидает присутствия транзакций. 

<img width="444" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/daecfd2a-f930-4e80-804d-061fbe56840f">
 
В этом случае Spring будет ожидать, что транзакция будет открыта, когда вы вызовете myMethod() класса UserService.  
 
Он не открывает её сам, вместо этого, если вызвать этот метод без предварительно существующей транзакции, Spring выбросит исключение.  Это дополнительные нюансы при "логической обработке транзакций". 

**Подводные камни**
 
Есть класс UserService с транзакционным методом invoice(), который вызывает createPDF(), который также является транзакционным. 

<img width="517" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/0bd3afdf-4c43-4c60-b89a-b8265846b521">
 
Сколько физических транзакций будет открыто, когда кто-то вызовет invoice()? Нет, ответ будет не два, а один. Почему? 
 
Spring создает транзакционный прокси UserService, но как только мы оказываемся внутри класса UserService и вызываем другие внутренние методы, прокси больше не задействован. Это означает, что новой транзакции не будет. 
 
Есть несколько приёмов (например, самоинъекция), которые можно использовать, чтобы обойти это ограничение. Но главный вывод: всегда помните о ГРАНИЦАХ транзакций PROXY. 

[к оглавлению](#spring)

## 28.	Расскажите про аннотации @Controller и @RestController. Чем они отличаются?

<img width="539" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/95972919-3f8e-484c-8e12-5b1b66b9af67">

If you use @RestController you cannot return a view (By using Viewresolver in Spring/springboot) and yes @ResponseBody is not needed in this case.

If you use @Controller you can return a view in Spring web MVC.

Controller – это один из стереотипов Spring Framework. Компоненты такого типа обычно занимаются обработкой сетевых запросов. Контроллер состоит из набора методовобработчиков, помеченных аннотацией  @RequestMapping. 
 
Ответ на запрос можно сформировать разными способами: например, просто вернуть из обработчика строку с именем jsp-файла, или же вернуть ResponseBodyEmitter, который будет асинхронно заполняться данными позже. Все возможные варианты перечислены в документации.            https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-return-types   

Большинство современных API реализуется по архитектуре REST.  В ней каждая сущность доступна под собственным URI*. 
 
URI — унифицированный идентификатор ресурса, последовательность символов, идентифицирующая абстрактный или физический ресурс. Ранее назывался Universal Resource Identifier — универсальный идентификатор ресурса. 
 
В методе-обработчике возвращается экземпляр класса этой сущности, который преобразуется в ответ сервера одним из HttpMessageConverter-ов. Например, в JSON его превратит MappingJackson2HttpMessageConverter.  
 
Чтобы использовать этот способ ответа, метод, или весь контроллер, должен иметь аннотацию @ResponseBody. 

<img width="1124" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/198fb917-d57c-4556-8f3f-1bb1ebd6ba52">

Аннотация @ResponseBody ставится на методы, которые работают с данными, а не с моделями. Ее не требуется указывать явно, если используется @RestController.  
 
Обычные методы возвращают Model, а методы аннотированные @ResponseBody возвращают объекты, которые конвертируются в медиафайлы с помощью HttpMessageConverter. 

@ResponseBody - The return value is converted through HttpMessageConverter implementations and written to the response. 

--------------
Аннотации `@Controller` и `@RestController` являются частью фреймворка Spring и используются для создания веб-приложений. 

`@Controller` - это аннотация, которая указывает на то, что класс является компонентом контроллера веб-приложения. Она обычно используется для создания MVC-приложений (Model-View-Controller), где контроллер обрабатывает входящие запросы, выполняет необходимые операции и возвращает представления.

`@RestController` - это специальная версия `@Controller`, которая, помимо обработки запросов, автоматически преобразует возвращаемые значения в формат JSON или XML (в зависимости от настроек). Она нацелена на создание веб-сервисов RESTful API, где ответы контроллера представляют данные в формате JSON или XML, а не представления.

Основное отличие между ними заключается в том, как они обрабатывают результаты выполнения контроллером. В случае `@Controller` возвращаемое значение будет интерпретироваться как имя представления, которое должно быть отрисовано и возвращено клиенту. В случае `@RestController` возвращаемое значение будет сериализовано в JSON или XML и возвращено клиенту в качестве ответа.

Таким образом, если вам нужно создать веб-приложение, которое предоставляет представления для отображения в браузере, используйте `@Controller`. Если вам нужно создать веб-сервис, который предоставляет данные в формате JSON или XML, используйте `@RestController`.

-------------
Аннотации `@Controller` и `@RestController` входят в Spring Framework и используются для создания веб-контроллеров в приложениях Java.

`@Controller` аннотация указывает, что класс является контроллером, который обрабатывает HTTP-запросы. Контроллер обычно содержит методы, аннотированные `@RequestMapping` или его производными аннотациями, которые указывают на URL-шаблоны и определяют, как должны быть обработаны входящие запросы. 

В контроллере с аннотацией `@Controller` методы могут возвращать различные типы результатов, такие как `ModelAndView`, `String` (имя представления), `void` и другие.

Пример контроллера с аннотацией `@Controller`:

```java
@Controller
@RequestMapping("/example")
public class ExampleController {
    
    @RequestMapping("/hello")
    public String hello(Model model) {
        model.addAttribute("message", "Hello, World!");
        return "hello-page";
    }
}
```

`@RestController` аннотация комбинирует в себе аннотации `@Controller` и `@ResponseBody`. Класс с аннотацией `@RestController` представляет RESTful веб-сервис и используется для создания веб-контроллеров, которые автоматически преобразуют Java-объекты в формат JSON или XML и отправляют в ответ клиенту. Обычно методы контроллера с аннотацией `@RestController` возвращают данные (например, объекты или коллекции), которые могут быть сериализованы и отправлены клиенту.

Пример контроллера с аннотацией `@RestController`:

```java
@RestController
@RequestMapping("/api")
public class ApiController {
    
    @GetMapping("/users")
    public List<User> getUsers() {
        List<User> users = userService.getUsers();
        return users;
    }
    
    @PostMapping("/users")
    public ResponseEntity<User> addUser(@RequestBody User user) {
        userService.addUser(user);
        return new ResponseEntity<>(user, HttpStatus.CREATED);
    }
}
```

Таким образом, основное отличие между `@Controller` и `@RestController` заключается в том, что `@RestController` предназначен для создания RESTful веб-сервисов и автоматически преобразует возвращаемые данные в формат JSON или XML. В то же время `@Controller` может возвращать различные типы результатов, включая представления (views) для отображения HTML-страниц.

------------
Пометка `@ResponseBody` - это аннотация, используемая в фреймворках разработки веб-приложений, таких как Spring или Spring Boot, для указания, что возвращаемое значение метода контроллера должно быть преобразовано в тело ответа HTTP, вместо визуализации представления.

Когда вы добавляете `@ResponseBody` к методу контроллера, это означает, что результат метода должен быть преобразован в формат ответа HTTP (обычно JSON или XML) и возвращен напрямую в теле ответа, без визуализации представления. Он может использоваться для возврата данных RESTful API или для реализации точек входа API.

Например, в Spring-приложении контроллер может быть определен следующим образом:

```java
@RestController
public class MyController {

    @GetMapping("/api/user/{id}")
    public @ResponseBody User getUserById(@PathVariable int id) {
        // Логика для получения пользователя по идентификатору
        User user = userService.getUserById(id);
        return user;
    }
}
```

В приведенном выше примере метод `getUserById` возвращает объект `User`. Благодаря аннотации `@ResponseBody` объект `User` будет автоматически преобразован в JSON (по умолчанию) и возвращен в теле ответа HTTP.

Одной из причин, почему возврат ответа в формате JSON или XML с использованием аннотации `@ResponseBody` стал популярным выбором, является эволюция веб-разработки в сторону создания RESTful API и разделения передачи данных и представления.

Возврат данных в формате представления (например, HTML) был стандартным подходом в традиционной веб-разработке, где серверная сторона генерировала представление и отправляла его на клиентскую сторону для отображения.

Однако с развитием клиентской стороны JavaScript и разработки одностраничных приложений (SPA), стало популярным использовать серверную сторону только для предоставления данных через API. В этом случае клиентская сторона (например, фронтенд-фреймворк, такой как React или Angular) отвечает за отображение данных и состояния интерфейса пользователя.

Преимущества возврата ответа в формате данных (JSON/XML) с использованием `@ResponseBody`:

1. Гибкость формата данных: Возвращение данных через API в формате JSON или XML позволяет легко интегрировать серверную часть с различными клиентскими приложениями, включая веб-приложения, мобильные приложения, сторонние сервисы и т. д.

2. Уменьшение нагрузки на сервер: При возврате только данных, а не полноценных HTML-страниц, размер ответов уменьшается, что ведет к снижению использования сетевого трафика и ресурсов сервера.

3. Разделение ответственности: Основываясь на принципе разделения ответственности (Separation of Concerns), выделение серверной части только для предоставления данных обеспечивает ясное разделение между клиентским и серверным кодом, упрощая поддержку и расширение системы.

4. Легкая масштабируемость: Возврат данных в формате JSON или XML делает API более гибким и удобным для масштабирования. Разработчики могут добавлять новые эндпоинты и расширять функциональность API, не затрагивая представления данных.

5. Возможность использования различных клиентских технологий: Благодаря формату данных, клиентская сторона может быть разработана с использованием различных технологий и фреймворков. Например, React, Angular, мобильные приложения или сторонние сервисы могут использовать API для получения данных.

6. Улучшенная производительность: Возвращение только данных без генерации полноценного HTML-представления сокращает затраты на обработку и ускоряет время отклика сервера.

В целом, использование `@ResponseBody` для возврата данных в формате JSON или XML позволяет разработчикам создавать более гибкие, масштабируемые и отделенные от представления веб-приложения, что объясняет его популярность в современной веб-разработке.

[к оглавлению](#spring)

## 29.	Как вернуть ответ со своим статусом (например, 213)?

Можно создавать свои ошибки, указывая через аннотации код ответа сервера и сообщение об ошибке.  
 
В случае выкидывания кодом такой ошибки в процессе обработки запроса спринг автоматически преобразует ее в JSON ответ со всей нужной информацией и код ответа будет соответствующий. 
 
Если же надо изменить код для ответа без ошибки, то можно так (код на java): 
 
Шаг 1: указываем возвращаемый тип метода контроллера как ResponseEntity<?> 
 
Шаг 2: возвращаем из метода контроллера  
new ResponseEntity<>(someObjectThatWillBeSerializedToJsonBySpring, HttpStatus.CREATED);  
 
или ResponseEntity.status(201).body(someObjectThatWillBeSerializedToJsonBySpring) 
 
Либо можно попробовать добавить аннотацию для метода контроллера: 
@ResponseStatus(HttpStatus.CREATED) 

---------------
Чтобы вернуть ответ с собственным статусом в Java Spring, вы можете воспользоваться объектом `org.springframework.http.ResponseEntity`. Этот объект позволяет вам указать не только тело ответа, но и статус код, заголовки и другие атрибуты.

Вот пример кода, демонстрирующий, как вернуть ответ со статусом 213 (Custom Status Code):

```java
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import ...

@RequestMapping("/your-endpoint")
public ResponseEntity<String> yourEndpointMethod() {
    // Ваша логика здесь

    String responseBody = "Пример ответа со своим статусом";
    HttpStatus customStatus = HttpStatus.valueOf(213);

    return new ResponseEntity<>(responseBody, customStatus);
}
```

В этом примере мы создаем объект `ResponseEntity`, передавая в него тело ответа `responseBody` и собственный статус код `customStatus`. Затем мы возвращаем этот объект из метода контроллера `yourEndpointMethod`.

Обратите внимание, что не все статус коды являются стандартными и поддерживаются всеми клиентами. Поэтому учитывайте это при выборе собственного статуса.

[к оглавлению](#spring)

## 30.	Что такое ViewResolver?

Все платформы MVC предоставляют способ работы с представлениями View. 
 
Spring делает это с помощью ViewResolver, который позволяет отображать модели в браузере, не привязывая реализацию к определенной технологии представления. 
 
ViewResolver сопоставляет имена представлений, возвращаемых методами контроллеров, с фактическими представлениями (html-файлами).  
 
Spring Framework поставляется с довольно большим количеством ViewResolver, например InternalResourceViewResolver, XmlViewResolver, ResourceBundleViewResolver и несколькими другими. 
 
По умолчанию реализацией интерфейса ViewResolver является класс InternalResourceViewResolver. Любым реализациям ViewResolver желательно поддерживать интернационализацию, то есть множество языков. 

----------------
ViewResolver в Spring - это интерфейс, который используется для определения, как Spring MVC должен найти и обработать представление (view) для возвращаемого контроллером результата. Он отвечает за нахождение фактического файла представления (как правило, шаблон HTML) и его обработку.

Основная задача ViewResolver состоит в преобразовании логического имени представления, возвращаемого из контроллера, в физический путь к файлу представления на основе заданных правил разрешения.

Spring предоставляет несколько реализаций интерфейса ViewResolver, таких как:

1. InternalResourceViewResolver: Разрешает представления в виде JSP или HTML файлов внутри директории WEB-INF.
2. ThymeleafViewResolver: Разрешает представления с использованием шаблонизатора Thymeleaf.
3. ResourceBundleViewResolver: Разрешает представления из файлов ресурсов ResourceBundle.
4. и другие.

Когда контроллер возвращает имя представления в виде строки, Spring MVC использует заданный ViewResolver для поиска соответствующего представления и его обработки в соответствующий HTML или другой формат перед его отправкой в качестве ответа клиенту.

Ниже приведен пример конфигурации `InternalResourceViewResolver` в файле `application-context.xml`:

```xml
<bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver">
    <property name="prefix" value="/WEB-INF/views/"/>
    <property name="suffix" value=".jsp"/>
</bean>
```

В этом примере задан `InternalResourceViewResolver` для разрешения представлений, находящихся в директории "/WEB-INF/views/" и имеющих расширение ".jsp".

ViewResolver позволяет разделить логику обработки контроллера и логику отображения представления, что обеспечивает более гибкую и модульную разработку приложений на основе Spring MVC.

------------
ViewResolver в Spring - это интерфейс, который определяет механизм разрешения представлений (views) для веб-приложения. Он используется для связывания логических имен представлений с соответствующими файлами или компонентами, которые будут обрабатывать и генерировать представление в ответ на запросы клиента.

Spring предоставляет несколько реализаций интерфейса ViewResolver "из коробки", и вы также можете создать свою собственную реализацию, если это необходимо.

Процесс работы с ViewResolver в Spring следующий:
1. Запрос от клиента поступает на сервер.
2. DispatcherServlet, который является центральным контроллером в Spring MVC, получает запрос.
3. DispatcherServlet получает имя представления из контроллера или другой логики обработки запроса.
4. DispatcherServlet обращается к ViewResolver для поиска реального представления по его логическому имени.
5. ViewResolver возвращает реальное представление.
6. DispatcherServlet использует полученное представление для генерации ответа на запрос клиента.

ViewResolver занимается поиском и выбором соответствующего представления (view) на основе имени, которое возвращает обработчик запроса (контроллер). Он не вносит данные в представление, а только определяет, какое представление будет использовано для отображения данных.

Когда ViewResolver найдет представление, он возвращает его DispatcherServlet, который берет на себя ответственность за заполнение представления данными из модели. DispatcherServlet получает данные из модели, которые были добавлены в нее контроллером, и передает их в представление для отображения. Это делается с помощью объекта ModelAndView, который содержит модель и имя представления.

Таким образом, ViewResolver играет роль в выборе представления, а DispatcherServlet отвечает за передачу данных модели в выбранное представление.

Один из основных принципов разработки Spring MVC заключается в том, чтобы разделить логику обработки запросов (контроллеры) и отображение представлений. ViewResolver был введен в Spring MVC для достижения этой цели.

Разделение обработки запросов и отображения представлений позволяет более гибко управлять процессом отображения данных. Отделение этой функциональности позволяет использовать различные типы представлений и разные стратегии их поиска. В результате, можно легко изменить способ отображения данных без изменения контроллеров.

ViewResolver предоставляет абстракцию, которая позволяет настраивать и подменять стратегии поиска представлений. Например, можно настроить ViewResolver для поиска представлений в разных источниках, таких как файловая система, база данных или удаленные серверы. Это предоставляет гибкость и расширяемость при разработке веб-приложений.

Кроме того, позволить DispatcherServlet искать представления самостоятельно может повлечь к наплыву логики отображения внутри контроллеров, что усложнит их поддержку и тестирование. Разделение обязанностей позволяет сделать код контроллеров более чистым и поддерживаемым.

Таким образом, разделение функций между ViewResolver и DispatcherServlet является одной из принятых практик в разработке Spring MVC для достижения гибкости, расширяемости и поддерживаемости веб-приложений.💡

[к оглавлению](#spring)

## 31.	Чем отличаются Model, ModelMap и ModelAndView?

Model 
 
ИНТЕРФЕЙС, лежит в пакете spring-context.  В методах контроллера можно использовать объекты Model для того, чтобы складывать туда данные, предназначенные для формирования представлений. Кроме того, в Model мы можем передать даже Map с атрибутами → 

<img width="673" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/d0798b93-1660-429c-87ea-7c83175b15e0">
 
ModelMap 
 
Этот КЛАСС наследуется от LinkedHashMap<String, Object>  и, по сути, служит общим контейнером модели для Servlet MVC, но не привязан к нему, и лежит в пакете spring-context.  
 
Имеет все преимущества LinkedHashMap плюс несколько удобных методов: 

<img width="737" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/db3e71c9-39b7-4e79-93d0-70e96bd3f2de">
 
ModelAndView 
 
Этот КЛАСС лежит в пакете spring-webmvc и может одновременно хранить модели и представление, чтобы контроллер мог отдавать их в ОДНОМ возвращаемом значении.  
 
Внутри содержит поле private Object view, куда записывает нужное представление, а также поле private ModelMap model,  
куда и складывает все атрибуты модели → 

<img width="741" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/9e9db050-9514-4522-9f2a-e3778e8f029a">

-----------
Model, ModelMap и ModelAndView - это классы в Spring, используемые для передачи данных из контроллера в представление (view) в процессе обработки запросов. Они имеют некоторые отличия в своем использовании:

1. Model:
   - Model - это интерфейс, предоставляемый Spring MVC, который позволяет добавлять атрибуты в модель данных для передачи их в представление.
   - В контроллере можно использовать объект типа Model для добавления атрибутов, используя метод `addAttribute()`. Например:
     ```java
     @Controller
     public class MyController {
         @RequestMapping("/my-url")
         public String myHandlerMethod(Model model) {
             model.addAttribute("name", "John");
             model.addAttribute("age", 25);
             return "my-view";
         }
     }
     ```
   - Атрибуты, добавленные в Model, будут доступны в представлении при его отображении.

2. ModelMap:
   - ModelMap - это класс, реализующий интерфейс Model, и предоставляющий дополнительные методы для работы с моделью данных.
   - Он предоставляет те же самые методы, что и Model, но также позволяет выполнять другие операции, такие как удаление атрибутов из модели или получение доступа к атрибутам модели для чтения. 
   - Пример использования ModelMap:
     ```java
     @Controller
     public class MyController {
         @RequestMapping("/my-url")
         public String myHandlerMethod(ModelMap modelMap) {
             modelMap.addAttribute("name", "John");
             modelMap.addAttribute("age", 25);
             return "my-view";
         }
     }
     ```

3. ModelAndView:
   - ModelAndView - это класс, который объединяет модель данных (Model) со сведениями о представлении (View), которое должно быть отображено и другой информацией.
   - Он позволяет указывать имя представления (View) и добавлять модельные атрибуты вместе в один объект.
   - Пример использования ModelAndView:
     ```java
     @Controller
     public class MyController {
         @RequestMapping("/my-url")
         public ModelAndView myHandlerMethod() {
             ModelAndView modelAndView = new ModelAndView();
             modelAndView.setViewName("my-view");
             modelAndView.addObject("name", "John");
             modelAndView.addObject("age", 25);
             return modelAndView;
         }
     }
     ```

Все три - Model, ModelMap и ModelAndView - предоставляют способы передачи данных из контроллера в представление, но имеют некоторые различия в своем использовании и функциональности. Выбор конкретного класса зависит от ваших потребностей и предпочтений разработки.

Когда контроллер возвращает `ModelAndView` в `DispatcherServlet`, `DispatcherServlet` обрабатывает этот объект и выполняет рендеринг представления без необходимости использовать `ViewResolver`.

`DispatcherServlet` внутренне использует различные компоненты, включая `ViewResolver`, для преобразования имени представления, указанного в `ModelAndView`, в конкретное представление для рендеринга. Однако при использовании `ModelAndView` контроллер уже предоставляет конкретное представление, и `DispatcherServlet` просто использовать его напрямую без дальнейшего разрешения через `ViewResolver`.

Поскольку вы доверяете `DispatcherServlet` для рендеринга представления, вам не нужно явно настраивать `ViewResolver`, если вы используете `ModelAndView`. Однако вам все равно нужно убедиться, что у вас есть соответствующий конфигурационный файл Thymeleaf, чтобы `DispatcherServlet` знал о спецификах рендеринга представления.

[к оглавлению](#spring)

## 32.	Расскажите про паттерн MVC, как он реализован в Spring?

<img width="855" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/37ca44c0-3329-4b62-872a-f938b671424a">

<img width="1165" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/163fb02d-dd7a-4e28-8cc6-1ab4f0283292">

----------------
Паттерн MVC (Model-View-Controller) - это архитектурный паттерн, который используется для разделения приложения на три основных компонента: модель (Model), представление (View) и контроллер (Controller). Этот подход способствует разделению логики бизнес-приложения, пользовательского интерфейса и обработки запросов.

В Spring фреймворке MVC (также известном как Spring MVC или Spring Web MVC) паттерн MVC реализован через следующие основные компоненты:

1. Модель (Model):
   - Модель представляет данные, с которыми работает приложение и логику для их обработки.
   - В Spring модель может представляться как просто объекты Java (POJO), так и объекты, аннотированные как `@Entity` в случае работы с JPA (Java Persistence API).
   - Модель может быть передана в представление (View) через контроллер (Controller) для отображения данных.

2. Представление (View):
   - Представление определяет, как данные из модели будут отображаться пользователю.
   - В Spring представление может быть представлено в виде JSP (JavaServer Pages), Thymeleaf, FreeMarker шаблонов или других типов представлений.
   - Шаблонизаторы предоставляют возможность встраивать данные из модели в представления с использованием выражений и тегов.

3. Контроллер (Controller):
   - Контроллер отвечает за обработку входящих запросов от клиента и принимает решение, какую модель и представление использовать для формирования ответа.
   - В Spring контроллеры обычно создаются с помощью аннотаций, таких как `@Controller` и `@RequestMapping`.
   - Контроллеры взаимодействуют с моделью для получения данных и обновления модели на основе входящих запросов, после чего они возвращают представление, которое будет отображаться пользователю.

Spring MVC обеспечивает простую и гибкую реализацию паттерна MVC, предоставляя механизмы для управления потоком запросов и связывания данных с моделью и представлением. Он обеспечивает централизованную обработку запросов, в которой каждый запрос обрабатывается соответствующим контроллером, который определяет модель и представление для ответа на запрос.

[к оглавлению](#spring)

## 33.	Расскажите про паттерн Front Controller, как он реализован в Spring?

Как конфигурировать сервлет в java congifg вместо использования web.xml - https://www.baeldung.com/spring-xml-vs-java-config

Паттерн Front Controller обеспечивает единую точку входа для всех входящих запросов.  
 
В Spring в качестве Front Controller выступает DispatcherServlet, все действия проходят через него. Как правило в приложении задаётся только один DispatcherServlet с маппингом “/”, который перехватывает все запросы.

Это и есть реализация паттерна Front Controller. 
 
Все запросы обрабатываются ОДНИМ фрагментом кода, который затем может делегировать ответственность за обработку запроса другим объектам приложения.  
 
Он также обеспечивает интерфейс для общего поведения, такого как безопасность, интернационализация и передача определенных представлений определенным пользователям. 
 
Однако иногда необходимо определить два и более DispatcherServlet-а, которые будут отвечать за свой собственный функционал. Например, чтобы один обрабатывал RESTзапросы с маппингом “/api”, а другой обычные запросы с маппингом “/default”.  
 
Spring предоставляет нам такую возможность, и для начала нужно понять, что: 

<img width="484" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/f3847d95-5d62-4dd4-af50-0a2c10b15b82">
 
Spring может иметь НЕСКОЛЬКО КОНТЕКСТОВ одновременно. Одним из них будет корневой контекст, а все остальные контексты будут дочерними. 
 
Все дочерние контексты могут получить ДОСТУП К БИНАМ, определенным в корневом контексте, но НЕ наоборот.  
 
Корневой контекст НЕ может получить доступ к бинам дочерних контекстов. 
 
Каждый дочерний контекст внутри себя может переопределить бины из корневого контекста. 
 
Каждый DispatcherServlet имеет свой дочерний контекст приложения. DispatcherServlet расширяет HttpServlet, основной целью которого является обработка входящих вебзапросов, соответствующих настроенному шаблону URL.  
 
Он принимает входящий URI и находит правильную комбинацию контроллера и вида.  Веб-приложение может определять любое количество DispatcherServlet-ов. Каждый из них будет работать в своем собственном пространстве имен, загружая свой собственный дочерний WebApplicationContext (на рисунке - Servlet WebApplicationContext) с вьюшками, контроллерами и т.д.  
 
Например, когда необходимо в одном Servlet WebApplicationContext определить обычные контроллеры, а в другом REST-контроллеры. 
 
WebApplicationContext расширяет ApplicationContext (создаёт и управляет бинами и т.д.), но помимо этого он имеет дополнительный метод getServletContext(), через который у него есть возможность получать доступ к ServletContext-у. 
 
ContextLoaderListener создает корневой контекст приложения  (на рисунке - Root WebApplicationContext) и будет использоваться всеми дочерними контекстами, созданными всеми DispatcherServlet.  
 
<img width="572" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/9154f367-c968-49c3-aa10-722f91c6e195">
 
Корневой контекст приложения будет общим и может быть только один.  
 
Root WebApplicationContext содержит компоненты, которые видны всем дочерним контекстам, такие как сервисы, репозитории, компоненты инфраструктуры и т.д.  
 
После создания корневого контекста приложения он сохраняется в ServletContext как атрибут, имя которого: WebApplicationContext.class.getName() + ".ROOT"  
 
Чтобы из контроллера любого дочернего контекста обратиться к корневому контексту приложения, можно использовать класс  WebApplicationContextUtils, 
содержащий статические методы → 
 
<img width="629" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/f714cb47-a81f-493e-bda6-1c81348bfb15">
 
ContextLoaderListener создает корневой контекст приложения.

<img width="1208" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/95dbd097-06c3-4602-a74c-a61b9ff246e3">

----------------
Паттерн Front Controller - это архитектурный паттерн, используемый для централизованной обработки входящих запросов в веб-приложении. Он основывается на принципе единой точки входа, где все запросы передаются в общий компонент - фронт-контроллер (Front Controller), который координирует обработку запросов и принимает решение о том, какой обработчик запроса вызвать.

В Spring фреймворке Front Controller реализован через модуль Spring Web MVC, которая предоставляет функциональность для обработки веб-запросов в приложении. Основной компонент, который реализует роль фронт-контроллера в Spring, - это `DispatcherServlet`.

Вот основные шаги, которые происходят при обработке запроса с использованием Front Controller в Spring:

1. В конфигурации приложения указывается, что все входящие запросы от клиента должны быть обработаны `DispatcherServlet`.

2. Клиент отправляет запрос на сервер.

3. `DispatcherServlet` является точкой входа для всех запросов и принимает входящий запрос.

4. Он определяет, какой контроллер (Handler) будет обрабатывать этот запрос. Для этого `DispatcherServlet` консультируется с конфигурацией URL-сопоставления (также известной как маппинг URL) и определяет, какой контроллер должен быть вызван на основе пути запроса.

5. Выбранный контроллер обрабатывает запрос. Он может взаимодействовать с различными сервисами и моделями, выполнять необходимую логику и подготавливать данные для ответа.

6. После обработки запроса контроллер возвращает модель данных и имя представления (View Name) обратно в `DispatcherServlet`.

7. `DispatcherServlet` консультируется с конфигурацией представлений (View Resolver) для определения фактического представления (View), которое будет использоваться для формирования ответа. Это может быть JSP, Thymeleaf-шаблон или другой тип представления.

8. Формируется ответ, используя выбранное представление и модель данных.

9. Ответ отправляется обратно клиенту.

Таким образом, в Spring паттерн Front Controller реализуется `DispatcherServlet`, который обеспечивает централизованную обработку запросов и координацию между контроллерами и представлениями.

-----------------
В приложении может быть несколько сервлетов по разным причинам. Вот несколько распространенных сценариев:

1. Разделение функциональности: Если приложение имеет различные функциональные области или модули, каждый из них может быть обслуживаем специфическим сервлетом. Например, у вас может быть сервлет, отвечающий за аутентификацию и авторизацию пользователей, а другой сервлет, отвечающий за обработку и отображение информации.

2. Обработка разных URL-шаблонов: Если у вас есть несколько URL-шаблонов или путей, которые требуют разных обработчиков или логики, каждый из них может быть связан с отдельным сервлетом. Например, у вас может быть сервлет, отвечающий за запросы, начинающиеся с "/api", и другой сервлет, отвечающий за запросы, начинающиеся с "/admin".

3. Предоставление разных точек входа: Если вам требуется предоставить различные точки входа в ваше приложение для разных типов клиентов или платформ, каждая точка входа может быть обслужена отдельным сервлетом. Например, у вас может быть сервлет, предоставляющий точку входа для веб-клиентов, и другой сервлет, предоставляющий точку входа для мобильных устройств.

4. Интеграция с внешними системами: Если ваше приложение должно взаимодействовать с внешними системами или API, каждая интеграция может быть реализована в виде отдельного сервлета. Например, у вас может быть сервлет, обрабатывающий запросы к сторонней платежной системе, и другой сервлет, обрабатывающий запросы к системе для отправки уведомлений.

В целом, использование нескольких сервлетов позволяет более гибко организовывать функциональность и обработку запросов в веб-приложении, улучшая его

-------------------

[к оглавлению](#spring)

## 34.	Что такое AOP? Как реализовано в спринге?

Статья → https://habr.com/ru/post/428548/ 

И еще одна - https://habr.com/ru/articles/254791/

Аспектно-ориентированное программирование АОP — это парадигма программирования, целью которой является повышение модульности за счет разделения междисциплинарных задач.  
 
Это достигается путем добавления дополнительного поведения к существующему коду без изменения самого кода. 
 
AOP предоставляет возможность реализации в одном месте сквозной логики. То есть логики, которая применяется к множеству частей приложения и обеспечение автоматического применения этой логики по всему приложению. 
 
Подход Spring к AOP заключается в создании "динамических прокси" для целевых объектов и "привязывании" объектов к конфигурированному совету для выполнения сквозной логики. 

---------
AOP означает "Аспектно-ориентированное программирование" (Aspect-Oriented Programming). Это парадигма программирования, которая позволяет разделять различные аспекты системы, такие как логгирование, безопасность, транзакции и другие, от основной логики приложения.

В Spring Framework AOP реализован с использованием прокси-объектов. Основная идея заключается в использовании прокси для обеспечения дополнительной функциональности перед или после выполнения метода. Spring AOP предоставляет аннотации (@Aspect, @Before, @After, @Around и т. д.) и конфигурационные файлы (XML или Java) для определения аспектов.

Пример использования Spring AOP с аннотациями:

1. Определите аспект, помеченный аннотацией @Aspect:
```java
@Aspect
public class LoggingAspect {

    @Before("execution(public * com.example.MyService.*(..))")
    public void beforeAdvice(JoinPoint joinPoint) {
        // Логирование перед выполнением метода
        System.out.println("Вызов метода: " + joinPoint.getSignature().getName());
    }

    @After("execution(public * com.example.MyService.*(..))")
    public void afterAdvice(JoinPoint joinPoint) {
        // Логирование после выполнения метода
        System.out.println("Метод выполнен: " + joinPoint.getSignature().getName());
    }
}
```

2. Настройте Spring для распознавания аспектов:
```xml
<aop:aspectj-autoproxy/>
```

Или, в случае Java-конфигурации:
```java
@Configuration
@EnableAspectJAutoProxy
public class AppConfig {
    // Конфигурация бина и другие настройки
}
```

После выполнения этих шагов аспект будет автоматически применяться ко всем методам класса `com.example.MyService` (подпакеты включены).

[к оглавлению](#spring)

## 35.	PROXY что это, для чего и как применяется в Spring

Паттерн Заместитель (Proxy) предоставляет объект-заместитель, который управляет доступом к другому объекту. То есть создается объект-суррогат, который может выступать в роли другого объекта и замещать его (перехватывать все вызовы).  

<img width="1117" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/cd3b0e1a-6d3e-45da-a794-de7a987cd861">

В Spring прокси просто оборачивает bean, он может добавить логику до и после выполнения методов.  
 
Spring AOP использует либо динамические прокси JDK (на основе интерфейса), либо CGLIB (на основе класса) для создания прокси для данного целевого объекта.  
 
Динамические прокси-серверы JDK предпочтительнее, когда у вас есть выбор. 
 
Если целевой объект для проксирования реализует хотя бы один интерфейс, то будет использоваться динамический прокси JDK. Все интерфейсы, реализованные целевым 
типом, будут проксированы.                                                           https://youtu.be/DKNDU7OjyJs?t=541  

<img width="930" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/c8571f06-e1a8-403f-b08a-ab2416b1cd59">

<img width="1074" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/4783b78d-13e0-4893-bd04-3032a972aa50">

Если целевой объект не реализует интерфейсов, будет создан прокси-сервер CGLIB. 
 
Если вы хотите принудительно использовать проксирование CGLIB (например, проксировать каждый метод, определенный для целевого объекта, а не только те, которые реализованы его интерфейсами), вы можете это сделать. 
 
Чтобы принудительно использовать прокси CGLIB, установите для атрибута proxytarget-class элемента <aop:config> значение true. 

<img width="1172" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/faf5575a-999e-4657-a90a-44c6aaf18c83">


Для принудительного использования прокси CGLIB в Spring можно использовать следующие инструкции при настройке Java и аннотационной конфигурации:

В классе конфигурации, помеченном аннотацией `@Configuration`, добавьте метод `@EnableAspectJAutoProxy` с атрибутом `proxyTargetClass = true`. Например:
```java
@Configuration
@EnableAspectJAutoProxy(proxyTargetClass = true)
public class AppConfig {
    // ...
}
```
Установив proxyTargetClass = true, вы указываете Spring Framework использовать прокси CGLIB вместо прокси JDK Dynamic при создании прокси-объектов для соответствующих бинов.

В Java-конфигурации Spring вы можете установить принудительное использование динамического прокси JDK, установив соответствующее свойство proxyTargetClass в значение false.

[к оглавлению](#spring)

## 36.	В чем разница между Filters, Listeners and Interceptors?

https://m-dev.space/notes/%D0%A4%D0%B8%D0%BB%D1%8C%D1%82%D1%80%D1%8B-Filters-%D1%81%D0%BB%D1%83%D1%88%D0%B0%D1%82%D0%B5%D0%BB%D0%B8-Listeners-%D0%B8-%D0%BF%D0%B5%D1%80%D0%B5%D1%85%D0%B2%D0%B0%D1%82%D1%87%D0%B8%D0%BA%D0%B8-Interceptors

https://www.programmersought.com/article/81061685870/

<img width="510" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/ebffb1cd-20e1-4879-81b9-b26d3eda8038">

https://stackoverflow.com/questions/35856454/difference-between-interceptor-and-filter-in-spring-mvc/71227949#71227949

1. Фильтры (Filter): Фильтры в Spring работают на уровне сервлетов и могут прямо манипулировать содержимым запроса и ответа. Например, фильтр может изменить параметры запроса, прочитать/изменить заголовки, модифицировать тело запроса или ответа и т.д.

2. Перехватчики (Interceptor): Перехватчики в Spring работают на уровне Spring MVC и предоставляют возможность контролировать целевую обработку запроса и ответа, но не манипулировать содержимым напрямую. Они могут обеспечивать предварительную обработку перед выполнением контроллера, последующую обработку после выполнения контроллера или обработку после возврата ответа клиенту.

Таким образом, фильтры имеют больше свободы в изменении содержимого запросов и ответов, поскольку они работают непосредственно с сервлетами, в то время как перехватчики позволяют контролировать обработку запросов и ответов на уровне Spring MVC, но не изменять содержимое напрямую.


**Filter**
 
Это ИНТЕРФЕЙС из пакета javax.servlet, имплементации которого выполняют задачи фильтрации либо по пути ЗАПРОСА к ресурсу (сервлету, либо по статическому контенту), либо по пути ОТВЕТА от ресурса, либо в ОБОИХ направлениях. 
 
Фильтры выполняют фильтрацию в методе doFilter(). Каждый фильтр имеет доступ к объекту FilterConfig, из которого он может получить параметры инициализации, и ссылку на ServletContext, который он может использовать, например, для загрузки ресурсов, необходимых для задач фильтрации. Фильтры настраиваются в дескрипторе развертывания веб-приложения. 
 
В веб-приложении мы можем написать несколько фильтров, которые вместе называются цепочкой фильтров. Веб-сервер решает, какой фильтр вызывать первым, в соответствии с порядком регистрации фильтров. 
 
Когда вызывается метод doFilter(ServletRequest request, ServletResponse response, FilterChain chain) первого фильтра, веб-сервер создает объект FilterChain, представляющий цепочку фильтров, и передаёт её в метод. 

<img width="1133" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/ac66421e-e038-442a-b47d-f5e8a3f0211e">

**Interceptor**
 
Это ИНТЕРФЕЙС из пакета org.aopalliance.intercept, предназначенный для AOP аспектно-ориентированного программирования. 
 
В Spring, когда запрос отправляется в Controller, перед тем как он в него попадёт, он может пройти через перехватчики Interceptor (0 или более). Это одна из реализаций АОП в Spring. Можно использовать Interceptor для выполнения таких задач, как запись в Log, добавление или обновление конфигурации перед тем, как запрос обработается Controllerом. 
 
Стек перехватчиков: он предназначен для связывания перехватчиков в цепочку в определенном порядке. При доступе к перехваченному методу или полю перехватчик в цепочке перехватчиков вызывается в том порядке, в котором он был определен. 

<img width="1118" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/26dc3919-3874-486d-b8ee-c5db792b0489">

Можно использовать Interceptor-ы для выполнения логики до попадания в контроллер, после обработки в контроллере, а также после формирования представления. Также можно запретить выполнение метода контроллера или указать любое количество перехватчиков. 
 
Перехватчики работают с HandlerMaping и поэтому должны реализовывать интерфейс 
HandlerInterceptor или наследоваться от готового класса HandlerInterceptorAdapter.  
 
В случае реализации HandlerInterceptor нужно переопределить 3 метода, а в случае HandlerInterceptor, только те, что необходимы: 
 
+ public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
 
Вызывается после того, как HandlerMaping определил соответствующий контроллер, но до того, как HandlerAdapter вызовет метод контроллера.  
 
С помощью этого метода каждый перехватчик может решить, прервать цепочку выполнения или направить запрос на исполнение дальше по цепочке перехватчиков до метода контроллера.  
 
Если этот метод возвращает true, то запрос отправляется следующему перехватчику или в контроллер. Если метод возвращает false, то исполнение запроса прекращается, обычно отправляя ошибку HTTP или записывая собственный ответ в response. 
 
+ public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)  
 
Отработает после контроллера, но перед формированием представления. Мы можем использовать этот метод для добавления дополнительных атрибутов в ModelAndView или для определения времени, затрачиваемого методом-обработчиком на обработку запроса клиента. Вы можете добавить больше объектов модели в представление, но вы не можете изменить HttpServletResponse, так как он уже зафиксирован. 
 
+ public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) 
 
Отработает после формирования представления. Вызывается только в том случае,  ЕСЛИ метод preHandle этого перехватчика успешно завершен и вернул true! 

<img width="793" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/84d3d67b-8482-47f3-a8fe-56023336f3be">

HandlerInterceptor связан с бином DefaultAnnotationHandlerMapping, который отвечает за применение перехватчиков к любому классу, помеченному аннотацией @Controller. 
 
Чтобы добавить перехватчики в конфигурацию Spring, нужно переопределить метод addInterceptors() внутри класса, который реализует WebMvcConfigurer 

<img width="593" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/1c120bff-d29d-40c9-9cd5-58cbb109c037">

**Filter vs. Interceptor**
 
+ Перехватчик основан на механизме Reflection, а фильтр основан на обратном вызове функции. 
+ Фильтр зависит от контейнера сервлета, тогда как перехватчик не зависит от него. 
+ Перехватчики могут работать только с запросами к контроллерам, в то время как фильтры могут работать почти со всеми запросами (например, js, .css и т.д.). • 	Перехватчики в отличии от фильтров могут обращаться к объектам в контейнере Spring, что даёт им более изощренный функционал. 
 
Порядок работы: 
+ Фильтры до
+ Перехватчики до
+ Метод контроллера
+ Перехватчики после
+ Фильтры после 
 
HandlerInterceptor в основном похож на Servlet Filter, но в отличие от него он просто позволяет настраивать предварительную обработку с возможностью запретить выполнение самого обработчика и настраивать постобработку. 
 
Согласно документации Spring, фильтры более мощные, например, они позволяют обмениваться объектами запроса и ответа, которые передаются по цепочке. Это означает, что фильтры работают больше в области запроса/ответа, в то время как HandlerInterceptor -s являются бинами и могут обращаться к другим компонентам в приложении.  
 
Фильтр настраивается в web.xml, а HandlerInterceptor в контексте приложения. 
 
**Java Listener**

<img width="305" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/1b05c111-53e2-42a9-8f24-28ee0f0b03f1">
 
Listener (Слушатель) - это класс, который реализует интерфейс javax.servlet.ServletContextListener.  
 
Он инициализируется только ОДИН раз при запуске вебприложения и уничтожается при остановке веб-приложения.  
 
Слушатель сидит и ждет, когда произойдет указанное событие, затем «перехватывает» событие и запускает собственное событие.  
 
Например, необходимо инициализировать пул соединений с базой данных до запуска веб-приложения. ServletContextListener – это то, что нужно. Он будет запускать код до запуска веб-приложения. 
 
Все ServletContextListener -s уведомляются об инициализации контекста до инициализации любых фильтров или сервлетов в веб-приложении, а также уведомляются об уничтожении контекста после того, как все сервлеты и фильтры уничтожены. 
 
Чтобы создать свой Listener, достаточно создать класс, имплементирующий интерфейс ServletContextListener и поставить над ним аннотацию @WebListener 

<img width="693" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/45178a35-74b0-4d86-8114-46c164728ade">

[к оглавлению](#spring)

## 37. Можно ли передать в запросе один и тот же параметр несколько раз? Как?

Да, можно принять все значения, используя массив в методе контроллера: 

<img width="832" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/bbe6f65e-f3a3-4551-94a1-70651195bed8">

---------------
В HTTP запросе можно передать один и тот же параметр несколько раз. Ниже приведены несколько примеров использования в Java Spring:

1. Query Parameters с массивом:

```java
@RequestMapping(value = "/example", method = RequestMethod.GET)
public String exampleMethod(@RequestParam("param") String[] values) {
    // Обработка значения параметра values
    return "response";
}
```

В URL-адресе запроса параметр `param` может быть передан несколько раз, например:

```
http://example.com/example?param=value1&param=value2&param=value3
```

В методе контроллера `exampleMethod`, параметр `values` будет содержать массив значений `[value1, value2, value3]`.

2. Query Parameters с использованием List:

```java
@RequestMapping(value = "/example", method = RequestMethod.GET)
public String exampleMethod(@RequestParam("param") List<String> values) {
    // Обработка значения параметра values
    return "response";
}
```

Аналогично, в URL-адресе запроса параметр `param` может быть передан несколько раз. Например:

```
http://example.com/example?param=value1&param=value2&param=value3
```

В методе контроллера `exampleMethod`, параметр `values` будет содержать список значений `["value1", "value2", "value3"]`.

3. Path Variables с использованием массива:

```java
@RequestMapping(value = "/example/{param}", method = RequestMethod.GET)
public String exampleMethod(@PathVariable("param") String[] values) {
    // Обработка значения параметра values
    return "response";
}
```

URL пути может содержать переменную `param` в нескольких составляющих, например:

```
http://example.com/example/value1/value2/value3
```

В методе контроллера `exampleMethod`, параметр `values` будет содержать массив значений `["value1", "value2", "value3"]`.

-------
Использование массива или списка (`List`) зависит от конкретных требований и особенностей вашего приложения. Вот некоторые соображения, которые могут помочь вам принять решение:

Использование массива:

1. Фиксированное количество значений: Если заранее известно, что количество передаваемых значений параметра будет фиксированным и неизменным, то использование массива может быть удобным. Например, передача часов работы в течение дня (`[8, 9, 10, 11, 12]`) или дни недели (`["пн", "вт", "ср", "чт", "пт"]`).

2. Простая обработка: Если вам нужно просто получить доступ к значениям параметра без дополнительной манипуляции или преобразования, массив может быть более удобным выбором.

Использование списка (`List`):

1. Изменяемое количество значений: Если количество передаваемых значений параметра может изменяться, то использование списка может быть предпочтительнее. Список позволяет динамически добавлять, удалять или изменять значения во время выполнения программы.

2. Удобные методы работы со списками: Если вам нужно выполнять различные операции с параметрами, такие как сортировка, поиск, фильтрация или другие манипуляции, использование списка предоставляет встроенные методы из Java Collections Framework, которые могут значительно упростить ваш код.

3. Поддержка разных типов данных: Список (`List`) позволяет хранить элементы разных типов данных, в то время как массив требует, чтобы все элементы были одного типа.

В целом, использование массива или списка будет зависеть от ваших специфических требований и предпочтений. Однако, если вы не уверены, лучше выбрать `List`, так как он предоставляет больше гибкости и удобства в работе с коллекциями.

------------
Использование `@RequestParam` и `@PathVariable` в зависит от того, как вы хотите передать данные в вашем API или веб-приложении. Вот некоторые соображения, которые могут помочь вам выбрать между ними:

Использование `@RequestParam`:

1. Параметры запроса: Если вам нужно передать параметры в запросе как query-параметры (часть URL после знака вопроса `?param1=value1&param2=value2`), то `@RequestParam` может быть полезным. Например, вы можете использовать `@RequestParam` для получения значения поискового запроса в URL `/search?query=example`.

2. Необязательные параметры: Если параметры не являются обязательными и могут отсутствовать в запросе, `@RequestParam` позволяет указать значения по умолчанию или задать их как необязательные.

Использование `@PathVariable`:

1. Часть пути URL: Если вам нужно передать параметры в запросе в качестве части пути URL, то `@PathVariable` может быть нужным. Например, вы можете использовать `@PathVariable` для получения значения идентификатора из URL `/users/{id}`.

2. Значения с фиксированным форматом: Если параметры имеют фиксированный формат и имеют определенное значение, использующееся в пути URL, `@PathVariable` может быть удобным. Например, `/products/{category}` или `/users/{username}`.

В некоторых случаях вы можете комбинировать оба подхода в одном запросе, используя и `@RequestParam`, и `@PathVariable`, чтобы передать различные данные.

В конечном счете, выбор между `@RequestParam` и `@PathVariable` будет зависеть от структуры вашего API, требований к маршрутизации и предпочтений разработчика.

[к оглавлению](#spring)

## 38.	Как работает Spring Security? Как сконфигурировать? Какие интерфейсы используются?

Зачем нужен такой модуль? 
+ Настройка безопасности 
+ Защита отдельных методов или целых блоков приложения 
 
Конфигурация с помощью аннотации @EnableWebSecurity (default @Configuration) 
 
<img width="619" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/151f8dd3-685d-42df-924f-e3f6c161f621">

 Под капотом цепочка – реализуем цепочку фильтров (в коде это стрим): 

<img width="550" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/492e5a22-85b2-48ac-84cc-0bf6d09f9f85">
 
Для аутентификации используем POST запрос и обязательные поля сущности: 
+ username 
+ password 
 
Spring ждёт эти поля и будет генерировать если явно их не обозначим. Когда эти данные «летят» в HttpServletRequest, то фильтры будут выдёргивать именно эти данные. 
 
Необходимо использовать csrf токен – это защита от скрытых полей и редиректа на вредоносные, чужие базы. 

Principal principal – это информация о текущем пользователе, которая хранится в контексте Spring Security: 

<img width="712" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/e003b75a-cf21-4daa-a13c-d86cfe845e55">

principal.getName() – так получаем имя аутентифицированного пользователя. Идемпотентность в контроллер-методе. 
 
**Авторизация**
 
Где и как хранится инфо о пользователях? 

<img width="1218" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/3a78e8d3-adac-4759-a807-dde886668d26">

Идентификация – уточнение имени и пароля. 
 
Аутентификация – это процедура проверки подлинности пользователя путём сравнения введённого им логина и пароля с сохранёнными в базе данных. 
 
Авторизация – это проверка и определение полномочий на выполнение определённых действий в соответствии с ранее выполненной аутентификацией. 
 
Как это работает? 

1)Пользователь формирует POST запрос 

2)Фильтр перехватывает и выдёргивает из запроса логин и пароль, далее формирует UAPAT токен (Username And Password Authorization token) 

3)Токен летит дальше и попадает в Authentication provider. Его задача провести аутентификацию и сказать, существует ли такой пользователь?  И если да, то кладём его в SPRING Security Context. 
 
Зачем тут нужны UserService и Authentication provider? 
 
+ Провайдер получает токен (логин и пароль).
+ Провайдер обращается к UserDetailsService: есть у тебя такой юзер?
+ UserDitailsService знает, где юзеры хранятся и по username (byUserName) получает и возвращает настоящего юзера в виде объекта UserDitails (principal).
+ Далее Authentication provider берёт из токена пароль и делает проверку equals()
+ Если они равны, кладёт их в Spring Security Context. 
 
Задачи Authentication provider: запросить настоящего юзера у UserDitailsService, сравнить пароль, почистить credentials (логин и пароль не сохраняются). 
 
Spring хранит только Authorities (права доступа), а если нужна полная информация о клиенте, то нужно обратиться в базу данных. 

**ФИКСИРУЕМ**

DaoAuthenticationProvider — это реализация AuthenticationProvider, которая использует UserDetailsService и PasswordEncoder для проверки подлинности имени пользователя и пароля.

<img width="790" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/128790c8-111c-4e91-9709-ec354f0d3bdb">

Когда пользователь посылает POST request, то «формируется посылка». КАК? 
 
№1 В цепочке фильтров стоит фильтр, который обрабатывает и выдёргивает TOKEN 
 
№2 Далее действует Authentication Manager, в котором есть Provider Manager.  Он может состоять не из одного провайдера, а из многих, настроенных на разные реакции. 
 
В DaoAuthenticationProvider записаны:  
                
                №3 UserDetailsService (возвращает пользователя по имени) и … 
                
                №4 PasswordEncoder (преобразовывает введённый пароль к хэшу) 
 
Если все ОК, то возвращается UPAT TOKEN 
+ UserDetails (принципал) 
+ Authorities (права доступа) 
 
Если аутентификация прошла успешно, возвращаемая проверка подлинности имеет тип UsernamePasswordAuthenticationToken и имеет принципала, который представляет собой UserDetails, возвращаемый настроенной службой UserDetailsService.  
 
В конечном итоге возвращенный UPAT устанавливается в SecurityContextHolder фильтром аутентификации. 
  
Источник: https://docs.spring.io/spring-security/reference/servlet/authentication/passwords/dao-authentication-provider.html  

[к оглавлению](#spring)

## 39.	Что такое SpringBoot? Какие у него преимущества? Как конфигурируется? Подробно.


Основные сущности фреймворка Spring Boot – это стартеры. Зависимости с названиями вида spring-boot-starter-xxx выполняют две основных задачи.  
 
Во-первых, они добавляют набор типичных сторонних библиотек-зависимостей, а вовторых, регистрируют типичные бины и их конфигурации. Кроме того, со Spring Boot в проекте появляется ряд таких полезностей, как embedded-сервер, конфигурация webприложения без web.xml, метрики, properties вынесенные из кода во внешние файлы. 
 
Например, spring-boot-starter-data-jpa даст вам готовый комплект всего необходимого для использования JPA: драйвер, совместимую с ним версию Hibernate, библиотеки Persistence API и Spring Data. В контексте приложения появятся все нужные для JPA репозиториев бины. 
 
Таким образом, Spring Boot ускоряет и упрощает разработку, дает возможность избавиться от boilerplate-кода в проекте и сфокусироваться на бизнес-задачах.  
 
Это бывает особенно важно в микросервисной архитектуре, когда создается большое количество приложений. 
 
С другой стороны, такая избыточность естественно приводит к большей тяжеловесности и медлительности приложения. 

----------
Spring Boot - это фреймворк, основанный на платформе Spring, который упрощает создание и развертывание приложений на Java. Он был создан, чтобы облегчить конфигурирование и запуск приложений Spring, предоставляя стандартизированный подход к разработке.

Преимущества Spring Boot:

1. Упрощенная настройка: Spring Boot предлагает умное автоматическое конфигурирование, которое может обрабатывать множество настроек и зависимостей по умолчанию. Это позволяет сократить объем кода конфигурации и упростить развертывание приложения.

2. Встроенный сервер приложений: Spring Boot поставляется с встроенным сервером приложений, таким как Tomcat, Jetty или Undertow. Вы можете запустить приложение внутри самого фреймворка без необходимости настройки и развертывания отдельного сервера.

3. Управление зависимостями: Spring Boot использует систему управления зависимостями Maven или Gradle для автоматического разрешения и управления зависимостями вашего проекта. Вы можете просто указать требуемые зависимости, и Spring Boot автоматически загрузит их при сборке проекта.

4. Удобство тестирования: Spring Boot предоставляет удобные инструменты для тестирования приложений, включая поддержку автоматической конфигурации и создание сценариев тестирования с использованием специального тестового контекста Spring.

5. Поддержка микросервисной архитектуры: Spring Boot занимает прочное положение в разработке микросервисов. Он предоставляет многофункциональные библиотеки и инструменты для разработки и развертывания микросервисных систем.

Конфигурация Spring Boot:

Spring Boot использует концепцию "установка по соглашению", что означает, что вы сможете уменьшить объем кода конфигурации, следуя определенным соглашениям. Однако, если вам нужно настроить что-то вручную, вы можете использовать файлы конфигурации в формате `.properties` или `.yml`.

Основные пути для конфигурации Spring Boot:

1. Файлы `application.properties` или `application.yml`: Вы можете определить свойства приложения, такие как порт сервера, базовые URL, настройки базы данных и другие, в этих файлах. Они автоматически загружаются при старте приложения.

2. Аннотации: Вы можете использовать аннотации, такие как `@EnableAutoConfiguration`, `@ComponentScan` и `@Configuration`, для настройки и управления компонентами и зависимостями.

3. Java-конфигурация: Вы можете создавать классы конфигурации, которые аннотированы `@Configuration`, и использовать методы с аннотацией `@Bean` для настройки компонентов и их зависимостей.

4. Внешние файлы конфигурации: Spring Boot позволяет загружать конфигурацию из внешних файлов, указанных с помощью системных свойств или переменных окружения.

В общем, Spring Boot предлагает множество опций для конфигурации, позволяя вам выбрать подход, который лучше соответствует потребностям вашего приложения.

Введение в Spring Boot: создание простого REST API на Java - https://habr.com/ru/articles/435144/

Преимущества и недостатки использования Spring Boot - https://javarush.com/groups/posts/3380-kofe-breyk-75-preimujshestva-i-nedostatki-ispoljhzovanija-spring-boot-funkcii-dlja-strok-v-java

Запускаем первое веб-приложение на Spring Boot - https://skillbox.ru/media/code/zapuskaem-pervoe-vebprilozhenie-na-spring-boot/

[к оглавлению](#spring)

## 40.	Какие задачи решает Spring Data?

Это проект, который упрощает работу с системами доступа к данным: реляционными и нереляционными базами данных, map-reduce фреймворками и облачными хранилищами.  
 
Центральная концепция проекта – репозитории из предметно-ориентированного дизайна (Domain-driven design, DDD). 
 
Spring Data состоит из множества отдельных библиотек для разных случаев жизни.  Вот самые популярные из них: 
+ Spring Data JPA – адаптер для реализаций Java Persistence API, таких как Hibernate. 
+ Spring Data JDBC – более простой и ограниченный чем JPA адаптер для JDBC-драйверов.  
+ Spring Data REST – создание готовых hypermedia-driven RESTful сервисов на основе репозиториев. 
+ Spring Data KeyValue – работа с хранилищами типа ключ-значение. • 	Библиотеки поддержки конкретных реализаций хранилищ: MongoDB, Redis, Cassandra, LDAP, и других. 
 
Основная часть работы в Spring Data строится вокруг интерфейса Repository.  
 
Это маркерный интерфейс. От него наследуются интерфейсы-специализации, которые уже содержат методы для работы с сущностями базы данных. Все эти интерфейсы параметризуются двумя типами: самой сущности и её идентификатора. 

-----------
Spring Data - это проект в экосистеме Spring, который предоставляет удобный и унифицированный способ работы с различными хранилищами данных. Он решает следующие задачи:

1. Упрощение доступа к данным: Spring Data предлагает абстракции и удобные API для работы с различными хранилищами данных, такими как реляционные базы данных, NoSQL базы данных, кэш-системы и другие. Он предоставляет возможность использовать общие методы для выполнения операций, таких как создание, чтение, обновление и удаление данных (CRUD), что позволяет упростить кодирование и снизить его сложность.

2. Управление сущностями и отношениями: Spring Data предоставляет подходы для отображения данных в объекты Java - предметно-ориентированные модели или сущности, которые соответствуют таблицам и сущностям в базе данных. Это позволяет легко манипулировать данными и работать с ними, используя объектно-ориентированный подход.

3. Работа с запросами и поиском данных: Spring Data предоставляет удобные способы формирования запросов и поиска данных. Он поддерживает различные механизмы запросов, включая языки запросов, такие как SQL или JPQL, а также предоставляет возможность создания критериев запросов на основе критериев или спецификаций. Это позволяет легко формировать запросы и извлекать нужные данные из хранилищ данных.

4. Реализация репозиториев: Spring Data предоставляет функциональность репозиториев, которая автоматически генерирует реализации интерфейсов репозиториев на основе метаданных модели данных. Это позволяет легко выполнять типичные операции доступа к данным, такие как поиск по идентификатору, сохранение, удаление и другие.

5. Поддержка транзакций: Spring Data интегрируется с механизмом управления транзакциями в Spring Framework, что позволяет управлять транзакционными операциями при работе с данными. Это обеспечивает консистентность и надежность операций в контексте базы данных.

В целом, Spring Data предоставляет удобное и гибкое решение для доступа к данным и работе с ними, абстрагируясь от деталей конкретных хранилищ данных и упрощая кодирование операций доступа и манипуляции с данными.

[к оглавлению](#spring)

## 41.	Какова иерархия интерфейсов/классов репозитория в Spring Data JPA?

<img width="469" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/2595e6e5-8563-4445-aeeb-e9240df542bf">

Repository (маркерный интерфейс, не содержит методов) — это интерфейс верхнего уровня, определенный в Spring Data Hierarchy. 
 
Интерфейс CrudRepository расширяет интерфейс репозитория, предоставляет методы для выполнения операции CRUD.  
 
PagingAndSortingRepository расширяет интерфейс CrudRepository и предоставляет дополнительные методы для извлечения сущностей с помощью разбиения на страницы и сортировки. 
 
Интерфейс QueryByExampleExecutor, используется для выполнения запроса по примеру. 
 
Интерфейс JpaRepository расширяет интерфейс PagingAndSortingRepository и QueryByExampleExecutor, предоставляя некоторые дополнительные пакетные методы.  
 
SimpleJpaRepository — это класс реализации интерфейса CrudRepository. QueryDslJpaRepository – это класс. 

[к оглавлению](#spring)

## 42.	*Как преодолеть проблему блокирующих вызовов?

(реактивное программирование, WebFlux, EventLoop)

Project Reactor. В чем его идея? - https://www.youtube.com/watch?v=qgjBDv03RWk
 
Требования сегодняшнего дня: приложения должны иметь высокую доступность и обеспечивать низкое время отклика даже при высокой нагрузке. 
 Проблематика                                                                                        https://habr.com/ru/post/565004/  
 
+ Модель «поток на запрос» 
 
Традиционный способ разработки веб-приложения с помощью Spring – это использование MVC и его развертывание в контейнере сервлетов, таком как Tomcat. Контейнер сервлетов имеет выделенный пул потоков для обработки HTTPзапросов, где каждому входящему запросу будет назначен поток, и этот поток будет обрабатывать весь жизненный цикл запроса (модель «поток на запрос»). По умолчанию для сервера Tomcat установлено 200 подключений. 
 
Это означает, что приложение сможет обрабатывать количество одновременных запросов, равное размеру пула потоков. Можно настроить размер пула потоков, но поскольку каждый поток резервирует некоторую память (обычно 1 МБ), чем больший размер пула потоков мы настраиваем, тем выше потребление памяти. 
 
Если приложение разработано в соответствии с архитектурой на основе микросервисов, то у нас есть лучшие возможности для масштабирования в зависимости от нагрузки, но за высокое использование памяти по-прежнему приходится платить (потоки часто блокируются в ожидании ответа от другой службы, что приводит к огромной трате ресурсов). 
 
+ Ожидание операций ввода/вывода 
 
Такой же тип потерь также возникает при ожидании завершения других типов операций ввода-вывода, таких как вызов базы данных или чтение из файла. Во всех этих ситуациях поток, выполняющий запрос ввода-вывода, будет заблокирован и будет ожидать, пока операция ввода-вывода не будет завершена, это называется блокирующим вводом-выводом.  Такие ситуации, когда выполняющийся поток блокируется, просто ожидая ответа, означают потерю потоков и, следовательно, потерю памяти (рисунок слева). 

<img width="1149" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/59496b22-55ba-4b80-9486-d6ed787783e0">

+ Время ответа 
 
Другой проблемой традиционного императивного программирования является время отклика, когда службе необходимо выполнить более одного запроса ввода-вывода (рисунок справа). Например, службе A может потребоваться вызвать службы B и C, а также выполнить поиск в базе данных, а затем вернуть в результате некоторые агрегированные данные. Это будет означать, что время ответа службы A, помимо времени ее обработки, будет суммой следующих значений: 
+ время отклика услуги B (задержка сети + обработка)
+ время отклика службы C (задержка сети + обработка)
+ время ответа на запрос к базе данных (сетевая задержка + обработка) 

Если нет никакой реальной логической причины выполнять эти вызовы последовательно, то, безусловно, если эти вызовы будут выполняться параллельно, это очень положительно повлияет на время отклика службы А.  
 
+ Перегрузка клиента 
 
Другой тип проблемы, которая может возникнуть в ландшафте микросервисов, - когда сервис A запрашивает некоторую информацию у сервиса B, скажем, например, обо всех заказах, размещенных в течение последнего месяца. Если количество заказов окажется огромным, для службы А может возникнуть проблема получить всю эту информацию сразу. Служба A может быть перегружена большим объемом данных, что может привести, например, к ошибке нехватки памяти. 
 
Все эти проблемы решает реактивное программирование.  
 
Перечислим преимущества: 
+ отходим от модели «поток на запрос» и можем обрабатывать больше запросов с небольшим количеством потоков 
+ предотвращаем блокировку потоков при ожидании завершения операций вводавывода 
+ упрощаем параллельные вызовы 
+ поддерживаем «обратное давление», давая клиенту возможность сообщить серверу, с какой нагрузкой он может справиться 

<img width="1144" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/71953048-d08b-4b03-9b46-82ae08fd111f">

То есть это не от слова «реактивный = высокоскоростной», это НЕ про ускорение.  Это про оптимизацию управления тредами, потоками: количество обрабатываемых запросов за единицу времени (от слова «реакция» … на события). 

Не ждём, а работаем: реактивность добавляет возможность обрабатывать данные потоком, разбивая задачу на множество подзадач. 
 
Говорят, когда Генри Форд придумал свой конвейер, он повысил производительность труда в четыре раза, благодаря чему ему удалось сделать автомобили доступными.  
 
Здесь мы видим то же самое: у нас не большие порции данных, а конвейер с потоком данных, и каждый обработчик пропускает через себя эти данные, какимто образом их преобразовывая. 

<img width="436" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/0d6b89b8-6b53-43a9-80b2-afc144234e73">

Что такое реактивный поток?     

https://habr.com/ru/company/oleg-bunin/blog/545702/  
 
Поток представляет собой некую последовательность, состоящую из постоянных событий, отсортированных по времени. В потоке может быть лишь ТРИ типа сообщений:  • сами данные  
+ ошибки  
+ сигнал о завершении работы потока  
 
Для работы наблюдатель должен лишь подписаться на поток. Это необходимое условие — иначе работа не начнет выполняться. 

<img width="1130" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/2271ffab-039f-4029-86b3-bf1555fe9433">

Сами данные будут получены лишь тогда, когда они будут готовы — это event модель.  То есть это может произойти либо в этом же, либо в совершенно другом потоке. 

Можно с уверенностью заявить, что реактивная модель основана на событиях — это и есть самая настоящая event-driven модель.

Получить данные из потока можно двумя способами: PUSH и PULL модели. PULL чтобы получить данные из потока мы сделали запрос на получение данных. 
Стандартный подход.

PUSH чтобы получить данные, мы не делаем запрос на получение данных. Данные сами нас уведомляют о своей готовности, и поток просто отдает их нам. В это время мы можем не ждать их вообще. Мы просто подписались на поток и забыли про него. Данные готовы к выдаче, отлично.

Реактивное приложение — это то, которое само извещает об изменении своего состояния, где мы не делаем запрос и не проверяем, что там изменилось, а приложение само сигнализирует об этом. Это совершенно другой подход в разработке. 
 
**Netty as a non-blocking server**

Рассмотрим пример использования реактивных потоков Flux вместе со Spring Reactor.  

В основе Reactor лежит сервер Netty. Spring Reactor — это основа технологии, которую мы будем использовать. А сама технология называется WebFlux.  

Чтобы WebFlux (веб флАкс) работал, нужен асинхронный неблокирующий сервер. 

Есть Selector — входной поток, который принимает запросы от клиентов и отправляет их на выполнение в освободившиеся потоки. Если в качестве синхронного сервера (Servletконтейнера) используется Tomcat, то в качестве асинхронного используется Netty. 

<img width="613" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/ae223940-44c5-4544-9651-19776984c3e0">

Драйвер r2dbc от команды Spring сразу предоставляет реактивное API (а не асинхронное), а для транспорта используется Netty (как и в jasync-sql). 
Blocking vs Reactive 
 
У нас есть два стека обработки запросов: 
+ Традиционный блокирующий стек.
+ Неблокирующий стек — в нем все происходит асинхронно и реактивно. 

Что же такое WebFlux? 

<img width="712" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/2d3a020d-6775-4d8f-8b3f-4cd40376f0c1">
 
Это асинхронный и неблокирующий микро-фреймворк, который позволяет одновременно обрабатывать огромное количество соединений.  
 
Модуль WebFlux является альтернативой Spring MVC и представляет собой реактивный подход для написания веб-сервисов.  
 
Он построен на библиотеке Reactor и работает, начиная с версии SpringBoot 2 и выше. По умолчанию он использует Netty (не Tomcat). 

<img width="1112" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/8d37432b-42cc-4bff-a324-24fd9b7cf1a4">

Spring Framework поддерживает реактивное программирование, начиная с пятой версии. Эта поддержка построена на основе Project Reactor.  

Project Reactor или просто Reactor — это библиотека Reactive для создания неблокирующих приложений на JVM, основанная на спецификации Reactive Streams.  

Это основа реактивного стека в экосистеме Spring. 

Spring WebFlux использует модель обработки запросов EventLoop (цикл событий). 

Отличное видео, пусть вас не смущает js (модель универсальна) →         https://youtu.be/8aGhZQkoFbQ  

Когда на сервер Netty приходит запрос, он немедленно отвечает объектом Future, таким образом, не блокируя клиента. Тем временем он может делать все, что хочет.  

Бонусом является то, что Netty обрабатывает большое количество соединений.  

События – это и запросы Request, и ответы Callback, которые регистрирует Netty. 

<img width="1133" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/24fe3c71-dc4c-4a63-a4a1-1fc856d03a3c">

Соединение между клиентом и сервером устанавливается через канал. EventLoop Netty ищет события. У него есть внутренняя очередь, в которой он хранит события и Цикл Событий, принимающий в порядке FIFO (первый вошёл, первый вышел), до тех пор, пока он не обработает их все.  

ChannelHandler ищет правильную конечную точку для вызова: либо Controller Endpoint (в классах, аннотированных @RestController), либо Functional Endpoint (функциональная конечная точка). Цикл событий Netty связывает каждый запрос с каналом, и таким образом он знает, на какой канал ему нужно отправить ответ. 
 
Посмотрим, сколько вычислительных ресурсов расходуют Netty и Tomcat на выполнение одного запроса. Throughput — это общее количество обработанных данных.  
 
При небольшой нагрузке, до первых 300 пользователей у RxNetty и Tomcat оно одинаковое, а после Netty (красная линия) уходит в отрыв — почти в 2 раза! 

<img width="1121" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/329770ad-4cdd-469d-91b1-c95b6544b6cf">

[к оглавлению](#spring)

## 43.	Как вызвать транзакционный метод из того же класса?

В Spring Framework существует аннотация @Transactional. Ей помечается метод или класс, весь код которого должен выполняться в рамках транзакции. Обычно имеется в виду транзакция базы данных, но вообще это понятие определяется используемым transactionManager-ом. Настройки, такие как уровень изоляции, стратегия роллбэка и прочие, определяются через параметры этой аннотации. 
 
В теории, @Transactional делает метод транзакционным для этого класса и всех его наследников. На практике же, по умолчанию, если вызвать транзакционный метод Foo.bar(), из Foo.baz(), то транзакция не создастся. 
 
Это происходит вследствие того, что по умолчанию Spring AOP добавляет код открытия и закрытия транзакции через динамический proxy класс. То есть, вместо Foo инджектится нечто, похожее на код на изображении. 
 
<img width="631" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/02acfd51-2294-4e51-8d66-e9362ff6033d">

Первый вариант решения проблемы – вместо аннотации использовать TransactionTemplate, то есть обернуть код в транзакцию вручную.  
 
Примеры использования в статье: https://www.baeldung.com/spring-programmatic-transaction-management   
 
Другой, более универсальный, но более сложный в конфигурации способ – переключить режим работы Spring AOP с динамических прокси на нечто другое. Обычно применяется библиотека AspectJ: 
@EnableTransactionManagement(mode = AdviceMode.ASPECTJ) 

В Spring AOP есть понятие weaving – этап добавления дополнительной функциональности (аспектов).  

В нашем случае, это код открытия и закрытия транзакции.  

Чтобы заработал weaving AspectJ этапа компиляции, в сборку нужно добавить плагин: aspectj-maven-plugin для maven, gradle-aspectj для gradle. 

И еще как вариант использовать @Autowired

<img width="504" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/745007b5-c8d3-4e5c-9368-cfd156a5f0e8">

Но считается анти-паттерном, так как криворукие могут удалить это внедрение и все сломается, а найти причину будет тяжело.

[к оглавлению](#spring)

## 44.	*Когда отрабатывает @Autowired а когда @Transactional? почему? Почему нельзя отработать @Transactional в другом методе? 

@Autowired работает в методе ДО инициализации, @Transactional после.  Так как оборачивает логику в прокси. 

Аннотация `@Autowired` используется для инъекции зависимости в Spring-компоненты. Когда Spring создает экземпляр класса и встречает аннотацию `@Autowired` над полем, конструктором или сеттером, он автоматически подставляет соответствующий экземпляр зависимостей.

Аннотация `@Transactional`, с другой стороны, используется для определения транзакционной границы метода. Когда метод с аннотацией `@Transactional` вызывается, Spring создает транзакцию вокруг этого метода. Если метод завершается успешно, транзакция фиксируется, и все изменения, внесенные в базу данных в рамках этой транзакции, сохраняются. Если происходит исключение, транзакция откатывается и все изменения отменяются.

Не существует прямой связи между аннотациями `@Autowired` и `@Transactional`, и их назначения разные. 

Аннотация `@Autowired` используется для разрешения зависимостей класса, тогда как `@Transactional` определяет поведение транзакции.

Вы можете использовать `@Autowired` для внедрения зависимости в любом методе класса, чтобы получить доступ к необходимым ресурсам. Однако транзакционное поведение, определенное аннотацией `@Transactional`, применяется только к методам класса и не может быть использовано для транзакций вне класса.

Таким образом, `@Transactional` не может быть использован в других методах, потому что это противоречило бы его роли и предназначения - управления транзакционной границей метода. Транзакционное поведение должно быть явно определено в методе, к которому оно относится.

[к оглавлению](#spring)

## 46.	Структура HTTP запроса, ответа

<img width="875" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/4697d289-64df-4a34-bdca-7d4b7c3e5742">

Структура протокола определяет, что каждое HTTP-сообщение состоит из трёх частей, которые передаются в следующем порядке:

Стартовая строка (англ. Starting line) — определяет тип сообщения;

Заголовки (англ. Headers) — характеризуют тело сообщения, параметры передачи и прочие сведения;

Тело сообщения (англ. Message Body) — непосредственно данные сообщения. 

Обязательно должно отделяться от заголовков пустой строкой.

<img width="552" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/b7812dbc-8f0e-4cfc-8427-b23cc5a33d28">

Структура HTTP запроса:
1. Метод запроса: Определяет тип операции, которую требуется выполнить. Некоторые из наиболее часто используемых методов включают GET, POST, PUT и DELETE.
2. URL (Uniform Resource Locator): Указывает на ресурс, к которому должен быть выполнен запрос.
3. Заголовки (Headers): Передают дополнительную информацию о запросе, такую как тип содержимого, язык, кеширование и другие параметры.
4. Тело запроса (Body): Компонент, необходимый только для некоторых методов запроса, таких как POST или PUT. Он содержит данные, которые передаются на сервер.

Структура HTTP ответа:
1. Статус-линия: Содержит код состояния, который указывает на успешность или неуспешность выполнения запроса. Например, 200 OK означает успешное выполнение, а 404 Not Found указывает на ошибку, когда запрашиваемый ресурс не найден.
2. Заголовки (Headers): Содержат дополнительную информацию, передаваемую от сервера клиенту. Заголовки могут содержать информацию о типе содержимого, дате и времени создания, параметрах кеширования и других аспектах ответа.
3. Тело ответа (Body): Содержит фактические данные, возвращаемые сервером. Например, это может быть HTML-код, JSON-данные или любой другой тип содержимого, указанный в заголовках.

🌐 HTTP запросы и ответы образуют основу взаимодействия клиента (обычно веб-браузера) с сервером по протоколу HTTP. Они позволяют передавать данные и выполнять различные операции на веб-серверах, такие как получение веб-страниц, отправка данных формы, обновление или удаление ресурсов на сервере и многое другое.

----------
HTTP (HyperText Transfer Protocol) и HTTPS (HyperText Transfer Protocol Secure) являются двумя разными протоколами, используемыми для передачи данных в Интернете. Они отличаются основными аспектами, включая безопасность и шифрование данных.

1. Безопасность: Основное отличие между HTTP и HTTPS заключается в безопасности передачи данных. HTTP не обеспечивает никакую защиту данных, и информация передается в открытом виде. Это означает, что злоумышленники могут перехватить и просмотреть передаваемую информацию, такую как логины, пароли или конфиденциальные данные. HTTPS, с другой стороны, использует шифрование SSL/TLS (Secure Sockets Layer/Transport Layer Security), для обеспечения безопасной передачи данных. Шифрование делает данные непонятными для третьих лиц и обеспечивает конфиденциальность и целостность информации.

2. Протокол уровня транспорта: HTTP работает поверх протокола TCP (Transmission Control Protocol), который является основным протоколом передачи данных в Интернете. HTTPS также использует TCP для установки надежного соединения, но добавляет слой шифрования SSL/TLS поверх TCP для обеспечения безопасности.

3. Порт: HTTP использует порт 80 для связи между клиентом и сервером, в то время как HTTPS использует порт 443. Обычно веб-браузеры автоматически перенаправляют запросы на нужный порт в зависимости от протокола, указанного в URL.

4. Сертификаты SSL/TLS: Для установки безопасного соединения по HTTPS сервер должен иметь действительный цифровой SSL/TLS-сертификат. Этот сертификат подтверждает подлинность сервера и используется при установке шифрованного соединения с клиентом.

В целом, HTTPS является более безопасным вариантом по сравнению с обычным HTTP, и рекомендуется использовать HTTPS для передачи конфиденциальных данных и обмена информацией на веб-сайтах.

-----------------
Шифрование данных в протоколе HTTPS (HTTP Secure) обеспечивает защищенную передачу информации между клиентом и сервером. Подробный процесс шифрования в HTTPS включает следующие шаги:

1. Установление соединения: Клиент отправляет запрос на защищенное соединение с сервером, указывая префикс "https://" в URL-адресе. Это сигнализирует серверу о необходимости использования протокола HTTPS вместо обычного HTTP.

2. Сертификат сервера: Сервер отвечает клиенту, предоставляя свой сертификат. Сертификат содержит публичный ключ сервера, который будет использоваться для шифрования данных.

3. Проверка сертификата: Клиент проверяет сертификат сервера, чтобы убедиться, что он действителен и выдан надежным удостоверяющим центром (CA - Certificate Authority). Клиент также проверяет, соответствует ли доменное имя сервера имени, указанному в сертификате. Если проверка не проходит успешно, клиент может показать предупреждение или даже прервать соединение.

4. Обмен ключами: При успешной проверке сертификата клиент генерирует случайный ключ (Session Key), который будет использоваться для шифрования данных в текущей сессии. Затем клиент шифрует этот случайный ключ с использованием публичного ключа, полученного из сертификата сервера.

5. Передача зашифрованного ключа: Клиент отправляет зашифрованный случайный ключ серверу. Сервер, владеющий соответствующим закрытым ключом, дешифрует ключ и получает доступ к нему.

6. Шифрование данных: Теперь у клиента и сервера есть общий случайный ключ (Session Key), который будет использоваться для шифрования и дешифрования данных, передаваемых между ними. Клиент и сервер могут использовать симметричное шифрование, такое как AES (Advanced Encryption Standard), для защиты информации.

7. Обмен данными: После установки защищенного соединения все данные, передаваемые между клиентом и сервером, шифруются с использованием общего ключа. Таким образом, даже если третье лицо перехватывает данные, они остаются незашифрованными, и только клиент и сервер могут расшифровывать их с использованием общего ключа.

В результате всех этих шагов данные передаются по защищенному каналу между клиентом и сервером, обеспечивая конфиденциальность и целостность информации.

[к оглавлению](#spring)

## 47.	HTTP методы

<img width="1004" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/b19004d1-0a6f-43f7-9345-897038862d37">

В протоколе HTTP (HyperText Transfer Protocol) существует несколько методов, которые определяют, как клиент и сервер взаимодействуют друг с другом в процессе передачи данных. Рассмотрим наиболее распространенные HTTP методы:

1. GET: Метод GET используется для запроса ресурса с сервера. Клиент отправляет GET-запрос указывая URL ресурса, и сервер возвращает содержимое этого ресурса в ответ.

2. POST: Метод POST используется для отправки данных на сервер для обработки. Например, при заполнении формы на веб-странице, данные из формы отправляются на сервер с помощью POST-запроса для дальнейшей обработки.

3. PUT: Метод PUT используется для загрузки или обновления ресурса на сервере. Клиент отправляет PUT-запрос, указывая URL ресурса и его содержимое, и сервер сохраняет или обновляет ресурс в соответствии с переданными данными.

4. DELETE: Метод DELETE используется для удаления указанного ресурса на сервере. Клиент отправляет DELETE-запрос указывая URL ресурса, и сервер удаляет этот ресурс, если он существует.

5. PATCH: Метод PATCH используется для частичного обновления ресурса на сервере. Клиент отправляет PATCH-запрос, указывая URL ресурса и передавая только необходимые изменения, которые должны быть внесены в ресурс. Остальная часть ресурса остается без изменений.

6. HEAD: Метод HEAD похож на GET, но в ответ на HEAD-запрос сервер отправляет только заголовки ответа без тела ответа. Это полезно, когда клиенту нужно получить только метаданные ресурса, без самого содержимого.

7. OPTIONS: Метод OPTIONS используется для получения доступных опций или параметров, связанных с ресурсом или сервером. Клиент отправляет OPTIONS-запрос на сервер, и сервер возвращает информацию о поддерживаемых методах, заголовках и других настройках.

Все эти методы позволяют клиенту и серверу взаимодействовать и выполнять необходимые операции в рамках протокола HTTP. Каждый метод имеет свое назначение и используется в соответствии с конкретными требованиями и задачами веб-приложений и API.

---------------
Методы HTTP и HTTPS отличаются друг от друга только в отношении безопасности передачи данных. HTTP (Hypertext Transfer Protocol) является стандартным протоколом передачи данных в Интернете, в то время как HTTPS (Hypertext Transfer Protocol Secure) - это защищенная версия HTTP, которая использует шифрование для защиты данных.

Теперь давайте рассмотрим разницу между методами POST и PUT в HTTP протоколе:

1. POST (Создание) - Этот метод используется для создания нового ресурса на сервере. Он отправляет данные от клиента к серверу и просит сервер сохранить их. Когда клиент отправляет POST-запрос, сервер создает новый ресурс и возвращает в ответ статус 201 (Created), а также может предоставить клиенту информацию о созданном ресурсе. POST-запросы неидемпотентны, что означает, что повторное выполнение POST-запроса приведет к созданию нового ресурса каждый раз.

Пример использования POST-метода:
```
POST /api/users HTTP/1.1
Host: example.com
Content-Type: application/json

{
  "name": "John",
  "email": "john@example.com"
}
```

2. PUT (Обновление) - Этот метод используется для обновления существующего ресурса на сервере. Он отправляет данные от клиента к серверу и просит сервер обновить указанный ресурс. Когда клиент отправляет PUT-запрос, сервер обновляет ресурс и возвращает в ответ статус 200 (OK) или 204 (No Content), в зависимости от того, возвращает ли сервер тело ответа или нет. PUT-запросы идемпотентны, что означает, что повторное выполнение PUT-запроса не приведет к созданию дополнительных или изменению текущих ресурсов.

Пример использования PUT-метода:
```
PUT /api/users/123 HTTP/1.1
Host: example.com
Content-Type: application/json

{
  "name": "John Doe",
  "email": "john.doe@example.com"
}
```

В обоих примерах выше мы отправляем данные в формате JSON на указанный URL-адрес. В запросах также указывается заголовок Content-Type, чтобы сервер понимал формат передаваемых данных.

-------------
Вот подробное описание основных методов HTTP с примерами:

1. GET (Получение) - Этот метод используется для получения содержимого ресурса с сервера. Он запрашивает данные от сервера и возвращает ответ с содержимым ресурса. GET-запросы являются идемпотентными, так как повторное выполнение одного и того же GET-запроса не должно изменять состояние сервера. Этот метод обычно используется для получения HTML-страниц, изображений, файлов и других статических ресурсов.

Пример использования GET-метода:
```
GET /api/users/123 HTTP/1.1
Host: example.com
```

2. POST (Создание) - Этот метод используется для создания нового ресурса на сервере. Он отправляет данные от клиента к серверу и просит сервер сохранить их. Когда клиент отправляет POST-запрос, сервер создает новый ресурс и возвращает в ответ статус 201 (Created), а также может предоставить клиенту информацию о созданном ресурсе. POST-запросы неидемпотентны, что означает, что повторное выполнение POST-запроса приведет к созданию нового ресурса каждый раз.

Пример использования POST-метода:
```
POST /api/users HTTP/1.1
Host: example.com
Content-Type: application/json

{
  "name": "John",
  "email": "john@example.com"
}
```

3. PUT (Обновление) - Этот метод используется для обновления существующего ресурса на сервере. Он отправляет данные от клиента к серверу и просит сервер обновить указанный ресурс. Когда клиент отправляет PUT-запрос, сервер обновляет ресурс и возвращает в ответ статус 200 (OK) или 204 (No Content), в зависимости от того, возвращает ли сервер тело ответа или нет. PUT-запросы идемпотентны, что означает, что повторное выполнение PUT-запроса не приведет к созданию дополнительных или изменению текущих ресурсов.

Пример использования PUT-метода:
```
PUT /api/users/123 HTTP/1.1
Host: example.com
Content-Type: application/json

{
  "name": "John Doe",
  "email": "john.doe@example.com"
}
```

4. DELETE (Удаление) - Этот метод используется для удаления указанного ресурса на сервере. Он отправляет запрос для удаления ресурса и возвращает в ответ статус 200 (OK) или 204 (No Content). DELETE-запросы идемпотентны, что означает, что повторное выполнение DELETE-запроса не приведет к ошибке или изменению состояния сервера.

Пример использования DELETE-метода:
```
DELETE /api/users/123 HTTP/1.1
Host: example.com
```

5. PATCH (Частичное обновление) - Этот метод используется для частичного обновления существующего ресурса на сервере. Он отправляет данные от клиента к серверу, содержащие только обновленные значения или инструкции для обновления ресурса. Сервер обрабатывает полученную информацию и обновляет соответствующие части ресурса. Как и PUT, PATCH-запросы также идемпотентны.

Пример использования PATCH-метода:
```
PATCH /api/users/123 HTTP/1.1
Host: example.com
Content-Type: application/json

{
  "name": "John Doe"
}
```

[к оглавлению](#spring)

## 48.	Ключевое отличие методов POST и GET

<img width="770" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/e506156a-0f79-46e9-9a70-23c4086687cd">

<img width="989" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/7b32984d-6ee1-4a96-b244-bf18d668a22c">

Основные ключевые отличия между методами POST и GET в протоколе HTTP заключаются в следующем:

1. Цель запроса:
   - GET: Метод GET используется для получения данных и ресурсов с сервера. Он предназначен для получения информации без изменения состояния сервера. Параметры запроса обычно передаются через URL (часть запроса после знака вопроса).
   - POST: Метод POST используется для отправки данных на сервер для создания нового ресурса или выполнения каких-либо изменений на сервере. Он предназначен для отправки данных в теле запроса, которые могут быть сохранены на сервере.

2. Формат данных:
   - GET: Данные GET-запроса обычно прикрепляются к URL в виде строки запроса (query string). Они видны в адресной строке браузера и могут быть закешированы. GET-запросы могут передавать только ограниченное количество данных.
   - POST: Данные POST-запроса передаются в теле запроса, а не в URL. Они не отображаются в адресной строке и могут быть отправлены в большем объеме. POST-запросы могут передавать различные типы данных, такие как JSON, XML или формы с файлами.

3. Безопасность:
   - GET: GET-запросы считаются безопасными, так как они только запрашивают данные с сервера и не вносят изменений на сервере.
   - POST: POST-запросы могут содержать чувствительную информацию, такую как пароли или личные данные, поэтому они могут потенциально быть менее безопасными. Однако, при использовании HTTPS (шифрованного соединения) данные POST-запросов защищены от несанкционированного доступа.

4. Идемпотентность:
   - GET: GET-запросы считаются идемпотентными, что означает, что повторное выполнение GET-запроса не должно привести к изменению состояния сервера. Они могут кэшироваться браузерами или прокси-серверами.
   - POST: POST-запросы не являются идемпотентными, поскольку при каждой отправке поступает новая информация на сервер, что может изменить состояние сервера, например, создать новый ресурс с каждым запросом.

5. Кэширование:
   - GET: GET-запросы могут кэшироваться, поэтому повторные запросы к одному и тому же URL могут быть обработаны локально, без отправки запроса на сервер. Это может улучшить производительность.
   - POST: POST-запросы не кэшируются по умолчанию, так как они могут содержать изменчивые данные и могут иметь побочные эффекты на сервере.

[к оглавлению](#spring)

## 49.	REST стиль

REST API (Representational State Transfer API) – это архитектурный стиль взаимодействия компонентов распределенного веб-приложения.  
 
Компоненты в REST взаимодействуют в сети Интернет в качестве клиентов и серверов.  

REST - набор соглашений взаимодействия с HTTP.  

Определяет стиль взаимодействия между разными компонентами системы. 
 
REST означает передачу репрезентативного состояния. 
 
Если разрабатывается публичное API и логика взаимодействия во многом покрывается четверкой методов CRUD - выбирается REST. Он наиболее популярен в WEB. Яндекс, Google и другие используют именно его для своего API.  
 
ВАЖНО! Корзина должна быт на стороне клиента (иначе это не REST). Храним состояние клиента на стороне КЛИЕНТА (а не на сервере). Клиент наполняет корзину и ОДИН раз id заказа отправляем на сервер. 
 
Representational - ресурсы в REST могут быть представлены в любой форме - JSON, XML, текст, или даже HTML- зависит от того, какие данные больше подходят потребителю. 

<img width="1024" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/1452ceb5-0eee-4e71-852a-d5b278f5c14b">

<img width="977" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/c15afa01-ecab-4b58-9bf3-7397fee5759b">

--------
REST (Representational State Transfer) - это архитектурный стиль, используемый для разработки распределенных приложений, основанный на протоколе HTTP. REST позволяет построить масштабируемые и гибкие системы, где клиенты и серверы могут взаимодействовать независимо друг от друга.

REST API (Application Programming Interface) - это интерфейс приложения, который предоставляет доступ к функциональности и данным через RESTful веб-сервисы. REST API использует стандартные HTTP методы (GET, POST, PUT, DELETE) для выполнения операций над ресурсами.

Вот примеры реализации REST API на Java с использованием фреймворка Spring Boot:

1. Создание простого REST-контроллера:

```java
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @GetMapping("/{id}")
    public User getUser(@PathVariable Long id) {
        // Логика получения пользователя по идентификатору
        return userService.getUserById(id);
    }
    
    @PostMapping
    public User createUser(@RequestBody User user) {
        // Логика создания пользователя
        return userService.createUser(user);
    }
    
    @PutMapping("/{id}")
    public User updateUser(@PathVariable Long id, @RequestBody User user) {
        // Логика обновления пользователя
        return userService.updateUser(id, user);
    }
    
    @DeleteMapping("/{id}")
    public void deleteUser(@PathVariable Long id) {
        // Логика удаления пользователя
        userService.deleteUser(id);
    }
}
```

2. Конфигурация Spring Boot приложения:

```java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class Application {
    
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

В приведенном выше примере создается контроллер для работы с пользователями. Он определяет различные методы, соответствующие операциям REST API (получение, создание, обновление, удаление пользователя). Аннотации, такие как `@RestController`, `@GetMapping`, `@PostMapping`, `@PutMapping`, `@DeleteMapping` используются для указания URL-адресов и методов HTTP запросов, обрабатываемых контроллером.

Важно отметить, что в примере использованы `@PathVariable` и `@RequestBody`. `@PathVariable` используется для извлечения значения из URL-пути, например, идентификатора пользователя. `@RequestBody` используется для получения данных из тела HTTP запроса в объект `User`.

Это лишь небольшой пример, и REST API может быть более сложным и содержать множество ресурсов, операций и дополнительных функций. Однако принципы RESTful архитектуры, такие как использование стандартных методов HTTP и работа с ресурсами, остаются важными элементами при разработке REST API.

----------
"Распределенное приложение" означает приложение, которое работает на нескольких компьютерах или серверах, и взаимодействует с другими приложениями и сервисами через сеть.

В распределенных приложениях различные компоненты приложения могут быть разделены и развернуты на разных узлах, и взаимодействие между ними происходит через сетевые протоколы, такие как HTTP. В этом случае, клиентское приложение может отправлять запросы на удаленные серверы, которые предоставляют REST API, и получать ответы для выполнения необходимых операций.

Распределенные приложения позволяют достичь лучшей масштабируемости, отказоустойчивости и гибкости, так как различные компоненты могут быть масштабированы независимо и работать на разных физических или виртуальных серверах.

[к оглавлению](#spring)

## 50.	Идемпотентность: что это такое, методы

<img width="1023" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/e626c7fb-d109-4324-9148-8523a9b782e4">

ВАЖНО!  

Идемпотентность не гарантирует. Что получим такой же ответ. 

Например, используя метод DELETE, первый раз объект удалили, а второй раз получили 404 not found… И, хотя состояние объекта не изменилось, но получили другой ответ.\ То есть ответ может менять в зависимости от операции. 

------------
Идемпотентность - это свойство операции, когда её множественное применение к целевому объекту имеет тот же результат, что и однократное применение. Другими словами, повторное выполнение идемпотентной операции не приводит к изменению состояния системы после первоначального выполнения.

Веб-методы, которые обычно считаются идемпотентными, включают:

1. GET: Получение данных не должно изменять состояние сервера.
2. PUT: Замена или обновление существующего ресурса. Повторное выполнение запроса с теми же данными не должно иметь побочных эффектов.
3. DELETE: Удаление существующего ресурса. Идемпотентным будет идти на удаление несуществующего ресурса.

[к оглавлению](#spring)

## 51.	Как метод пост сделать идемпотентным?

Метод POST обычно считается неидемпотентным, так как при повторном выполнении запроса создается новый ресурс или выполняются другие побочные эффекты. Однако, если вы хотите сделать метод POST идемпотентным, можно реализовать следующие подходы:

1. Уникальный идентификатор запроса: Включите в запрос уникальный идентификатор, который будет использоваться для определения дублирующихся запросов. Сервер может проверить этот идентификатор и игнорировать повторные запросы.

2. Проверка состояния: Перед созданием нового ресурса с помощью POST, выполните проверку состояния, чтобы убедиться, что ресурс не был создан ранее. Например, сервер может выполнить запрос GET для проверки существования ресурса перед его созданием.

3. Возврат состояния: В ответ на POST-запрос сервер может вернуть информацию о созданном ресурсе, включая его идентификатор. В последующих запросах клиент может использовать эту информацию для получения или обновления ресурса, делая запросы идемпотентными.

-------------
Хорошо, давайте рассмотрим несколько примеров того, как можно сделать метод POST идемпотентным.

1. Использование уникального идентификатора запроса:
   При выполнении POST-запроса можно включить в тело запроса или в заголовок уникальный идентификатор, который будет использоваться для определения дублирующихся запросов. Например, вы можете добавить заголовок "Request-ID" со значением уникального идентификатора, сгенерированного клиентом или сервером. Сервер может проверить этот идентификатор и игнорировать повторные запросы. Вот пример использования заголовка "Request-ID" в запросе:

   ```
   POST /api/resource
   Host: example.com
   Content-Type: application/json
   Request-ID: 12345
   
   {"data": "example"}
   ```

   Если сервер обнаруживает повторный запрос с тем же идентификатором "12345", он может проигнорировать его и вернуть предыдущий результат.

2. Проверка существующего состояния:
   Перед созданием нового ресурса с помощью POST можно выполнить проверку состояния, чтобы убедиться, что ресурс не был создан ранее. Например, предположим, у вас есть API для создания пользователей. Вы можете сначала выполнить GET-запрос для проверки существования пользователя с указанным именем перед выполнением POST-запроса. Если пользователь с таким именем уже существует, сервер может вернуть существующий ресурс вместо создания нового. Вот пример:

   ```
   GET /api/users?name=johndoe
   Host: example.com
   ```

   Если сервер возвращает существующего пользователя, клиент может использовать эту информацию для дальнейших действий, не создавая дубликатов.

3. Возврат информации о созданном ресурсе:
   В ответ на POST-запрос сервер может вернуть информацию о созданном ресурсе, включая его идентификатор. Клиент может использовать эту информацию для получения или обновления ресурса в последующих запросах. Например, при создании нового поста в блоге сервер может вернуть информацию о созданном посте, включая его уникальный идентификатор. Клиент может сохранить этот идентификатор и использовать его для обновления поста в будущем, делая запросы идемпотентными.

[к оглавлению](#spring)

## Дополнительные вопросы из интернета


### Расскажи подробно про интерфейс Resource в spring
-------------
В Spring Framework интерфейс `Resource` является абстракцией для работы с различными типами ресурсов, такими как файлы, классы, URL-ы и другие источники данных. Он предоставляет унифицированный способ получения доступа к ресурсам, независимо от их физического расположения или типа.

`Resource` предоставляет следующие основные методы:

1. `isReadable()`: Определяет, доступен ли ресурс для чтения.

2. `getInputStream()`: Возвращает `InputStream` для чтения содержимого ресурса.

3. `exists()`: Проверяет, существует ли ресурс.

4. `isOpen()`: Проверяет, открыт ли ресурс.

5. `getURL()`: Возвращает `URL` ресурса.

6. `getFile()`: Возвращает файловый объект ресурса.

7. `getFilename()`: Возвращает имя файла ресурса.

8. `getDescription()`: Возвращает описание ресурса.

Как получить экземпляр `Resource` в вашем коде? В Spring Framework это можно сделать с помощью различных реализаций `Resource`, включая:

- `ClassPathResource`: Предоставляет доступ к ресурсам, находящимся в пути класса (class path).
- `FileSystemResource`: Предоставляет доступ к ресурсам на файловой системе.
- `UrlResource`: Предоставляет доступ к ресурсам по URL-адресу.
- `ByteArrayResource`: Предоставляет доступ к ресурсам в виде массива байтов.
- `ServletContextResource`: Предоставляет доступ к ресурсам, расположенным в контексте веб-приложения.

Пример использования интерфейса `Resource`:

```java
import org.springframework.core.io.Resource;
import org.springframework.core.io.ClassPathResource;

public class ResourceExample {
    public static void main(String[] args) {
        Resource resource = new ClassPathResource("example.txt");
        
        if (resource.exists()) {
            try {
                InputStream inputStream = resource.getInputStream();
                // Чтение данных из потока
                
                // Закрытие потока
                inputStream.close();
            } catch (IOException e) {
                // Обработка исключения
            }
        }
    }
}
```

В этом примере мы создали экземпляр `Resource` с помощью `ClassPathResource`, который ищет файл "example.txt" в пути класса. Мы затем проверяем, существует ли ресурс, и если да, получаем `InputStream` для чтения его содержимого.

Использование `Resource` в Spring Framework позволяет абстрагироваться от конкретной реализации ресурса и упрощает доступ к ним в приложении.



### Каков механизм формирования спрингом sql запросов из имен методов?
--------------
Spring Framework предоставляет мощный механизм под названием "Spring Data JPA", который позволяет автоматически генерировать SQL-запросы на основе имен методов в репозиториев.

Для использования этого механизма необходимо выполнить следующие шаги:

1. Определить интерфейс репозитория, расширяющий `CrudRepository` или `JpaRepository`. Например:

```java
import org.springframework.data.repository.CrudRepository;

public interface UserRepository extends CrudRepository<User, Long> {
    User findByUsername(String username);
}
```

2. Создать собственный метод в интерфейсе репозитория, используя специальные ключевые слова и шаблоны имен методов. В данном примере метод `findByUsername()` позволяет найти пользователя по его имени.

3. Запустить приложение Spring и использовать методы репозитория для выполнения операций с базой данных. Например:

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;

@Component
public class DemoRunner implements CommandLineRunner {
  
    @Autowired
    private UserRepository userRepository;

    @Override
    public void run(String... args) throws Exception {
        User user = userRepository.findByUsername("john.doe");
        System.out.println(user.getId() + ":" + user.getUsername());
    }
}
```

В этом примере мы внедрили `UserRepository` в `DemoRunner` и использовали метод `findByUsername()` для поиска пользователя по его имени.

Spring Data JPA будет анализировать имя метода и автоматически генерировать SQL-запрос соответствующий указанному имени. В данном случае, Spring Data JPA сгенерирует SQL-запрос, который будет искать пользователя по имени в таблице, соответствующей сущности `User`.

Преимуществом этого механизма является автоматическая генерация SQL-запросов на основе имен методов, что позволяет значительно упростить работу с базой данных и избежать написания SQL-запросов вручную.

Когда Spring формирует SQL-запросы из имен методов, он использует механизм называемый "Query Creation" в рамках Spring Data JPA.

Механизм формирования SQL-запросов основан на конвенции и шаблонах имен методов. По умолчанию, Spring анализирует имя метода репозитория, чтобы определить, какой SQL-запрос нужно выполнить.

Вот некоторые ключевые слова и шаблоны имен методов, которые Spring Data JPA использует для формирования SQL-запросов:

- `findBy`: используется для поиска записей по определенным полям. Например, `findByUsername(String username)` будет искать записи, у которых значение поля "username" соответствует указанному значению.

- `countBy`: используется для подсчета количества записей, удовлетворяющих указанным условиям. Например, `countByUsername(String username)` будет подсчитывать количество записей, у которых значение поля "username" соответствует указанному значению.

Кроме того, вы можете комбинировать ключевые слова и операторы, такие как `And`, `Or`, `Is`, `Not`, чтобы создавать более сложные запросы и условия.

Spring Data JPA анализирует имя метода, разбирает его на части и внедряет условия в SQL-запросы, формируя параметризованные запросы. Это помогает предотвратить атаки SQL инъекции и обеспечивает безопасное выполнение запросов.

Если необходимо реализовать более сложные запросы, которые нельзя сформировать с использованием шаблонов имен методов, можно использовать аннотацию `@Query`, чтобы написать пользовательский SQL-запрос внутри метода репозитория.

Вот пример использования аннотации `@Query`:

```java
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;

public interface UserRepository extends JpaRepository<User, Long> {
  
    @Query("SELECT u FROM User u WHERE u.username = ?1 AND u.enabled = true")
    User findEnabledUserByUsername(String username);
}
```

В этом примере мы написали пользовательский SQL-запрос с использованием аннотации `@Query`. Запрос выбирает пользователя, у которого имя соответствует указанному значению и поле "enabled" равно `true`.

Вы можете найти и прочитать о все ключевых словах и шаблонах имен методов, используемых Spring Data JPA для формирования SQL-запросов, в официальной документации Spring Data.

Вот ссылка на документацию Spring Data JPA, где вы можете найти дополнительную информацию об именованных методах запросов (Query Creation):

https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.query-creation

В этом разделе документации описаны различные ключевые слова и операторы, их синтаксис и способы использования для создания запросов. Вы также найдете примеры кода, чтобы лучше понять, как использовать эти ключевые слова в ваших собственных методах репозитория.

Spring Data JPA использует соглашения о наименовании методов для преобразования имен методов репозитория в соответствующие SQL-запросы. Некоторые общие шаблоны имен методов и их соответствующие операторы SQL приведены ниже:

1. `findBy`: Этот префикс указывает на выполнение операции SELECT. За `By` следует поле, по которому нужно выполнить поиск. Примеры: `findByFirstName`, `findByAge`, `findByLastNameAndFirstName`, и т.д.

2. `countBy`: Этот префикс указывает на выполнение операции COUNT. За `By` следует поле, по которому нужно выполнить подсчет. Примеры: `countByFirstName`, `countByAge`, `countByLastNameAndFirstName`, и т.д.

3. `deleteBy`: Этот префикс указывает на выполнение операции DELETE. За `By` следует поле, по которому нужно выполнить удаление. Примеры: `deleteByFirstName`, `deleteByAge`, `deleteByLastNameAndFirstName`, и т.д.

Важно отметить, что Spring Data JPA распознает не только ключевые слова, указанные в документации, но также позволяет формировать запросы на основе имен методов, используя специальные ключевые слова или модификаторы, такие как `Distinct`, `IgnoreCase`, `OrderBy` и др.

Также возможно использование операторов, таких как `and`, `or`, `not` для комбинирования условий в запросах.

Например, метод с именем `findByLastNameAndAge` будет автоматически преобразован в запрос вида:

```sql
SELECT * FROM table_name WHERE last_name = ? AND age = ?
```

Если вам нужно более сложное или специфичное поведение запроса, вы можете использовать аннотацию `@Query` и написать собственный SQL-запрос.



### Чем бин отличется от pojo класса?
--------------
Концепции "POJO" (Plain Old Java Object) и "бин" относятся к различным подходам в объектно-ориентированном программировании. Вот основные отличия между ними:

POJO (Plain Old Java Object):
- POJO класс - это простой Java класс, который обычно является частью бизнес-модели или слоя данных приложения.
- POJO класс обычно не зависит от каких-либо специфических фреймворков или библиотек. Он может быть написан с использованием стандартных языковых средств Java.
- POJO класс не требует специальных аннотаций или наследования от конкретных классов или интерфейсов.

Бин:
- Бин (bean) в контексте Java является специальным типом POJO класса, который управляется контейнером (например, фреймворком Spring).
- Бин обычно используется для создания компонентов приложения и интеграции их в контейнер управления.
- Бин может содержать специальные аннотации или конфигурационные дескрипторы, которые определяют его поведение и связи с другими компонентами.
- Контейнер управления (например, контекст Spring) обычно отвечает за создание и жизненный цикл бинов, а также за внедрение зависимостей между ними.

Таким образом, POJO класс является общим термином для простого Java класса, тогда как бин - это конкретный тип POJO класса, используемый в контексте управляемого контейнера или фреймворка.



### Для чего существует такое количество ApplicationContext?
----------------
Существует несколько типов ApplicationContext в фреймворке Spring, каждый из которых предоставляет различные функциональные возможности для управления и настройки вашего приложения. Вот несколько наиболее распространенных типов ApplicationContext:

1. AnnotationConfigApplicationContext:
   - Используется для создания контекста на основе аннотаций (Annotation-based configuration).
   - Распознает аннотации, такие как @Configuration, @ComponentScan, @Bean и другие, для определения компонентов и их взаимосвязей.

2. ClassPathXmlApplicationContext:
   - Загружает конфигурацию Spring из XML-файлов, расположенных в classpath.
   - Позволяет определить и настраивать бины и их зависимости с помощью XML-конфигурации.

3. FileSystemXmlApplicationContext:
   - Аналогичен ClassPathXmlApplicationContext, но позволяет загружать XML-конфигурацию из файловой системы.

4. WebApplicationContext:
   - Специальный тип контекста, предназначенный для веб-приложений.
   - Имеет доступ к контексту сервлета и позволяет использовать особенности веб-разработки Spring, такие как внедрение зависимостей в контроллеры и обработку запросов.

Каждый тип ApplicationContext предоставляет разные способы конфигурации и управления бинами в вашем приложении. Выбор конкретного типа зависит от вашего приложения, его архитектуры и требований.



### Что такое pojo класс в java?
------------
POJO в Java означает Plain Old Java Object (Простой, старый, обычный Java-объект). Это термин, используемый в контексте Java-программирования для обозначения простых классов, которые не зависят от фреймворка или специфической технологии.

Основные характеристики POJO-классов:

1. Простота: POJO-классы не должны обладать специальными требованиями или зависеть от фреймворков или библиотек. Они должны быть обычными классами, которые можно легко создавать, изменять и использовать.

2. Независимость от фреймворков: POJO-классы не должны иметь прямых зависимостей от какого-либо конкретного фреймворка или библиотеки, чтобы обеспечить их переносимость и повторное использование.

3. JavaBeans стандарт: POJO-классы могут следовать JavaBeans стандарту, который предоставляет соглашения для именования методов, аннотаций и других соглашений, чтобы обеспечить совместимость с различными фреймворками и инструментами.

POJO-классы широко используются в различных областях Java-разработки, включая сериализацию объектов, передачу данных между слоями приложений и взаимодействие с базами данных. Они облегчают разработку, тестируемость и поддержку приложений, поскольку не вносят лишних зависимостей и сложностей.

JavaBeans стандарт - это соглашения и правила, разработанные для создания и использования POJO-классов (Plain Old Java Objects) в Java-программировании. Они определяют набор соглашений для именования методов, использования аннотаций и других принципов, которые обеспечивают совместимость между различными фреймворками и инструментами.

Вот некоторые основные аспекты JavaBeans стандарта:

1. Установка и получение значений через методы (Getter и Setter): По соглашению, для доступа к полям объекта должны быть созданы публичные методы, которые извлекают (Getter) и устанавливают (Setter) значения для этих полей. Например, если есть поле "name", то для него должны быть методы getName() и setName().

2. Поддержка сериализации: Классы, следующие JavaBeans стандарту, должны быть сериализуемыми, то есть они должны реализовывать интерфейс `java.io.Serializable`. Это позволяет сохранять объекты в потоке и восстанавливать их обратно.

3. Использование дефолтного конструктора: POJO-классы, соответствующие JavaBeans стандарту, должны иметь публичный конструктор без аргументов (дефолтный конструктор). Это требуется для создания объектов через рефлексию и инстанцирования классов.

4. Обработка событий: JavaBeans стандарт также определяет механизм обработки событий, позволяющий реагировать на различные события, происходящие в объектах JavaBeans.

JavaBeans стандарт обеспечивает согласованность и совместимость между различными фреймворками и инструментами, которые работают с POJO-классами. Он позволяет использовать эти классы в различных технологиях, таких как сериализация, веб-фреймворки, средства привязки данных и других.



### Как можно связать бины?
-------------
Для связывания (или инъекции) бинов в Java можно использовать различные подходы, в зависимости от фреймворка или инструмента, который вы используете. Вот несколько основных способов связывания бинов:

1. Автоматическая инъекция через аннотации: Многие современные фреймворки, такие как Spring Framework, поддерживают автоматическую инъекцию зависимостей с использованием аннотаций, таких как `@Autowired`. Вы можете пометить поле, конструктор или метод в классе, который требует зависимость, и фреймворк автоматически найдет соответствующий бин и внедрит его.

2. Конфигурационные файлы: В некоторых фреймворках, таких как JavaEE или Spring, можно использовать конфигурационные файлы для явного описания связей между бинами. Например, в Spring Framework вы можете определить конфигурационный XML-файл или использовать аннотацию `@Configuration` с классом, чтобы указать, какие бины должны быть созданы и как они должны быть связаны.

3. Инъекция через конструктор: Другой популярный способ связывания бинов - это использование конструктора для внедрения зависимостей. Вы можете создать конструктор в классе, который принимает одну или несколько зависимостей в качестве параметров. При создании экземпляра класса соответствующий бин автоматически будет внедрен через этот конструктор.

4. JNDI (Java Naming and Directory Interface): JNDI - это стандартный способ в Java для доступа к удаленным и локальным сервисам по их именам. Вы можете назначить бину имя, а затем использовать JNDI для получения ссылки на этот бин и использования его в других компонентах вашего приложения.

JNDI (Java Naming and Directory Interface) представляет собой стандартный интерфейс Java для доступа к именованным объектам и службам в распределенной среде. Он предоставляет механизм для обнаружения и получения доступа к объектам по их именам в различных средах и контекстах.

JNDI позволяет создавать бины с использованием следующих шагов:

1. Определение ресурса в сервере приложений: Сначала необходимо определить ресурс, который будет представлять ваш бин. Это может быть источник данных, такой как база данных, файловая система или другой внешний сервис. Ресурс обычно настраивается в файле конфигурации сервера приложений или с помощью инструментов администрирования сервера.

2. Создание и настройка бина: Затем вы создаете ваш бин, используя Java-код. Например, можно создать класс `MyBean`, который будет представлять ваш бин. Вы можете настроить необходимые свойства и поведение бина, добавив соответствующие методы и аннотации.

3. Связывание бина с ресурсом через JNDI: Когда ваш бин создан, необходимо связать его с ранее определенным ресурсом, чтобы он мог получить доступ к нему. Для этого вам понадобится код, который выполняет связывание бина с JNDI контекстом.

Пример:

```java
// Шаг 1: Определение ресурса в сервере приложений

// Предположим, что у вас есть база данных MySQL с именем "mydb" и источником данных "jdbc/mydb".
// В этом примере мы будем использовать GlassFish сервер приложений.

// Шаг 2: Создание и настройка бина

public class MyBean {
    private DataSource dataSource; // Ссылка на ресурс базы данных

    public void setDataSource(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    public void performDatabaseOperation() throws SQLException {
        // Используем ресурс базы данных для выполнения операции
        Connection connection = dataSource.getConnection();
        // выполнение запросов к базе данных, обработка данных и т.д.
        // ...
        connection.close(); // Освобождаем соединение с базой данных
    }
}

// Шаг 3: Связывание бина с ресурсом через JNDI

// Используем InitialContext для получения контекста JNDI
Context context = new InitialContext();

// Получаем ссылку на ресурс базы данных из JNDI контекста
DataSource dataSource = (DataSource) context.lookup("jdbc/mydb");

// Создаем экземпляр бина
MyBean myBean = new MyBean();

// Связываем бин с ресурсом, передавая ссылку на ресурс базы данных
myBean.setDataSource(dataSource);

// Теперь вы можете использовать myBean для выполнения операций с базой данных
myBean.performDatabaseOperation();
```

В этом примере мы определили ресурс базы данных с помощью имени "jdbc/mydb" в сервере приложений GlassFish. Затем мы создали класс `MyBean`, который содержит ссылку на этот ресурс через `DataSource`. В итоге, мы связали бин с ресурсом, используя `context.lookup()` для поиска и получения ссылки на ресурс базы данных из JNDI контекста.

Таким образом, использование JNDI позволяет связывать бины с ресурсами и получать доступ к ним в распределенной среде.



### Какие бины будут использоваться для настройки приложения?
---------
В контексте Java-приложений, термин "бин" обычно используется для обозначения объектов, которые управляются контейнером инверсии управления (IoC) и могут быть внедрены в другие компоненты приложения. Бины обычно используются для настройки приложения путем предоставления экземпляров классов или значений параметров.

Вот несколько типов бинов, которые могут быть использованы для настройки приложения:

1. Конфигурационные бины: Это бины, которые содержат конфигурационные параметры приложения, такие как URL базы данных, порты, пути к файлам и т.д. Доступ к этим параметрам можно получить через бины во время выполнения приложения.

2. Сервисные бины: Это бины, которые предлагают функциональность или сервисы, необходимые другим компонентам приложения. Например, веб-службы, утилиты для работы с данными, обработчики событий и другие компоненты, которые выполняют важные операции в приложении.

3. Хранилище данных (Data Access) бины: Эти бины отвечают за доступ к данным, таким как базы данных, файловые системы, внешние API и другие источники данных. Они обеспечивают методы и операции для чтения, записи, обновления и удаления данных из указанных источников.

4. Утилитарные бины: Эти бины предоставляют различные утилиты, которые могут быть использованы в приложении, такие как преобразования данных, форматирование, шифрование, проверка подлинности и другие функции, упрощающие разработку и обслуживание приложения.

5. Контроллеры и компоненты представления: Эти бины используются в веб-приложениях для обработки запросов, управления потоком выполнения и взаимодействия с пользовательским интерфейсом. Они обрабатывают входящие запросы, а затем вызывают соответствующие сервисные бины для выполнения бизнес-логики.

Это только небольшой список категорий бинов, которые могут быть использованы для настройки приложения. Фактическое количество и типы бинов зависят от конкретных потребностей вашего приложения и фреймворка, который вы используете для его разработки.

<img width="569" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/0921893e-721c-4fe8-abb5-dac42d16decf">



### Как получить данные из файлла  .property (spring)?
-----------
1) Аннотация @Value
2) Environment и метод getProperty()
3) создание pojo класса с аннотациями @Configuration и @ConfigurationProperties

Подробнее -> https://rukovodstvo.net/posts/id_584/

<img width="637" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/fcca882b-60d8-4333-ae55-2482ee56b7b2">



### Как запустить спринг-приложение из под сервера tomcat?
----------------
Для запуска Spring-приложения под сервером Tomcat вы можете следовать следующим шагам:

1. Создайте WAR-файл: Убедитесь, что ваше Spring-приложение настроено для создания WAR-файла вместо JAR-файла. Если вы используете Maven, убедитесь, что у вас есть плагин `spring-boot-maven-plugin` с настройкой `<packaging>war</packaging>` в секции `<build>` вашего файла `pom.xml`.

2. Соберите приложение: Используйте инструмент сборки, такой как Maven или Gradle, чтобы собрать ваше приложение и создать WAR-файл.

3. Установите Tomcat: Установите сервер Tomcat и убедитесь, что он запущен и работает.

4. Разместите WAR-файл в Tomcat: Переместите созданный WAR-файл в директорию `webapps` в директории установки Tomcat.

5. Запустите Tomcat: Запустите сервер Tomcat, выполнив соответствующий файл запуска (например, `startup.bat` для Windows или `startup.sh` для Unix/Linux). Tomcat начнет развертывание вашего приложения из файла WAR.

6. Проверьте развертывание: После успешного развертывания вы можете проверить свое приложение, перейдя по URL-адресу `http://localhost:8080/your-app-context`, где `your-app-context` - это контекст вашего приложения.

Убедитесь, что правильно настроили файл `pom.xml` или скрипт сборки, создали WAR-файл и разместили его в правильном месте в Tomcat. Если возникнут ошибки или проблемы, проверьте журналы Tomcat для получения дополнительной информации.

<img width="712" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/7b92c2a3-6587-4119-8740-967437107c0b">



### Что такое artifacts?
----------
Артефакты (artifacts) - это выходные данные или результаты процесса разработки, такие как скомпилированный код, библиотеки, исполняемые файлы, документация, конфигурационные файлы, изображения и т. д. Артефакты представляют собой продукты или результаты, созданные в процессе разработки программного обеспечения.

В контексте сборки приложения, артефактом может быть готовый JAR-файл, WAR-файл или другой вид пакета, содержащий весь необходимый код, ресурсы и зависимости для запуска приложения. Артефакты являются финальными результатами процесса сборки и могут быть развернуты или использованы для дальнейшего развертывания или доставки приложения в производственную среду или другие окружения.

В среде разработки Java, такой как Maven или Gradle, артефакты обычно определяются с помощью конфигурации упаковщика (packaging) в файле `pom.xml` (для Maven) или скрипта сборки (для Gradle). Эти инструменты автоматически генерируют и упаковывают артефакты согласно заданным настройкам.

<img width="706" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/1820899a-cecf-4f9c-89e0-2b7155afae56">



### В чем отличие артефакта war от war exploded?
--------------
Артефакт WAR (Web application archive) и артефакт WAR exploded (распакованный WAR) представляют два различных способа организации и развертывания веб-приложения.

1. WAR (Web application archive):
WAR-файл является архивом, содержащим все необходимые файлы и ресурсы для веб-приложения, компактно упакованными в один файл. WAR-файл обычно содержит исходные файлы приложения (.class файлы, JSP-страницы, HTML, CSS, JavaScript и т. д.), библиотеки, конфигурационные файлы и ресурсы. WAR-файл может быть развернут на веб-сервере, таком как Apache Tomcat или Jetty, путем его размещения в определенной директории веб-сервера или с использованием инструментов управления развертыванием.

2. WAR exploded (распакованный WAR):
WAR exploded представляет собой распакованную версию WAR-файла, то есть все файлы и ресурсы извлечены из архива и лежат в нативной файловой системе. Вместо одного файла WAR, распакованный WAR представляет собой обычную директорию, содержащую все компоненты веб-приложения в их оригинальных файлах и папках. Распакованный WAR может быть использован для локальной разработки, отладки и тестирования веб-приложений или для обновления и модификации компонентов приложения на сервере без необходимости разворачивания нового архива.

Таким образом, основное отличие между артефактом WAR и WAR exploded заключается в способе организации и упаковки компонентов веб-приложения. WAR представляет собой архивный файл, тогда как WAR exploded содержит все файлы и ресурсы в распакованном состоянии в виде обычной директории.



### Чем контроллер отличается от сервлета?
---------
<img width="717" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/937e6340-b95a-4670-bc05-f8937215be5c">

1. Сервлет:
Сервлет (Servlet) - это Java класс, который используется для обработки HTTP запросов и генерации HTTP ответов. Сервлет работает на сервере и обычно используется для создания динамических веб-страниц. Он взаимодействует с клиентскими запросами, анализирует параметры запроса, выполняет необходимые операции и генерирует ответы, которые отправляются обратно клиенту. Сервлеты обычно принимают форму .java файлов, которые компилируются в .class файлы и развертываются на сервере приложений.

2. Контроллер:
Контроллер (Controller) - это компонент в архитектуре MVC (Model-View-Controller), который управляет потоком выполнения веб-приложения. Контроллер отвечает за обработку входных запросов от клиента, принимает решения о дальнейших действиях на основе этих запросов и координирует работу модели и представления. Он связывает данные и бизнес-логику с пользовательским интерфейсом. В контексте Java веб-разработки, контроллеры обычно представляют собой классы, которые получают запросы от пользователей, обрабатывают их, вызывают соответствующие сервисы или модели и возвращают представления для отображения результатов обратно пользователю.

Таким образом, основное отличие между контроллером и сервлетом заключается в их роли и контексте использования. Сервлеты - это низкоуровневые компоненты, работающие с HTTP протоколом, обрабатывающие запросы и генерирующие ответы. Контроллеры - это высокоуровневые компоненты, управляющие потоком выполнения веб-приложения и связывающие модель, представление и данные.



### Какая основная зависимость фреймворка Спринг? Почему во многих сборках она не указывается явно?
-------------------
Основная зависимость фреймворка Spring - это зависимость от модуля Spring Core (spring-core). Этот модуль предоставляет основные функциональные возможности фреймворка, такие как инверсия управления (Inversion of Control, IoC) и внедрение зависимостей (Dependency Injection, DI). 

Однако, в некоторых сборках или в проектах, где уже присутствуют другие модули Spring, зависимость от модуля Spring Core может не указываться явно в файле сборки (например, pom.xml в случае Maven). Это связано с тем, что некоторые модули Spring уже являются зависимостями других модулей, и поэтому модуль Spring Core автоматически подключается через эти зависимости. Таким образом, указание зависимости от Spring Core становится избыточным, поскольку она уже включена в другие модули.



### Основные паттерны Spring

DI, IoC,Proxy,Singleton,Factory,Template,MVC,Front Controller,Service locator

Proxy (Заместитель) - представляет функциональные возможности другого класса. объект-оболочка или агент, который вызывается клиентом для доступа к реальному обслуживающему объекту за кулисами. Обеспечивает защиту исходного объекта от внешнего мира.

Singleton (Одиночка) - гарантирует, что в памяти будет существовать только один экземпляр объекта, который будет предоставлять сервисы. Рекомендуется использовать бинов без состояния.

Factory (Фабрика) -позволяет инициализировать объект через фабричный метод(BeanFactory - Простой контейнер, который обеспечивает базовую поддержку DI (Dependency Injection, инъекция зависимостей). Для работы с этим контейнером используется интерфейс org.springframework.beans.factory.BeanFactory; ApplicationContext - объявляет специфичные enterprise-функции. Эти функции включают в себя возможность чтения параметров из property-файлов и публикацию событий приложения для слушателей событий (предназначен для обработки какого-либо события - он«слушает» событие, например щелчок мышью пользователя или нажатие клавиши, а затем реагирует соответствующим образом.). Для работы с этим контейнером используется интерфейс
org.springframework.context.ApplicationContext.).

Template (Шаблон) - название говорит само за себя. Пример использования - запрос к базе данных: установка соединения ~> запрос ~> получить всех пацан0ff ~> закрыть соединение.

Model View Controller (Модель-Представление-Контроллер) - основная задача - отделить логику от визуализации. Паттерн основан на Servlet API. В данном паттерне компоненты не зависят друг от друга и каждый отвечает за определенную задачу.

Front Controller (Контроллер запросов) - Spring предоставляет DispatcherServlet, чтобы гарантировать, что входящий запрос будет отправлен вашим контроллерам. Паттерн используется для того, чтобы все запросы обрабатывались одним обработчиком и передавались в main, что так же в свою очередь обеспечивает дополнительную безопасность и удобство для разработчика.

View Helper (Вспомогательный компонент представления) - отделяет статическое содержимое в представлении, такое как JSP, HTML, от обработки бизнес-логики. У спринга есть своя библиотека для инкапсуляции логики обработки в хелперах.

Service Locator (Локатор служб) - используется, когда мы хотим найти различные сервисы, используя JNDI (Java Naming and Directory Interface - это набор Java API, организованный в виде службы каталогов, который позволяет Java-клиентам открывать и просматривать данные и объекты по их именам.). При запросе сервиса первый раз Service Locator ищет его в JNDI и кэширует
объект. Дальнейший поиск этого же сервиса через Service Locator выполняется в кэше, что значительно улучшает производительность приложения.

Observer-Observable (Наблюдатель) - Используется в механизме событий ApplicationContext. Определяет зависимость "один-ко-многим" между объектами, чтобы при изменении состояния одного объекта все его подписчики уведомлялись и обновлялись автоматически.

Context Object (Контекстный объект) - Паттерн Context Object, инкапсулирует системные данные в объекте-контексте для совместного использования другими частями приложения без привязки приложения к конкретному протоколу.

ApplicationContext является центральным интерфейсом в приложении Spring для предоставления информации о конфигурации приложения.


[к оглавлению](#spring)

