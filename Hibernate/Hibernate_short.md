# Hibernate


+ [Что такое ORM?](#что-такое-orm)
+ [Что такое JPA?](#что-такое-jpa)
+ [Что появилось раньше JPA или Hibernate?](#что-появилось-раньше-jpa-или-hibernate)
+ [Что такое Hibernate?](#что-такое-hibernate)
+ [Какие ключевые интерфейсы использует Hibernate?](#какие-ключевые-интерфейсы-использует-hibernate)
+ [PROXY: что это такое, для чего и как применяется в Hibernate.](#proxy-что-это-такое-для-чего-и-как-применяется-в-hibernate)
+ [Расскажи про Hibernate кэширование (уровни кэша и что под капотом)](#расскажи-про-hibernate-кэширование-уровни-кэша-и-что-под-капотом)
+ [Как работать с кэшем второго уровня?](#как-работать-с-кэшем-второго-уровня)
+ [Что такое Persistence Context?](#что-такое-persistence-context)
+ [Что такое EntityManager?](#что-такое-entitymanager)
+ [Методы интерфейса EntityManager](#методы-интерфейса-entitymanager)
+ [Какие функции он выполняет?](#какие-функции-он-выполняет)
+ [Каким условиям должен удовлетворять класс чтобы являться Entity?](#каким-условиям-должен-удовлетворять-класс-чтобы-являться-entity)
+ [Расскажи про жизненный цикл сущности Entity, перечисли четыре статуса ЖЦ Entity объекта (Entity Instance’s Life Cycle).](#расскажи-про-жизненный-цикл-сущности-entity-перечисли-четыре-статуса-жц-entity-объекта-entity-instances-life-cycle)
+ [Как влияют операции persist, remove, merge, refresh, detach на Entity объекты каждого из четырех статусов?](#как-влияют-операции-persist-remove-merge-refresh-detach-на-entity-объекты-каждого-из-четырех-статусов)
+ [Может ли абстрактный класс быть Entity?](#может-ли-абстрактный-класс-быть-entity)
+ [Может ли Entity класс наследоваться от не Entity классов (non-entity classes)?](#может-ли-entity-класс-наследоваться-от-не-entity-классов-non-entity-classes)
+ [Может ли Entity класс наследоваться от других Entity классов?](#может-ли-entity-класс-наследоваться-от-других-entity-классов)
+ [Может ли не Entity класс наследоваться от Entity класса? ](#может-ли-не-entity-класс-наследоваться-от-entity-класса)
+ [Что такое встраиваемый (Embeddable) класс?](#что-такое-встраиваемый-embeddable-класс)
+ [Какие требования JPA устанавливает к встраиваемым (Embeddable) классам?](#какие-требования-jpa-предъявляет-к-встраиваемым-embeddable-классам)
+ [Для чего нужны аннотации @Embedded и @Embeddable?](#для-чего-нужны-аннотации-embedded-и-embeddable)
+ [Что такое Mapped Superclass?](#что-такое-mapped-superclass)
+ [Какие стратегии маппинга иерархии наследования (Inheritance Mapping Strategies) описаны в JPA?](#какие-три-стратегии-маппинга-при-наследовании-сущностей-entity-inheritance-mapping-strategies-описаны-в-jpa)
+ [Как мапятся Enum -ы?](#как-мапятся-enumы)
+ [Как мапятся даты (до Java 8 и старше)?](#как-мапятся-даты-до-java-8-и-старше)
+ [Как Hibernate работает с разными типами?](#как-hibernate-работает-с-разными-типами)
+ [Как сохранять в базе данных коллекции базовых типов?](#как-сохранять-в-базе-данных-коллекции-базовых-типов)
+ [Какие есть виды связей (маппинг ассоциаций)?](#какие-есть-виды-связей-маппинг-ассоциаций)
+ [Что такое владелец связи?](#что-такое-владелец-связи)
+ [Что такое каскады?](#что-такое-каскады)
+ [Какие два типа fetch стратегии в JPA вы знаете?](#какие-два-типа-fetch-стратегии-в-jpa-вы-знаете)
+ [Для чего нужна аннотация Basic?](#для-чего-нужна-аннотация-basic)
+ [Для чего нужна аннотация Column?](#для-чего-нужна-аннотация-column)
+ [Для чего нужна аннотация Access?](#для-чего-нужна-аннотация-access)
+ [Для чего нужна аннотация Cacheable?](#для-чего-нужна-аннотация-cacheable)
+ [Каких провайдеров кэша второго уровня знаешь?](#каких-провайдеров-кэша-второго-уровня-знаешь)
+ [Как смапить составной ключ?](#как-смапить-составной-ключ)
+ [Для чего нужна аннотация ID?](#для-чего-нужна-аннотация-id)
+ [Какие @GeneratedValue вы знаете?](#какие-generatedvalue-вы-знаете)
+ [Расскажите про аннотации @JoinColumn и @JoinTable? Где и для чего они используются?](#расскажите-про-аннотации-joincolumn-и-jointable-где-и-для-чего-они-используются)
+ [Для чего нужны аннотации @OrderBy и @OrderColumn, чем они отличаются?](#для-чего-нужны-аннотации-orderrby-и-ordercolumn-чем-они-отличаются)
+ [Для чего нужна аннотация Transient?](#для-чего-нужна-аннотация-transient)
+ [Какие шесть видов блокировок (lock) описаны в спецификации JPA (или какие есть значения у enum LockModeType в JPA)?](#какие-шесть-видов-блокировок-lock-описаны-в-спецификации-jpa-или-какие-есть-значения-у-enum-lockmodetype-в-jpa)
+ [Что такое JPQL/HQL и чем он отличается от SQL?](#что-такое-jpqlhql-и-чем-он-отличается-от-sql)
+ [Что означает полиморфизм (polymorphism) в запросах JPQL (Java Persistence query language) и как его «выключить»?](#что-означает-полиморфизм-polymorphism-в-запросах-jpql-java-persistence-query-language-и-как-его-выключить)
+ [Что такое Criteria API и для чего он используется?](#что-такое-criteria-api-и-для-чего-он-используется)
+ [В чем разница в требованиях к Entity в Hibernate, от требований к Entity, указанных в спецификации JPA?](#в-чем-разница-в-требованиях-к-entity-в-hibernate-от-требований-к-entity-указанных-в-спецификации-jpa)
+ [Расскажите про проблему N+1 Select и путях ее решения.](#расскажите-про-проблему-n1-select-и-путях-ее-решения)
+ [Что такое EntityGraph? Как и для чего их использовать?](#что-такое-entitygraph-как-и-для-чего-их-использовать)
+ [Можно ли в JDBC реализовать кэш?](#можно-ли-в-jdbc-реализовать-кэш)
+ [Какие интерфейсы, классы есть в JDBC?](#какие-интерфейсы-классы-есть-в-jdbc)
+ [Если установить стратегию генерации ключа AUTO, то какую из типов стратеги Hibernate САМ никогда не выберет и почему?](#если-установить-стратегию-генерации-ключа-auto-то-какую-из-типов-стратеги-hibernate-сам-никогда-не-выберет-и-почему)


## Что такое ORM?

Object Relational Mapping – способ сопоставления Java Объекта с записями в базе данных, объектно-реляционное сопоставление, позволяет разработчикам работать с базами данных, представляя их в виде объектов, как в объектно-ориентированном программировании.

ORM преобразует объект в строку в таблице и обратно, используя JDBC API для взаимодействия с базой данных. Наш код –> JDBC –> драйвера разработчиков БД –> БД.

[к оглавлению](#hibernate)

## Что такое JPA?

JPA – это спецификация (стандарт, технология), определяющая правила объектно-реляционного отображения простых JAVA-объектов (Plain Old Java Object - POJO) и предоставляющая универсальный API для сохранения, получения и управления такими объектами.

Сам JPA не умеет ни сохранять, ни управлять объектами, JPA только определяет правила игры: как должен действовать каждый провайдер (Hibernate, EclipseLink, OJB, Torque и т.д.), реализующий стандарт JPA. Также JPA определяет правила, как должны описываться метаданные отображения и как должны работать провайдеры.

![image](https://github.com/Oknel-Vap/Interview_questions/assets/116596752/e2101bd0-74a0-493e-a7f6-4430e2247735)

[к оглавлению](#hibernate)

## Что появилось раньше JPA или Hibernate?

На основе Hibernate (2001) появилась спецификация JPA (2006). Хибер раньше.

[к оглавлению](#hibernate)

## Что такое Hibernate?

Hibernate - это фреймворк для объектно-реляционного отображения (ORM), который предоставляет механизм для сохранения, извлечения и обработки данных из баз данных в объектно-ориентированном стиле. Сама популярный провайдер JPA. 

Главная цель – создание объектного слоя между кодом и БД, чтобы работать с таблицами, как с объектами. Скрывает от разработчика множество кода (JDBC слой), необходимого для управления ресурсами и позволяет сосредоточиться на бизнес логике. 

Hibernate предоставляет собственный мощный язык запросов (HQL), который похож на SQL. Стоит отметить, что HQL полностью объектно-ориентирован и понимает такие принципы, как наследование, полиморфизм и ассоциации (связи).

Hibernate неявно использует управление транзакциями (большинство запросов нельзя выполнить вне транзакций).

Hibernate поддерживает все основные СУБД: MySQL, Oracle, PostgreSQL, Microsoft SQL Server Database, HSQL, DB2.

[к оглавлению](#hibernate)

## Какие ключевые интерфейсы использует Hibernate?

+ Configuration interface (Интерфейс конфигурации):

Интерфейс конфигурации используется для настройки Hibernate. Он позволяет задать параметры конфигурации, такие как диалект базы данных, настройки соединения и мапинги сущностей.
+ SessionFactory interface (Интерфейс фабрики сессий):
  
Интерфейс фабрики сессий используется для создания экземпляров сессий; он читает конфигурационное hbm.xml-файл или файл метаданных аннотаций и инстанцирует сессии. Является синглтоном для приложения и потокобезопасным объектом. В процессе инициализации SessionFactory настраивает Hibernate на основе конфигурационных файлов или настроек, а также определений сущностей. Каждое соединение с базой данных обслуживается новым объектом Session, созданным с помощью SessionFactory.
+ Session interface (Интерфейс сессии):
  
Интерфейс сессии является основным интерфейсом для взаимодействия с базой данных. Он представляет одиночное соединение с базой данных, используется для управления состоянием объектов (предоставляет методы для CRUD операций), выполнения запросов к базе данных и сохранения изменений в базе данных. Сессия также отвечает за управление транзакциями и кэшированием первого уровня.
+ Transaction interface (Интерфейс транзакции):

Интерфейс транзакции контролирует транзакции базы данных. Он позволяет начать транзакцию, откатить её, подтвердить изменения и задействовать уровни изоляции транзакций.
+ Query and Criteria interfaces (Интерфейсы запросов и критериев):

Интерфейс Query предоставляет функциональность для построения HQL-запросов (Hibernate Query Language), а интерфейс Criteria используется для динамического создания запросов на основе критериев.

Query Interface (Интерфейс запросов) используется для создания объектно-ориентированных или HQL (Hibernate Query Language) запросов к базе данных. HQL предоставляет средства для написания запросов с использованием классов и свойств Java, а не непосредственно таблиц и столбцов базы данных.

Criteria Interface (Интерфейс критериев) предоставляет API для создания запросов с использованием программного кода, а не текстовых запросов. Он позволяет создавать гибкие и динамические запросы, особенно полезные, когда критерии запроса могут меняться во время выполнения программы. Criteria поддерживает создание сложных запросов, включая разбиение на страницы, сортировку, ограничения, объединение, и использование агрегатных функций.

[к оглавлению](#hibernate)

## PROXY: что это такое, для чего и как применяется в Hibernate

![image](https://github.com/Oknel-Vap/Interview_questions/assets/116596752/e5b42d79-b59b-4997-950e-3fe8b79299f6)

Proxy используется для замены реальной сущности POJO (Plain Old Java Object). Hibernate использует объекты Proxy для объектов, чтобы разрешить отложенную LAZY загрузку.

Паттерн Заместитель (Proxy) предоставляет объект-заместитель, который управляет доступом к другому объекту. То есть создается объект-суррогат, который может выступать в роли другого объекта и замещать его (перехватывать все вызовы). 

Применение PROXY позволяет отложить загрузку данных из базы данных до тех пор, пока это действительно необходимо для их использования в коде. Это может значительно улучшить производительность приложения, поскольку избегается загрузка большого объема данных, которые могут быть никогда не использованы. Кроме того, PROXY в Hibernate может использоваться для отслеживания изменений в сущности. Если изменения были внесены в PROXY объект, Hibernate может автоматически обновить соответствующую запись в базе данных при сохранении объекта.

В целом, использование PROXY в Hibernate позволяет улучшить производительность приложения, уменьшить количество запросов к базе данных и обеспечить более эффективную работу с сущностями в контексте персистентности данных.

Hibernate заружает только id сущности в прокси. 

[к оглавлению](#hibernate)

## Расскажи про Hibernate кэширование (уровни кэша и что под капотом)

1. Уровень первого уровня кэша (First-Level Cache):
   Первый уровень кэша находится непосредственно внутри сессии Hibernate (persistent context) и является частью её жизненного цикла. Каждая сессия Hibernate содержит свой собственный кэш, который хранит объекты, полученные из базы данных во время текущей сессии. При выполнении запросов Hibernate сначала ищет объекты в этом кэше, и если объект уже находится в кэше первого уровня, то он возвращается без обращения к базе данных.
   Отключить нельзя. Hibernate хранит отслеживаемые сущности в Map, ключами которой являются id сущностей, а значениями — сами объекты-сущности.

2. Уровень второго уровня кэша (Second-Level Cache):
   Кэш второго уровня является общим для всех сессий (уровень SessionFactory) и предназначен для кэширования данных, доступных из различных сессий Hibernate. Он может быть настроен с использованием различных поставщиков кэша, таких как Ehcache или Infinispan. Кэш второго уровня хранит сериализованные версии объектов или их состояние. При запросе Hibernate сначала ищет объекты в кэше первого уровня, потом второго уровня, и только если они не найдены, выполняет запрос к базе данных.

    Hibernate НЕ хранит объекты классов, а хранит информацию в виде массивов строк, чисел и т. д. И идентификатор объекта выступает указателем на эту информацию. Концептуально это нечто вроде Map, в которой id объекта — ключ, а массивы данных — значение. Приблизительно это выглядит так: ![image](https://github.com/Oknel-Vap/Interview_questions/assets/116596752/58ed9d78-bb95-4cee-8778-7f41faa518fe)

3. Уровень кэша запросов (Query Cache):
   Кэш запросов предназначен для кэширования результатов выполнения запросов. При включенном кэше запросов Hibernate сохраняет результаты выполнения запросов в кэше, используя их параметры в качестве ключей. Таким образом, если запрос с теми же параметрами выполняется снова, Hibernate возвращает результат из кэша запросов, не выполняя запрос повторно в базу данных.

В Hibernate предусмотрен кэш для запросов, и он интегрирован с кэшем второго уровня. Также необходимо его включить и указать какой запрос нужно кэшировать (используя для данного запроса метод - query.setCacheable(true))

Это требует двух дополнительных физических мест для хранения кэшированных запросов и временных меток для обновления таблицы БД. Этот вид кэширования эффективен только для часто используемых запросов с одинаковыми параметрами.

Важно: хранит результат запроса, причём ключом является сам запрос и те параметры, которые были переданы в запросе. Хитро устроен: сохраняет не объекты целиком, а их id -шники, потом по id ищет объекты в кэше второго уровня.

**Очистка кэша**

При исполнении HQL запроса Hiber удаляет из кэша все объекты того типа, который использовался в запросе. При нативном запроса (SQL) Hiber ек знает, какой именно тип объекта изменился, поэтому очищает весь кэш. Замечание: Нативные select-запросы не сбрасывают кэш, только insert, update, delete, вызовы процедур и т. п. (метод executeUpdate()).

Можно указать, какие именно сущности должны быть удалены из кэша:

<img width="718" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/b9bc7e2f-9b02-4aec-baae-bf541c2e10a8">

Либо удалить вручную через метод getCache(): 

+ session.getSessionFactory().getCache().evictQueryRegion("com.javarush.employee”);
+ session.getSessionFactory().getCache().evictEntityData("Employee”, 4); Чтобы удалить один объект из кэша, нужно передать его имя (тип) и id.

[к оглавлению](#hibernate)

## Как работать с кэшем второго уровня?

1. Сначала его включить. Для включения необходимо добавить следующие строки в конфиг файле JPA (persistence.xml):

![image](https://github.com/Oknel-Vap/Interview_questions/assets/116596752/14cedfc8-ea27-42a8-a2db-0b6e2d915100)

Hibernate сам не реализует кешированиe, поэтому подключить можно любую реализацию, которая соответствует спецификации ORM фреймворка. Из популярных реализаций можно выделить: EHCache, OSCache, SwarmCache, JBoss TreeCache. Также понадобится отдельно настроить и саму реализацию кэша. В случае с провайдером кэширования EHCache это нужно сделать в файле ehcache.xml 

2. Аннотируйте сущности, для которых вы хотите использовать кэш второго уровня, с использованием аннотации @Cache.

@Cache используется для настройки кэширования второго уровня на уровне сущности или запроса, в то время как @Cacheable указывает, что результат выполнения конкретного метода должен быть закэширован.

Зависимости класса по умолчанию также не кэшируются. Если нужно кэшировать и зависимости, то над ними также ставим аннотацию. 

В аннотации @Cache нужно указать стратегию. В Hibernate существует четыре стратегии одновременного доступа к объектам в кэше:

![image](https://github.com/Oknel-Vap/Interview_questions/assets/116596752/aa7ecb0b-c01f-45e6-b778-b7bb5238eacd)

Для работы с кэшем второго уровня (second level cache) в JPA описан Cache интерфейс, содержащий большое количество методов по управлению кэшем второго уровня (удалять все или определенные Entity из кэша, узнать закэшировалась ли сущность Entity и т.п.).

Если он поддерживается провайдером JPA, конечно. Объект данного интерфейса можно получить с помощью метода getCache() у EntityManagerFactory.

3. Запросы, которые вы хотите кэшировать, должны быть выполнены через EntityManager или Query.

Hibernate позволяет очень гибко управлять кешированием. 

<img width="802" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/8f252a54-d968-4feb-be4b-77590ec47e57">

[к оглавлению](#hibernate)

## Что такое Persistence Context?

Персистентный контекст - это набор экземпляров сущностей, загруженных из БД или только что созданных. Персистентный контекст является своего рода кэшем данных в рамках транзакции - это и есть кэш первого уровня. Внутри контекста персистентности происходит управление экземплярами сущностей и их жизненным циклом.

Persistence контекст бывает двух типов в зависимости от этапа жизненного цикла:

+ Persistence контекст области транзакции (Transaction scope persistence context)
+ Расширенный persistence контекст (Extended persistence context)

Для EntityManager, управляемого контейнером, можно выбрать тип persistence контекста. Укажите тип контекста в атрибуте type @PersistenceContext (type = PersistenceContextType.EXTENDED / TRANSACTION). Типом по умолчанию является Transaction scope. Обратите внимание, что расширенный контекст всегда используется для EntityManager, управляемого приложением (в этом случае нельзя выбирать тип контекста). Расширенный контекст одного компонента (компонент А) не знает ничего о расширенном контексте другого компонента (компонент Б).


[к оглавлению](#hibernate)

## Что такое EntityManager?

EntityManager - это интерфейс JPA, используемый для взаимодействия с персистентным контекстом. EntityManager описывает API для всех основных операций над Entity, а также для получения данных и других сущностей JPA. По сути - главный API для работы с JPA.

Один или несколько EntityManager образуют или могут образовать persistence context.

Если проводить аналогию с обычным JDBC, то EntityManagerFactory будет аналогом DataSource, а EntityManager аналогом Connection.

[к оглавлению](#hibernate)

## Методы интерфейса EntityManager

![image](https://github.com/Oknel-Vap/Interview_questions/assets/116596752/be0c84ef-a4b6-4779-bc1a-81a8cef49986)

Метод detach() - это способ отсоединить объект от контекста персистентности и избежать сохранения его изменений в базе данных. Однако сама сущность не удаляется из базы данных, а ее состояние остается в памяти и может быть повторно присоединено, используя метод merge().

Метод contains() может быть использован для проверки, находится ли сущность в контексте персистенции. Если сущность не находится в контексте персистенции, ее можно загрузить снова с помощью метода find(), или обратиться к базе данных напрямую.

[к оглавлению](#hibernate)

## Какие функции он выполняет?

Общая функция EntityManager заключается в предоставлении средств для управления объектами-сущностями приложения и их отображением в базе данных.

EntityManager в JPA (Java Persistence API) выполняет следующие функции:

+ Управление состоянием и жизненным циклом объекта: Операции над Entity: persist (добавление Entity под управление JPA), merge (изменение), remove (удаление), refresh (обновление данных), detach (удаление из-под управления контекста персистентности), lock (блокирование Entity от изменений в других thread).

+ Исполнение запросов: EntityManager позволяет выполнять запросы к базе данных, включая чтение и запись данных. Он использует язык запросов JPQL (Java Persistence Query Language), который позволяет выполнить запросы на языке Java, без зависимости от конкретной базы данных.

+ Управление транзакциями: EntityManager управляет транзакциями при работе с базой данных. Он начинает транзакцию при запросе и коммитит ее, когда все изменения были успешно применены.

+ Кэширование данных: EntityManager позволяет кэшировать данные, чтобы ускорить доступ к данным в базе данных. Он использует два типа кэширования: кэш первого уровня (EntityManager cache) и кэш второго уровня (shared cache), который хранится вне EntityManager.

+ Работа с объектами в разных средах: EntityManager позволяет работать с объектами в разных средах (например, в разных транзакциях или потоках выполнения), обеспечивая синхронизацию состояния объектов между различными средами.

+ Получение других сущностей JPA: getTransaction, getEntityManagerFactory, getCriteriaBuilder, getMetamodel, getDelegate.

+ Работа с EntityGraph: createEntityGraph, getEntityGraph.

[к оглавлению](#hibernate)

## Каким условиям должен удовлетворять класс чтобы являться Entity?

Требования к Entity классу в JPA:

![image](https://github.com/Oknel-Vap/Interview_questions/assets/116596752/d5ab17d2-980e-4aac-8e2a-530183d5e568)

![image](https://github.com/Oknel-Vap/Interview_questions/assets/116596752/3056916d-d826-4017-8bec-86da2d511ce0)

![image](https://github.com/Oknel-Vap/Interview_questions/assets/116596752/3725b480-7b68-46c2-819d-67fd6d3682d8)

[к оглавлению](#hibernate)

## Расскажи про жизненный цикл сущности Entity, перечисли четыре статуса ЖЦ Entity объекта (Entity Instance’s Life Cycle).

+ **Этап №1 New, переходное состояние (Transient State)**

Объект создан, не имеет primary key, не является частью контекста персистентности (не управляется JPA);

+ **Этап №2 Managed, постоянное состояние (Persistent State)**

Объект создан, имеет primary key, является частью контекста персистентности (управляется JPA);

+ **Этап №3 Detached, отсоединённое состояние (Detached State)**

Объект создан, имеет primary key, не является (или больше не является) частью контекста персистентности (не управляется JPA);

+ **Этап №4 Removed, состояние «удалено» (Removed State)**

Объект создан, является частью контекста персистентности (управляется JPA), будет удален при commit-е транзакции (закрытии сессии или вызове метода flush()).

[к оглавлению](#hibernate)

## Как влияют операции persist, remove, merge, refresh, detach на Entity объекты каждого из четырех статусов?

![image](https://github.com/Oknel-Vap/Interview_questions/assets/116596752/570c2759-2224-4f75-9a0c-ed17182472aa)

![image](https://github.com/Oknel-Vap/Interview_questions/assets/116596752/b918f632-d2aa-4ab2-b21a-86877a5d7432)

[к оглавлению](#hibernate)

## Может ли абстрактный класс быть Entity?

Абстрактный класс может быть Entity классом. Абстрактный Entity класс отличается от обычных Entity классов только тем, что нельзя создать объект этого класса.

Имена абстрактных классов могут использоваться в запросах. Абстрактные Entity классы используются в наследовании, когда их потомки наследуют поля абстрактного класса.

[к оглавлению](#hibernate)

## Может ли Entity класс наследоваться от не Entity классов (non-entity classes)?

Да, сущности могут наследоваться от НЕ Entity классов, которые, в свою очередь, могут быть как абстрактными, так и обычными.

Состояние (поля) НЕ Entity суперкласса НЕ является персистентным, то есть не хранится в БД и не обрабатывается провайдером (Hibernate), поэтому любое такое состояние (поля), унаследованное Entity классом, также НЕ будет отображаться в БД.

[к оглавлению](#hibernate)

## Может ли Entity класс наследоваться от других Entity классов?

Да, может.

[к оглавлению](#hibernate)

## Может ли не Entity класс наследоваться от Entity класса?

Да, может.

[к оглавлению](#hibernate)

## Что такое встраиваемый (Embeddable) класс?

Встраиваемый (Embeddable) класс - это класс, который не используется сам по себе, а только как часть одного или нескольких Entity классов. Hibernate называет эти классы компонентами. JPA называет их встраиваемыми. В любом случае, концепция одна и та же: композиция значений.

Встраиваемый класс может быть встроен в несколько классов-сущностей, но встроенный объект с конкретным состоянием принадлежит исключительно владеющей им сущности и не может использоваться одновременно другими сущностями, он не является общим для нескольких сущностей. В целом, встраиваемый класс служит для того, чтобы выносить определение общих атрибутов для нескольких сущностей, можно считать что JPA просто встраивает в сущность вместо объекта такого класса те атрибуты, которые он содержит.

экземпляры встраиваемых классов, в отличие от экземпляров сущностей, не имеют собственного персистентного состояния, вместо этого они существуют только как часть состояния объекта, которому они принадлежат; встраиваемые классы могут использоваться в качестве ключей и значений Map.

[к оглавлению](#hibernate)

## Какие требования JPA предъявляет к встраиваемым (Embeddable) классам?

+ Должны соответствовать требованиям для сущностей (раздел 2.1 Java Persistence API), за исключением того, что у встраиваемых классов не ставится аннотация @Entity и может отсутствовать первичный ключ (@Id).
+ Должны быть аннотированы @Embeddable.

[к оглавлению](#hibernate)

## Для чего нужны аннотации @Embedded и @Embeddable?

@Embeddable Аннотация JPA, размещается над классом для указания того, что класс является встраиваемым в другие классы и будет внедрен другими сущностями, то есть поля этого встраиваемого класса будут добавляться к полям других сущностей и будут представлять столбцы в таблице этой сущности.

@Embedded аннотация JPA, используется для размещения над полем в классе-сущности для указания того, что внедряется встраиваемый класс.

[к оглавлению](#hibernate)

## Что такое Mapped Superclass?

Mapped Superclass (сопоставленный суперкласс) – это класс, от которого наследуются Entity, он может содержать аннотации JPA, однако сам такой класс не является Entity, ему не обязательно выполнять все требования, установленные для Entity (например, он может не содержать первичного ключа). Эти суперклассы чаще всего используются, когда есть общая для нескольких классов сущностей информация о состоянии и отображении, которую можно вынести в Mapped Superclass.

Особенности Mapped Superclass:

+ Должен быть помечен аннотацией @MappedSuperclass или описан в xml файле.
+ Не может использоваться в операциях EntityManager или Query, вместо этого нужно использовать классы-наследники.
+ Не может состоять в отношениях с другими сущностями, т.е. в Entity нельзя создать поле с типом сопоставленного суперкласса.
+ Может быть абстрактным.
+ Не имеет своей таблицы в БД.

Основным недостатком использования сопоставленного суперкласса является то, что полиморфные запросы невозможны, то есть мы не можем загрузить всех наследников Mapped Superclass.

Аннотация @MappedSuperclass используется, когда необходимо разделить общие свойства или методы между разными сущностями, но без создания собственной таблицы для базового класса.

[к оглавлению](#hibernate)

## Какие три стратегии маппинга при наследовании сущностей (Entity Inheritance Mapping Strategies) описаны в JPA?

Стратегии наследования нужны для того, чтобы дать понять провайдеру (Hibernate) как ему отображать в БД сущности-наследники. Для этого нам нужно декорировать родительский класс аннотацией @Inheritance и указать один из типов отображения:

+ SINGLE_TABLE.

Одна таблица на всю иерархию классов. (используется по умолчанию, для определения типа используется @DiscriminatorColumn - DTYPE; хорошая поддержка полиморфизма)
+ TABLE_PER_CLASS.

Таблица для каждого конкретного класса сущностей. (использует UNION, потом по общей таблице делает выборки; не работает генерация ключа IDENTITY, плохой полиморфизм из-за union или многих SELCTов)
+ JOINED.

Стратегия «соединения», при которой поля или свойства, специфичные для подклассов, отображаются в таблицах этих подклассов, а поля или свойства родительского класса отображаются в таблице родительского класса.

Таблица подкласса не содержит столбцы для полей, унаследованных от родительского класса, за исключением поля для первичного ключа @Id, который должен быть определен только в родительской таблице (сущности, т.е id наследника = id в таблице родителя).

Столбец первичного ключа в таблице подкласса служит внешним ключом первичного ключа таблицы суперкласса. Также в таблице родительского класса добавляется столбец DiscriminatorColumn с DiscriminatorValue для определения типа наследника.

Эта стратегия обеспечивает хорошую поддержку полиморфных отношений, но требует выполнения одной или нескольких операций соединения таблиц при создании экземпляров подклассов сущностей. В глубоких иерархиях классов это может привести к недопустимому снижению производительности.

[к оглавлению](#hibernate)

## Как мапятся Enum`ы?

+ По порядковым номерам

@Enumerated(EnumType.ORDINAL) – это значение по умолчанию, говорит о том, что в базе будут храниться порядковые номера Enum (0, 1, 2…). Проблема с этим типом отображения возникает, когда нам нужно изменить наш Enum.

Если мы добавим новое значение в середину или просто изменим порядок перечисления, мы сломаем существующую модель данных. Такие проблемы могут быть трудно уловимыми, и нам придется обновлять все записи базы данных.

+ По именам

@Enumerated(EnumType.STRING) означает, что в базе будут храниться имена Enum.

Так мы можем безопасно добавлять новые значения перечисления или изменять порядок перечисления. Однако переименование значения enum все равно нарушит работу базы данных. Потребляет намного больше места, чем необходимо. 

+ @PostLoad и @PrePersist

Аннотация @PostLoad используется для выполнения каких-либо действий сущности после ее загрузки из базы данных. Например, можно установить значения для полей, которые не хранятся в базе данных. Аннотация @PrePersist используется для выполнения каких-либо действий над сущностью перед сохранением ее в базу данных. Например, можно установить дату и время создания для новой сущности.

Идея состоит в том, чтобы в Entity иметь не только поле с Enum, но и вспомогательное поле. Поле с Enum аннотируем @Transient, а в БД будет храниться значение из вспомогательного поля.  Если мы используем этот вариант, мы не сможем использовать значение Enum в запросах JPQL.

+ Converter

В JPA с версии 2.1 можно создать новый класс, который реализует интерфейс javax.persistence.AttributeConverter и аннотировать его с помощью @Converter.

Аннотация @Converter используется для конвертации значения атрибута в базу данных и из нее. То есть можно просто установить собственные правила преобразования перечислений в соответствующие значения базы данных, если использовать интерфейс AttributeConverter.

[к оглавлению](#hibernate)

## Как мапятся даты (до Java 8 и старше)?

+ java.sql (DATE, TIME, TIMESTAMP)

Использование типов java.sql для полей сущностей не всегда может быть хорошим выбором. Эти классы специфичны для JDBC и содержат множество устаревших функций. Поскольку эти типы соответствуют SQL, их сопоставление относительно простое. Можно использовать аннотацию @Basic или @Column.

+ java.util

Тип java.util.Date содержит информацию о дате и времени с точностью до миллисекунд. Но так как классы из этого пакета не имели прямого соответствия типам данных SQL, приходилось использовать над полями java.util.Date аннотацию @Temporal, чтобы дать понять SQL, с каким конкретно типом данных она работает. Для этого у аннотации @Temporal нужно было указать параметр TemporalType, который принимал одно из трёх значений: DATE, TIME или TIMESTAMP, что позволяло указать базе данных с какими конкретными типами данных она работает.

Тип java.util.Date имеет точность до миллисекунд, и недостаточно точен для обработки SQL-значения Timestamp, который имеет точность вплоть до наносекунд. Поэтому, когда мы извлекаем сущность из базы данных, неудивительно, что в этом поле мы находим экземпляр java.sql.Timestamp, даже если изначально мы сохранили java.util.Date. Но это не страшно, так как Timestamp наследуется от Date.

+ java.util.Calendar

Как и в случае java.util.Date, тип java.util.Calendar может быть сопоставлен с различными типами SQL, поэтому мы должны указать их с помощью @Temporal. Разница лишь в том, что Hibernate не поддерживает отображение (маппинг) Calendar на TIME

+ java.time

Все классы в новом API неизменяемые (immutable) и, как следствие, поток безопасные. Точность представления времени составляет одну наносекунду, что в миллион раз точнее чем в пакете java.util.

Типы данных из пакета java.time напрямую отображаются (маппятся) на соответствующие типы SQL и поэтому нет необходимости явно указывать аннотацию @Temporal:

+ LocalDate соответствует DATE.
+ LocalTime и OffsetTime соответствуют TIME.
+ Instant, LocalDateTime, OffsetDateTime и ZonedDateTime соответств. TIMESTAMP.

Это означает, что можно пометить эти поля только аннотацией @Basic (или @Column).

[к оглавлению](#hibernate)

## Как Hibernate работает с разными типами?

<img width="684" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/8b138599-52d6-465f-b386-0ba6b793c1d3">

Hibernate предоставляет возможность работы с различными типами данных в базе данных. Он автоматически обрабатывает преобразование и сопоставление типов данных между объектами Java и столбцами базы данных.

Hibernate предоставляет встроенные типы данных (базовые), такие как целые числа, строки, даты и времена и т. д., которые могут быть использованы для сопоставления стандартных типов данных Java с типами данных базы данных.

Кроме того, Hibernate предоставляет возможность создания и регистрации настраиваемых типов данных, которые представляют более сложные типы данных или особые требования. Настраиваемые типы данных могут быть реализованы путем создания классов-оберток, которые определяют, как данные должны быть преобразованы из Java в формат, понятный базе данных, и обратно.

Hibernate также предоставляет возможность использовать аннотации или файлы конфигурации для указания соответствия между типами данных Java и типами данных базы данных. Это позволяет разработчикам гибко настраивать сопоставление типов данных в зависимости от специфических требований приложения.

В Hibernate можно настроить собственные типы значений или другой их маппинг. Для этого нужно создать класс для маппинга, который имплементирует один из интерфейсов:

+ org.hibernate.type.Type / org.hibernate.type.BasicType
+ org.hibernate.usertype.UserType / org.hibernate.usertype.CompositeUserType (CompositeUserType дает нам возможность предоставить Hibernate информацию для обработки композиции в классе Money (в частности, 2 атрибута). Это даст нам возможность, например, ссылаться на атрибут amount в запросе HQL.)

После создания нужно обязательно зарегистрировать тип перед добавлением отображений:
```java
Configuration cfg = new Configuration();
cfg.registerTypeOverride( new MoneyType() );
cfg...;
```

Далее можем использовать этот тип с аннотацией @Type над полем, которое необходимо смапить:

<img width="563" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/8178595f-613c-4c1f-a034-b5498ec59f15">

[к оглавлению](#hibernate)

## Как сохранять в базе данных коллекции базовых типов?

Для этих случаев в JPA имеется специальная аннотация @ElementCollection, которая указывается в классе сущности над полем коллекции базовых или встраиваемых типов.

Все записи коллекции хранятся в отдельной таблице, то есть в итоге получаем ДВЕ таблицы:
+ одну для сущности
+ вторую для коллекции элементов

Аннотация @ElementCollection похожа на отношение @OneToMany, за исключением того, что целью являются базовые и встраиваемые типы, а не сущности.

Можно использовать аннотации @AttributeOverrides и @AttributeOverride для настройки отображения в таблице полей базовых или встраиваемых типов.

Использование коллекций элементов имеет один большой недостаток: элементы коллекции не имеют идентификатора, и Hibernate не может обращаться индивидуально к каждому элементу коллекции.

Когда нужно добавить новый объект в коллекцию или удалить из коллекции существующий элемент, Hibernate удаляет все строки из таблицы элементов и вставляет новые строки по одной для каждого элемента в коллекции.

То есть при добавлении одного элемента в коллекцию, Hibernate не добавит одну строку в таблицу коллекции, а очистит её и заполнит по новой всеми элементами.
Поэтому коллекции элементов следует использовать только для очень маленьких коллекций, чтобы Hibernate не выполнял слишком много операторов SQL. Во всех других случаях рекомендуется использовать коллекции сущностей с @OneToMany

[к оглавлению](#hibernate)

## Какие есть виды связей (маппинг ассоциаций)?

Первое слово относится к классу Entity, второе к полю в этом классе (ассоциации).

![image](https://github.com/Oknel-Vap/Interview_questions/assets/116596752/6ce3e5bd-464c-4f41-9869-9f4e03c28688)

Направления в отношениях сущностей: unidirectional и bidirectional

Однонаправленные (uni-directional associations): одна сторона знает про отношения, а другая нет. Однонаправленные отношения имеют только одного владельца связи.

Атрибут моделирует ассоциацию, а аннотация объявляет тип отношения.

Маппинг ассоциации зависит только от исходной таблицы (source table, владелец связи) и целевого объекта (target entity). Если у отдела (один) есть набор, коллекция сотрудников (много), а у сотрудника нет собственного отдела, тогда используем unidirectional @OneToMany.

В этом случае @JoinColumn должен быть в классе ВЛАДЕЛЬЦА СВЯЗИ (department). У нас это Департамент, т.к. на него ссылается внешний ключ класса Employees.

Двунаправленные (bi-directional associations): каждая сущность имеет поле, которое ссылается на другую сущность. Через это поле код первой сущности может получить доступ ко второй сущности, находящейся на другой стороне отношений.

Если у первой сущности есть поле, ссылающееся на вторую сущность, и наоборот, то в этом случае говорят, что обе сущности знают друг о друге, и что они состоят в двунаправленных отношениях.

[к оглавлению](#hibernate)

## Что такое владелец связи?

Владелец связи -  сторона связи, которая управляет состоянием связи между сущностями.  

Односторонним называется отношение, владельцем которого является только одна из двух сторон. Следует заметить, что при этом вторая сторона об этом отношении ничего не знает. Hibernate будет считать владельцем отношения ту сущность, в которой будет поставлена аннотация отношения.

У двусторонних отношений помимо стороны - владельца (owning side) имеется ещё и противоположная сторона (inverse side). Т.е. обе стороны отношения обладают информацией о связи. Чтобы Hibernate понял, что мы хотим создать именно двустороннее отношение нам нужно указать, какая из сторон является владельцем отношений, а какая является обратной стороной. Это делается при помощи атрибута mappedBy. Важно отметить, что указывается этот атрибут в аннотации, которая находится на противоположной стороне отношения.

Следует отметить, что в отношении один ко многим стороной-владельцем может быть только сторона многих (many), поэтому атрибут mappedBy есть только в аннотации @OneToMany.

[к оглавлению](#hibernate)

## Что такое каскады?

Каскады (cascades) — это механизм, который определяет, какие операции над сущностью должны автоматически распространяться на связанные с ней сущности.

Если посмотреть документацию, то CascadeType – это Enum, в котором перечисления соответствуют этапам ЖЦ Entity. JPA позволяет распространять операции с сущностями (например, persist или remove) на связанные сущности. Это означает, что при включенном каскадировании если сущность – ВЛАДЕЛЕЦ СВЯЗИ переходит в одно из своих состояний, то зависимая сущность без явных команд перейдёт в то же состояние (например, будет удалена). 

Как правило, каскадные операции применяются от владельца связи к зависимым сущностям, но они могут распространяться и в обратном направлении (хотя это совсем не нужно). Главное условие: между ними должно быть двунаправленное отношение, иначе каскадные операции выполняются только в одном направлении.

Вы можете указывать каскады в аннотации @OneToMany, @ManyToMany, @OneToOne или @ElementCollection, чтобы определить желаемое поведение каскадирования для связей.

[к оглавлению](#hibernate)

## Какие два типа fetch стратегии в JPA вы знаете?

В Java Persistence API (JPA) существует два типа стратегий загрузки (fetching strategies), которые определяют как и когда ассоциированные сущности и коллекции будут загружены из базы данных. 

![image](https://github.com/Oknel-Vap/Interview_questions/assets/116596752/b57afc5a-9a97-4a36-960d-41afa344b21e)

В FETCH.LAZY возвразается прокси.

[к оглавлению](#hibernate)

## Для чего нужна аннотация Basic?

Аннотация @Basic для поля или свойства означает, что это Basic Type* (базовый тип), и Hibernate должен использовать стандартное сопоставление для его сохранения. 

Basic — указывает на простейший тип маппинга данных на колонку таблицы базы данных. Также в параметрах аннотации можно указать fetch стратегию доступа к полю и является ли это поле обязательным или нет.

Мы должны явно использовать аннотацию @Basic , когда хотим отклониться от значений по умолчанию параметров optional (может ли в поле сущности быть null - true или нет - false, по умолчанию true) и fetch (EAGER по умолчанию). Мы можем указать один или оба этих атрибута, в зависимости от ваших потребностей.

Различия между @Basic и @Column аннотациями:

+ Атрибуты аннотации @Basic применяются к сущностям JPA, тогда как атрибуты @Column применяются к столбцам базы данных
+ @Атрибут @Basic annotations optional определяет, может ли поле сущности быть null или нет; с другой стороны, атрибут @Column annotation nullable указывает, может ли соответствующий столбец базы данных быть null
+ Мы можем использовать @Basic , чтобы указать, что поле должно быть лениво загружено
+ Аннотация @Column позволяет нам указать имя столбца сопоставленной базы данных

[к оглавлению](#hibernate)

## Для чего нужна аннотация Column?

Аннотация говорит к какому именно столбцу в таблице БД мы привязываем поле класса.

Аннотация @Column сопоставляет поле класса столбцу таблицы, а её атрибуты определяют поведение в этом столбце, используется для генерации схемы базы данных.

Атрибут nullable аннотации @Column указывает, может ли соответствующий столбец в таблице быть null.

Аннотация @Column позволяет указать имя столбца в таблице и ряд других свойств: insertable/updatable – можно ли добавлять/изменять данные в колонке (by default = true); length – длина, для строковых типов данных, по умолчанию 255 символов.

[к оглавлению](#hibernate)

## Для чего нужна аннотация Access?

Аннотация определяет тип доступа (access type) для класса entity, суперкласса, embeddable или отдельных атрибутов, то есть как JPA /Hibernate будет обращаться к атрибутам entity, как к полям класса (FIELD, по умолчанию) или как к свойствам класса (PROPERTY), имеющим гетеры (getter) и сеттеры (setter).

Аннотация Access позволяет контролировать, как Hibernate будет получать и устанавливать значения полей или свойств класса. С ее помощью можно указать, будет ли Hibernate использовать прямой доступ к полям или через методы-сеттеры и геттеры.

[к оглавлению](#hibernate)

## Для чего нужна аннотация Cacheable?

Cacheable — позволяет включить или выключить использование кэша второго уровня (second-level cache) для данного Entity (если провайдер JPA поддерживает работу с кешированием и настройки кэша (second-level cache) стоят как ENABLE_SELECTIVE или DISABLE_SELECTIVE.

Аннотация @Cacheable размещается над классом Entity. Её действие распространяется на эту сущность и её наследников, если они не определили другое поведение.

@Cache это аннотация Hibernate, настраивающая тонкости кэширования объекта в кэше второго уровня Hibernate. Аннотации @Cacheable  достаточно, чтобы объект начал кэшироваться с настройками по умолчанию. 

[к оглавлению](#hibernate)

## Каких провайдеров кэша второго уровня знаешь?

<img width="748" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/b46312ed-50a6-41b8-9381-5c100581704c">

[к оглавлению](#hibernate)

## Как смапить составной ключ?

Составной первичный ключ, также называемый составным ключом, представляет собой комбинацию из двух или более столбцов для формирования первичного ключа таблицы. В соответствии с JPA, допустимые типы атрибутов для первичного ключа:

+ примитивные типы и их обертки
+ строки
+ BigDecimal и BigInteger
+ java.util.Date и java.sql.Date

В JPA есть требования к составному ключу:

+ составной КЛЮЧ должен быть представлен классом первичного ключа, при этом используется одна из двух аннотаций: @IdClass и @EmbeddedId;
+ КЛАСС первичного ключа должен быть public и иметь public конструктор без аргументов;
+ КЛАСС первичного ключа должен имплементировать маркерный интерфейс Serializable;
+ КЛАСС первичного ключа должен иметь методы equals и hashCode;
+ АТРИБУТЫ, представляющие поля составного ключа, могут быть базовыми, составными и @ManyToOne, но НЕ могут быть коллекциями или @OneToOne.

Однако, первое правило имеется только в JPA.

@IdClass:

Создаем класс AccountId (имплементирует Serializible) с полями, которые являются частями составного ключа. Затем нужно аннотировать сущность Account аннотацией @IdClass (указать в ней AccountId.class) и объявить поля из класса AccountId в entity Account с такими же именами и аннотировать их @Id.

<img width="436" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/b8f4a260-96c6-48ea-8362-d6f6fe856fd0">

@EmbeddedId:

Является альтернативой аннотации @IdClass. Рассмотрим пример: необходимо сохранить информацию о книге с заголовком и языком в качестве полей Primary Key.

В этом случае класс первичного ключа, BookId, должен быть аннотирован @Embeddable. Затем нужно встроить этот класс в сущность Book, используя @EmbeddedId.

<img width="748" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/2a57b13a-718f-4eac-82fc-acff897d0c8c">

@IdClass v.s. @EmbeddedId

C аннотацией @IdClass пришлось указывать столбцы дважды - в AccountId и в Account. Но с @EmbeddedId мы этого не сделали;

JPQL-запросы с @IdClass проще. С @EmbeddedId, чтобы получить доступ к полю, нужно из сущности обратиться к встраиваемому классу и потом к его полю:

<img width="742" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/5fb4d340-c9b8-4c69-887c-60d2dbf4ee15">

[к оглавлению](#hibernate)

## Для чего нужна аннотация ID?

В JPA (Java Persistence API) аннотация @Id используется для обозначения поля или свойства модели данных, которое является первичным ключом для сущности (Entity) в базе данных. 

[к оглавлению](#hibernate)

## Какие @GeneratedValue вы знаете?

![image](https://github.com/Oknel-Vap/Interview_questions/assets/116596752/3170f433-47bf-4698-84d8-0912b371dcba)

В шестом гибере есть еще UUID-стратегия. https://habr.com/ru/companies/otus/articles/686136/

Начиная с JPA 3.1, есть возможность аннотировать атрибут первичного ключа с помощью @GeneratedValue и установить стратегию для GenerationType.UUID. В соответствии со спецификацией, persistence provider должен сгенерировать значение UUID на основе IETF RFC 4122. 

Как упоминалось ранее, IETF RFC 4122 определяет 4 различных стратегии создания UUID. Hibernate поддерживает две из них:

+ Стратегия по умолчанию генерирует UUID на основе случайных чисел (IETF RFC 4122, версия 4).

+ Также можно настроить генератор, который использует IP-адрес компьютера и временную отметку (IETF RFC 4122, версия 1).

Используя Hibernate 6, можно аннотировать атрибут первичного ключа с помощью @UuidGenerator и установить стиль RANDOM, AUTO или вовсе не указывать его. Во всех трех случаях Hibernate будет применять стратегию по умолчанию.

```java
    @Id
    @GeneratedValue
    @UuidGenerator
    private UUID id;
```

https://habr.com/ru/companies/haulmont/articles/653843/

[к оглавлению](#hibernate)
