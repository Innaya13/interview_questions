[Вопросы для собеседования](https://github.com/Oknel-Vap/Interview_questions/blob/main/QUESTIONS.md#interview_questions)

# Исключения

+ [Что такое исключения?](#что-такое-исключения)
+ [Опишите иерархию исключений.](#опишите-иерархию-исключений)
+ [Расскажите про обрабатываемые и необрабатываемые исключения](#расскажите-про-обрабатываемые-и-необрабатываемые-исключения)
+ [Можно ли обработать необрабатываемые исключения?](#можно-ли-обработать-необрабатываемые-исключения)
+ [Какой оператор позволяет принудительно выбросить исключение?](#какой-оператор-позволяет-принудительно-выбросить-исключение)
+ [О чем говорит ключевое слово throws?](#о-чем-говорит-ключевое-слово-throws)
+ [Как создать собственное («пользовательское») исключение?](#как-создать-собственное-пользовательское-исключение)
+ [Расскажите про механизм обработки исключений в java (Try-catch-finally)](#расскажите-про-механизм-обработки-исключений-в-java-try-catch-finally)
+ [Возможно ли использование блока try-finally (без catch)?](#возможно-ли-использование-блока-try-finally-без-catch)
+ [Может ли один блок catch отлавливать сразу несколько исключений?](#может-ли-один-блок-catch-отлавливать-сразу-несколько-исключений)
+ [Всегда ли выполняется блок finally? Существуют ли ситуации, когда блок finally не будет выполнен?](#всегда-ли-выполняется-блок-finally-существуют-ли-ситуации-когда-блок-finally-не-будет-выполнен)
+ [Может ли метод main() выбросить исключение во вне и если да, то где будет происходить обработка данного исключения?](#может-ли-метод-main-выбросить-исключение-во-вне-и-если-да-то-где-будет-происходить-обработка-данного-исключения)
+ [В каком порядке следует обрабатывать исключения в catch блоках?](#в-каком-порядке-следует-обрабатывать-исключения-в-catch-блоках)
+ [Что такое механизм try-with-resources?](#что-такое-механизм-try-with-resources)
+ [Что произойдет если исключение будет выброшено из блока catch после чего другое исключение будет выброшено из блока finally?](#что-произойдет-если-исключение-будет-выброшено-из-блока-catch-после-чего-другое-исключение-будет-выброшено-из-блока-finally)
+ [Что произойдет если исключение будет выброшено из блока catch после чего другое исключение будет выброшено из метода close() при использовании try-with-resources?](#что-произойдет-если-исключение-будет-выброшено-из-блока-catch-после-чего-другое-исключение-будет-выброшено-из-метода-close-при-использовании-try-with-resources)

## Что такое исключения?

Событие, которое встречается в ходе программы и прерывает стандартный ход её выполнения.

Исключение в Java – объект, экземпляр класса. Могут порождаться не только автоматически при возникновении исключительной ситуации, но и создаваться самим разработчиком.

Все классы исключений наследуются от Throwable (имеют свойство – возможность быть брошенными через слово throw).

[к оглавлению](#исключения)

## Опишите иерархию исключений

![image](https://github.com/Oknel-Vap/Interview_questions/assets/116596752/e1d20ff6-b5f8-40e7-8ac8-51e01be50744)

Исключения делятся на несколько классов, но все они имеют общего предка — класс Throwable, потомками которого являются классы Exception и Error.

Error ошибки виртуальной машины.

StackOverflowError — возникает, например, когда метод бесконечно вызывает сам себя OutOfMemoryError — возникает, когда недостаточно памяти для создания новых объектов. NoClassDefFoundError – не смог найти класс Error — это критическая ошибка во время исполнения программы, связанная с работой виртуальной машины Java.

В большинстве случаев Error не нужно обрабатывать, поскольку она свидетельствует о каких-то серьезных недоработках в коде.

Исключения (Exceptions) являются результатом проблем в программе, которые в принципе решаемые и предсказуемые. Они могут быть отслежены / видны компилятором.

Например, произошло деление на ноль в целых числах. RuntimeExceptions исключения, которые могут быть предотвращены программно (программист сам пишет проверку, т.е. не ловит нет throw).

IOException — ошибка при вводе-выводе данных (Input-Output).

**RuntimeExceptions:**

+ ArithmeticException: исключение, возникающее при делении на ноль
+ IndexOutOfBoundException: тип индекса вышел за допустимые пределы
+ IllegalArgumentException: использование неверного аргумента при вызове метода
+ NullPointerException: использование пустой ссылки
+ NumberFormatException: ошибка преобразования строки в число
+ ArrayIndexOutOfBoundsException: выход за пределы массива

**В Java все исключения делятся на два типа:**

+ checked (контролируемые/проверяемые исключения) должны обрабатываться блоком catch или описываться в сигнатуре метода (например, throws IOException).Наличие такого обработчика/модификатора сигнатуры проверяются на этапе компиляции. Если ни один из методов в иерархии вызовов не обрабатывает исключение, оно может достичь корневого метода (main() в Java) и, если исключение не будет обработано, программа завершится с сообщением об ошибке.
+ unchecked (неконтролируемые/непроверяемые исключения), к которым относятся ошибки Error(например, OutOfMemoryError), обрабатывать которые не рекомендуется и исключения в рантайме (ао время выполнения), представленные классом RuntimeException и его наследниками (например, NullPointerException), которые могут не обрабатываться блоком catch и не быть описанными в сигнатуре метода. FileNotFoundException – не нашел файл для открытия; FileSystemException (AccessDeniedException(разрешение), SocketException (BindException (ошибка связи сокета), ConnectException (отказ соединения)

[к оглавлению](#исключения)

## Расскажите про обрабатываемые и необрабатываемые исключения

Checked исключения, это те, которые должны обрабатываться блоком catch или писываться в сигнатуре метода.

Unchecked могут не обрабатываться и не быть описанными.

Unchecked исключения в Java — наследованные от RuntimeException, checked — от Exception.

Checked исключения отличаются от Unchecked исключения в Java, тем что наличие\обработка Checked исключения проверяются компилятором на этапе компиляции.

Наличие\обработка Unchecked исключения происходит на этапе выполнения.

[к оглавлению](#исключения)

## Можно ли обработать необрабатываемые исключения?

Можно, но не надо.

В Java все исключения делятся на два типа:

+ checked (контролируемые/проверяемые исключения) должны обрабатываться блоком catch или описываться в заголовке метода (например, throws IOException). Наличие такого обработчика/модификатора в заголовке метода проверяется на этапе компиляции;
+ unchecked (неконтролируемые/непроверяемые исключения), к которым относятся ошибки Error (например, OutOfMemoryError), обрабатывать которые не рекомендуется и исключения времени выполнения, представленные классом RuntimeException и его наследниками (например, NullPointerException), которые могут не обрабатываться блоком catch и не быть описанными в заголовке метода.

В Java нельзя явно обработать необрабатываемые исключения. Необрабатываемые исключения (также называемые unchecked exceptions) — это исключения, которые не требуют быть объявленными в сигнатуре метода или обрабатываться с помощью конструкции try-catch.

Эти исключения возникают в случаях, когда происходит критическая ошибка выполнения программы, например, деление на ноль или обращение к несуществующему объекту. Обычно такие исключения свидетельствуют о нарушении логики программы или ошибке программиста.

Лучшей практикой является предотвращение возникновения необрабатываемых исключений путем правильной обработки возможных ошибок, использования валидации входных данных и написания качественного кода.

Если возникло исключение, которое является необрабатываемым, и вы все равно хотите его обработать, можно использовать конструкцию try-catch для перехвата исключения и выполнения некоторых действий. Но это не рекомендуется, так как это может привести к нестабильности программы и к скрытию ошибок, которые требуют исправления.

[к оглавлению](#исключения)

## Какой оператор позволяет принудительно выбросить исключение?

Это оператор throw:
```
throw new Exception();
```
[к оглавлению](#исключения)

## О чем говорит ключевое слово throws?

Модификатор throws прописывается в сигнатуре метода и указывает на то, что метод потенциально может выбросить исключение с указанным типом

[к оглавлению](#исключения)

## Как создать собственное (пользовательское) исключение?

Необходимо унаследоваться от базового класса требуемого типа исключений (например от Exception или RuntimeException).

[к оглавлению](#исключения)

## Расскажите про механизм обработки исключений в Java (Try-catch-finally)

try — данное ключевое слово используется для отметки начала блока кода, который потенциально может привести к ошибке.

catch — ключевое слово для отметки начала блока кода, предназначенного для перехвата и обработки исключений в случае их возникновения.

finally — ключевое слово для отметки начала блока кода, который является дополнительным. Этот блок помещается после последнего блока catch. Управление передаётся в блок finally в любом случае, было выброшено исключение или нет.

Общий вид конструкции для обработки исключительной ситуации выглядит следующим образом:
```
try { //код, который потенциально может привести к исключительной ситуации }

catch(SomeException e ) { //в скобках указывается класс конкретной ожидаемой ошибки 

//код обработки исключительной ситуации} 

finally { //необязательный блок, код которого выполняется в любом случае}
```
[к оглавлению](#исключения)

## Возможно ли использование блока try-finally (без catch)?

Да, в Java возможно использование блока try-finally без catch.

try-finally блок используется для выполнения кода, который должен быть выполнен в любом случае, независимо от исключений и ошибок, возникающих внутри try-блока.

Основные причины использования блока try-finally без catch:

Организация очистки и освобождения ресурсов: блок finally позволяет гарантировать, что некоторый код будет выполнен в любом случае, независимо от возникновения исключений. Например, закрытие открытых файлов или соединений с базами данных.
Обработка и перевыброс исключений: если внутри try-блока возникнет исключение, оно может быть перехвачено и обработано в блоке finally, и затем повторно брошено, чтобы его обработали в другом месте программы.
Выполнение завершающих действий: блок finally может содержать код, который должен быть выполнен в любом случае перед выходом из метода или перед завершением программы.
Ниже приведен пример использования блока try-finally без catch:
```
try {
    // Код, который может вызывать исключение
} finally {
    // Код, который должен быть выполнен в любом случае
}
```
В этом примере блок finally будет выполнен, независимо от того, возникло исключение или нет внутри блока try.

Да, в Java можно перехватить исключение в блоке `finally` и повторно бросить его для обработки в другом месте программы. Вот пример:

```java
public class Main {
    public static void main(String[] args) {
        try {
            doSomething();
        } catch (Exception e) {
            System.out.println("Перехвачено исключение: " + e.getMessage());
        }
    }

    public static void doSomething() throws Exception {
        try {
            // Некоторый код, который может вызвать исключение
            throw new Exception("Исключение внутри try-блока");
        } finally {
            // Блок finally будет выполнен независимо от того, возникло исключение или нет
            System.out.println("Блок finally выполнен");
            // Повторное бросание исключения
            throw new Exception("Исключение внутри finally-блока");
        }
    }
}
```

В этом примере метод `doSomething()` выбрасывает исключение внутри блока `try`, а затем в блоке `finally` выбрасывается другое исключение. В методе `main()` исключение перехватывается в блоке `catch` и выводится сообщение. Таким образом, исключение было перехвачено и обработано в блоке `finally`, а затем повторно брошено и обработано в блоке `catch` в другом месте программы.

Результат выполнения данного кода будет следующим:

```
Блок finally выполнен
Перехвачено исключение: Исключение внутри finally-блока
```

Обратите внимание, что при повторном бросании исключения из блока `finally` исходное исключение, возникшее в блоке `try`, будет потеряно. Поэтому важно внимательно обрабатывать исключения и принимать решение о перебрасывании только в случаях, когда это действительно необходимо.

[к оглавлению](#исключения)

## Может ли один блок catch отлавливать сразу несколько исключений?

Да, в Java блок catch может отлавливать сразу несколько исключений. Для этого используется следующий синтаксис:
```
try {
    // код, при выполнении которого может возникнуть исключение
} catch (ExceptionType1 | ExceptionType2 | ... | ExceptionTypeN exception) {
    // код для обработки исключений типов ExceptionType1, ExceptionType2, ..., ExceptionTypeN
}
```
В данном примере блок catch может обрабатывать одновременно исключения типов ExceptionType1, ExceptionType2, ..., ExceptionTypeN. Каждый тип исключения разделяется символом |. Если произошло исключение определенного типа, то будет выполнен соответствующий блок кода внутри блока catch.

Да, в Java блок `catch` может отлавливать сразу несколько исключений. Для этого можно указать несколько типов исключений через разделитель `|` (вертикальная черта). Вот пример:

```java
try {
    // Код, который может вызвать исключения
} catch (IOException | SQLException e) {
    // Обработка исключений IOException и SQLException
}
```

В этом примере блок `catch` отлавливает как исключения типа `IOException`, так и исключения типа `SQLException`. Если возникнет любое из этих исключений, то будет выполнен соответствующий блок `catch`.

Что касается указания исключений, то лучше всего указывать конкретные типы исключений, которые вы ожидаете обработать или которые требуют специальной обработки. Это поможет сделать код более понятным и предсказуемым. Если вы указываете более общий тип исключения, такой как `Exception`, то это может затруднить отладку и усложнить обработку конкретных исключений.

Если вам нужно обработать разные типы исключений по-разному, то рекомендуется использовать отдельные блоки `catch` для каждого типа исключения. Это позволит вам предоставить специфическую обработку для каждого исключения и лучше контролировать поведение программы при возникновении ошибок.

Вот пример:

```java
try {
    // Код, который может вызвать исключения
} catch (IOException e) {
    // Обработка исключения IOException
} catch (SQLException e) {
    // Обработка исключения SQLException
}
```

В этом примере блок `catch` обрабатывает исключение `IOException` отдельно от исключения `SQLException`, что позволяет предоставить различную логику обработки для каждого типа исключения.

[к оглавлению](#исключения)

## Всегда ли выполняется блок finally? Существуют ли ситуации, когда блок finally не будет выполнен?

+ Когда System.exit(0) вызывается из блока try. 
+ Когда JVM исчерпывает память catch (OutOfMemoryError oome) { // do stuff }
+ Когда ваш Java-процесс принудительно убит из задачи или консоли 
+ Условие взаимоблокировки потоков в блоке try 
+ Когда ваш компьютер отключается из-за сбоя питания

В основном, блок `finally` выполняется всегда, но есть несколько ситуаций, когда он может не быть выполнен:

1. Если в блоке `try` происходит безусловное завершение выполнения программы или потока, например, вызывается метод `System.exit()`, который принудительно завершает выполнение программы, или происходит необрабатываемое исключение типа `Error`, которое приводит к аварийному завершению программы.

2. Если в блоке `try` происходит бесконечный цикл, который не завершается, например, из-за условия, которое всегда остается истинным.

3. Если в блоке `try` возникает исключение типа `ThreadDeath`, которое может быть выброшено при прерывании потока с помощью метода `Thread.stop()` (этот метод считается устаревшим и не рекомендуется использовать).

4. Если в блоке `try` происходит сбой в работе JVM или другой серьезный сбой, который приводит к аварийному завершению программы.

В этих случаях выполнение программы или потока прерывается без выполнения блока `finally`. В остальных случаях блок `finally` будет выполнен независимо от того, произошло исключение в блоке `try` или нет. Блок `finally` обычно используется для освобождения ресурсов, таких как закрытие файловых дескрипторов или сетевых соединений, независимо от того, произошло исключение или нет.

[к оглавлению](#исключения)

## Может ли метод main() выбросить исключение во вне и если да, то где будет происходить обработка данного исключения?

Да, метод main() может выбросить исключение во вне, но в этом случае исключение должно быть обработано в коде, вызывающем метод main().

Если исключение не обработано в самом методе main(), оно будет передано обработчику исключений, определенному в JVM (Java Virtual Machine). Обработчик исключений записывает информацию об исключении в журналы и печатает трассировку стека.

Таким образом, если исключение выброшено из метода main(), оно будет передано JVM для обработки. Дополнительно, вы можете определить собственный обработчик исключений, используя конструкцию try-catch в методе main() для локальной обработки исключений.

Вот пример обработки исключения, выброшенного из метода `main()`:

```java
public class Main {
    public static void main(String[] args) {
        try {
            // Вызов метода, который может выбросить исключение
            doSomething();
        } catch (Exception e) {
            // Обработка исключения
            System.err.println("Произошло исключение: " + e.getMessage());
        }
    }

    public static void doSomething() throws Exception {
        // Некоторый код, который может выбросить исключение
        throw new Exception("Ошибка!");
    }
}
```

В этом примере метод `doSomething()` выбрасывает исключение типа `Exception`. В методе `main()` мы вызываем `doSomething()` и помещаем этот вызов в блок `try-catch`. Если исключение выбрасывается из `doSomething()`, оно будет перехвачено блоком `catch` и обработано. В данном примере мы просто выводим сообщение об ошибке в стандартный поток ошибок (`System.err`), но вы можете выполнить любую другую логику обработки исключения в блоке `catch`.

Обратите внимание, что в примере явно указано, что метод `doSomething()` выбрасывает исключение с помощью ключевого слова `throws`. Это необходимо для того, чтобы компилятор знал о возможности выброса исключения из метода и чтобы мы могли обработать его в блоке `try-catch` в методе `main()`.

[к оглавлению](#исключения)

## В каком порядке следует обрабатывать исключения в catch блоках?

Общее правило: обрабатывать исключения нужно от «младшего» к старшему. Т.е. нельзя поставить в первый блок catch(Exception ex) {}, иначе все дальнейшие блоки catch() уже ничего не смогут обработать, т.к. любое исключение будет соответствовать обработчику catch(Exception ex).

[к оглавлению](#исключения)

## Что такое механизм try-with-resources?

Данная конструкция, которая появилась в Java 7, позволяет использовать блок try-catch не заботясь о закрытии ресурсов, используемых в данном сегменте кода. Ресурсы объявляются в скобках сразу после try, а компилятор уже сам неявно создаёт секцию finally, в которой и происходит освобождение занятых в блоке ресурсов. Под ресурсами подразумеваются сущности, реализующие интерфейс java.lang.Autocloseable.

Общий вид конструкции:
```
try(/*объявление ресурсов*/) {
    //...
} catch(Exception ex) {
    //...
} finally {
    //...
}
```
Стоит заметить, что блоки catch и явный finally выполняются уже после того, как закрываются ресурсы в неявном finally.

[к оглавлению](#исключения)

## Что произойдет если исключение будет выброшено из блока catch после чего другое исключение будет выброшено из блока finally?

Из файнали подавит из кэтч будет обработано в finally блоке.

Если было выброшено два исключения – одно в try, второе в finally, то исключение в finally “проглотит” исключение выше (см. пример).

Если до блока finally исключение было обработано, то мы можем получить информацию об исключении в блоке try и тем самым не потерять исключение, которое впоследствии может быть перезаписано в finally другим исключением

При возникновении исключения в блоке `try` сначала выполняется код в блоке `finally`, а затем обработка переходит в блок `catch` (если есть соответствующий обработчик для данного исключения). 

Блок `finally` предназначен для выполнения кода, который должен быть выполнен независимо от того, возникло исключение или нет. Например, в блоке `finally` может быть код для освобождения ресурсов или закрытия открытых соединений.

Если исключение будет выброшено из блока `catch`, а затем другое исключение будет выброшено из блока `finally`, то исключение из блока `finally` будет перехвачено и станет "главным" исключением. Исключение из блока `catch` будет потеряно и не будет доступно для дальнейшей обработки.

В Java, если в блоке `finally` выбрасывается исключение, оно замещает любое исключение, которое могло быть выброшено в блоке `try` или `catch`. Это означает, что исключение из блока `finally` будет передано дальше для обработки или перехвата.

Пример:

```java
try {
    // Код, который может выбросить исключение
    throw new Exception("Исключение из блока try");
} catch (Exception e) {
    // Перехватываем исключение из блока try
    System.out.println("Перехвачено исключение: " + e.getMessage());
    throw new Exception("Исключение из блока catch");
} finally {
    // Выбрасываем исключение из блока finally
    throw new Exception("Исключение из блока finally");
}
```

В этом примере исключение "Исключение из блока finally" будет передано дальше для обработки или перехвата, а исключение "Исключение из блока catch" будет потеряно.

Важно отметить, что при выбрасывании исключения из блока `finally` оригинальное исключение, которое могло быть выброшено в блоке `try` или `catch`, будет подавлено. Если вам нужно сохранить информацию об этом оригинальном исключении, вы можете вызвать метод `addSuppressed()` на выброшенном исключении из блока `finally`, чтобы добавить оригинальное исключение в список подавленных исключений.

[к оглавлению](#исключения)

## Что произойдет если исключение будет выброшено из блока catch после чего другое исключение будет выброшено из метода close() при использовании try-with-resources?

Если исключение будет выброшено в основном коде и в методе close(), то приоритетнее будет первое исключение, а второе исключение будет подавлено, но информация о нем сохранится (с помощью метода Throwable.addSuppressed(Throwable exception), который вызывается неявно Java компилятором)

Если исключение будет выброшено из блока catch после чего другое исключение будет выброшено из метода close() при использовании try-with-resources, то исключение, выброшенное из метода close(), будет добавлено в список подавленных исключений и будет доступно через метод getSuppressed() исключения, выброшенного из блока catch.

[к оглавлению](#исключения)
