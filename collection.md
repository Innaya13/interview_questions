# Коллекции

+ [Что такое «коллекция»?](#что-такое-коллекция)
+ [Расскажите про иерархию коллекций](#расскажите-про-иерархию-коллекций)
+ [Почему Map — это не Collection, в то время как List и Set являются Collection?](#почему-map-это-не-collection-в-то-время-как-list-и-set-являются-collection)
+ [В чем разница между классами java.util.Collection и java.util.Collections?](#в-чем-разница-между-классами-javautilcollection-и-javautilcollections)
+ [Какая разница между итераторами с fail-fast и fail-safe поведением? (с примерами)](#какая-разница-между-итераторами-с-fail-fast-и-fail-safe-поведением-с-примерами)
+ [Каким будет результат выполнения данного кода?](#какая-разница-между-итераторами-с-fail-fast-и-fail-safe-поведением-с-примерами)
+ [Чем различаются Enumeration и Iterator?](#чем-различаются-enumeration-устаревший-и-iterator)
+ [Как избежать ConcurrentModificationException во время перебора коллекции?](#как-избежать-concurrentmodificationexception-во-время-перебора-коллекции)
+ [Как между собой связаны Iterable, Iterator и «for-each»?](#как-между-собой-связаны-iterable-iterator-и-for-each)
+ [Можно ли, обходя ArrayList, удалить элемент? Какое вылетит исключение?](#можно-ли-итерируясь-по-arraylist-удалить-элемент-какое-вылетит-исключение)
+ [Как удалить элемент из ArrayList при итерации?](#как-удалить-элемент-из-arraylist-при-итерации)
+ [Как поведёт себя коллекция, если вызвать iterator.remove()?](#как-поведёт-себя-коллекция-если-вызвать-iteratorremove)
+ [Чем Set отличается от List?](#чем-set-отличается-от-list)
+ [Расскажите про интерфейс Set.](#расскажите-про-интерфейс-set)
+ [Расскажите про реализации интерфейса Set](#расскажите-про-реализации-интерфейса-set)
+ [Зачем нужны и чем отличаются интерфейсы Comparable и Comparator?](#зачем-нужны-и-чем-отличаются-интерфейсы-comparable-и-comparator)
+ [В чем отличия TreeSet и HashSet?](#в-чем-отличия-treeset-и-hashset)
+ [Чем LinkedHashSet отличается от HashSet?](#чем-linkedhashset-отличается-от-hashset)
+ [Что будет, если добавлять элементы в TreeSet по возрастанию?](#что-будет-если-добавлять-элементы-в-treeset-по-возрастанию)
+ [Что будет в этом случае?](#что-будет-в-этом-случае)
+ [Как устроен HashSet, сложность основных операций](#как-устроен-hashset-сложность-основных-операций)
+ [Как устроен LinkedHashSet, сложность основных операций](#как-устроен-linkedhashset-сложность-основных-операций)
+ [Как устроен TreeSet, сложность основных операций](#как-устроен-treeset-сложность-основных-операций)
+ [Расскажите про интерфейс List](#расскажите-про-интерфейс-List)
+ [Как устроен ArrayList, сложность основных операций](#как-устроен-arraylist-сложность-основных-операций)
+ [Как устроен LinkedList, сложность основных операций](#как-устроен-linkedlist-сложность-основных-операций)
+ [Почему LinkedList реализует и List, и Deque?](#почему-linkedlist-реализует-и-list-и-deque)
+ [Чем отличаются ArrayList и LinkedList?](#чем-отличаются-arraylist-и-linkedlist)
+ [Что такое Queue?](#что-такое-queue)
+ [Что такое Deque? Чем отличается от Queue?](#что-такое-dequeue-чем-отличается-от-queue)
+ [Приведите пример реализации Deque](#приведите-пример-реализации-dequeue)
+ [Какая коллекция реализует FIFO?](#какая-коллекция-реализует-fifo)
+ [Какая коллекция реализует LIFO?](#какая-коллекция-реализует-lifo)
+ [Оцените количество памяти на хранение одного примитива типа byte в LinkedList?](#оцените-количество-памяти-на-хранение-одного-примитива-типа-byte-в-linkedlist)
+ [Оцените количество памяти на хранение одного примитива типа byte в ArrayList?](#оцените-количество-памяти-на-хранение-одного-примитива-типа-byte-в-arraylist)
+ [Как устроена HashMap? (Расскажите про принцип корзин)](#как-устроена-hashmap-сложность-основных-операций-расскажите-про-принцип-корзин)
+ [Что такое бинарное дерево?](#что-такое-бинарное-дерево)
+ [Когда и как происходит перестроение мапы в дерево?](#когда-и-как-происходит-перестроение-мапы-в-дерево)
+ [Каковы особенности красно-чёрного дерева?](#каковы-особенности-красно-чёрного-дерева)
+ [Сложность основных операций HashMap?](#сложность-основных-операций-hashmap)
+ [Что такое LinkedHashMap? LinkedHashMap - что в нем от LinkedList, а что от HashMap?](#что-такое-linkedhashmap)
+ [Как устроена TreeMap, сложность основных операций?](#как-устроена-treemap-сложность-основных-операций)
+ [Что такое WeakHashMap?](#что-такое-weakhashmap)
+ [В чем разница между HashMap и WeakHashMap? Для чего используется WeakHashMap?](#в-чем-разница-между-hashmap-и-weakhashmap-для-чего-используется-weakhashmap)
+ [Как работает HashMap при попытке сохранить в него два элемента по ключам с одинаковым hashCode(), но для которых equals() == false?](#как-работает-hashmap-при-попытке-сохранить-в-него-два-элемента-по-ключам-с-одинаковым-hashcode-но-для-которых-equals--false)
+ [Что будет, если мы кладем в HashMap ключ, у которого equals и hashCode определены некорректно?](#что-будет-если-мы-кладем-в-hashmap-ключ-у-которого-equals-и-hashcode-определены-некорректно)
+ [Возможна ли ситуация, когда HashMap выродится в список даже с ключами имеющими разные hashCode()?](#возможна-ли-ситуация-когда-hashmap-выродится-в-список-даже-с-ключами-имеющими-разные-hashcode)
+ [Почему нельзя использовать byte[] в качестве ключа в HashMap?](#почему-нельзя-использовать-byte-в-качестве-ключа-в-hashmap)
+ [Будет ли работать HashMap, если все добавляемые ключи будут иметь одинаковый hashCode()?](#будет-ли-работать-hashmap-если-все-добавляемые-ключи-будут-иметь-одинаковый-hashcode)
+ [Какое худшее время работы метода get(key) для ключа, которого НЕТ в HashMap?](#какое-худшее-время-работы-метода-getkey-для-ключа-которого-нет-который-есть-в-hashmap)
+ [Какое худшее время работы метода get(key) для ключа, который ЕСТЬ в HashMap?](#какое-худшее-время-работы-метода-getkey-для-ключа-которого-нет-который-есть-в-hashmap)

## Что такое коллекция?

«Коллекция» - это структура данных, набор каких-либо объектов.

Данными (объектами в наборе) могут быть числа, строки, объекты пользовательских классов и т.п.

Коллекции (java) – набор классов и интерфейсов, предназначенных для хранения данных. Каждый класс имеет свою специфику хранения объектов. Классы коллекций являются дженерик-параметрами.

В Java коллекции - это контейнеры, которые используются для хранения, управления и манипулирования группами объектов. Коллекции предоставляют различные структуры данных, такие как списки, множества, отображения и очереди, позволяя легко добавлять, удалять и искать элементы.

Коллекции в Java представлены в виде классов и интерфейсов. Классы представляют конкретные реализации коллекций (например, ArrayList, HashSet, HashMap), а интерфейсы определяют общие методы и функциональность, которые должны быть реализованы классами коллекций (например, List, Set, Map).

Коллекции в Java также могут использовать дженерики для обеспечения типовой безопасности. Дженерики позволяют указать тип данных, которые будут храниться в коллекции, чтобы предотвратить ошибки типизации во время компиляции. Например, вы можете создать список List<String>, который будет содержать только строки, или Set<Integer>, который будет содержать только целые числа.

Коллекции в Java предоставляют удобные и эффективные способы работы с группами объектов, что делает их важным компонентом в разработке Java-приложений.

Для хранения наборов данных в Java предназначены массивы. Однако их не всегда удобно использовать, прежде всего потому, что они имеют фиксированную длину. Кроме того, у массивов нет никакой защиты от изменений.
Эту проблему в Java решают коллекции.
Коллекции – это "контейнер" или группа, т.е. совокупность объектов, которые мы храним вместе. Или так: коллекции — это наборы однородных элементов (например, страницы в книге, яблоки в корзине или люди в очереди).

Инструменты для работы с такими структурами в Java содержатся в Java Collections Framework, классы коллекций располагаются в пакете java.util

Классы коллекций являются дженериками и параметризируются типом хранимых внутри элементов. В качестве значения дженерик параметра может использоваться только ссылочный тип, поэтому все коллекции в java работают со ссылочными типами.

Если нужно хранить примитивы, то их можно превратить в объекты при помощи классов-обёрток.
А еще есть специализированные коллекции для многопоточного использования (java.util.concurrent).

<img width="463" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/3034d6ee-29c8-44f4-9fd9-e653a574785a">

[к оглавлению](#коллекции)

## Расскажите про иерархию коллекций

![image](https://github.com/Oknel-Vap/Interview_questions/assets/116596752/5b500d48-1e60-41ed-ae6c-12c475fb48ca)

Интерфейс Collection расширяют интерфейсы:

List (список) представляет собой коллекцию, в которой допустимы дублирующие значения. Элементы такой коллекции пронумерованы, начиная от нуля, к ним можно обратиться по индексу.

Реализации:

+ ArrayList - инкапсулирует в себе обычный массив, длина которого автоматически увеличивается при добавлении новых элементов.
+ LinkedList (двунаправленный связный список) - состоит из узлов, каждый из которых содержит как собственно данные, так и две ссылки на следующий и предыдущий узел.
+ Vector — реализация динамического массива объектов, методы которой синхронизированы (доступны по очереди, т.е. может использовать кто-то один).
+ Stack — реализация стека LIFO (last-in-first-out).

Set (сет) описывает неупорядоченную коллекцию, не содержащую повторяющихся элементов.

Реализации:

+ HashSet - использует HashMap для хранения данных. В качестве ключа используется добавляемый элемент, а в качестве значения — объект-пустышка (new Object()). Из-за особенностей реализации порядок элементов не гарантируется при добавлении.
+ LinkedHashSet — гарантирует, что порядок элементов при обходе коллекции будет идентичен порядку добавления элементов.
+ (SortedSet) TreeSet — предоставляет возможность управлять порядком элементов в коллекции при помощи объекта Comparator, либо сохраняет элементы с использованием «natural ordering».

Queue (очередь) предназначена для хранения элементов с предопределённым способом вставки и извлечения FIFO (first-in-first-out):

+ PriorityQueue — предоставляет возможность управлять порядком элементов в коллекции при помощи объекта Comparator, либо сохраняет элементы с использованием «natural ordering».
+ ArrayDeque — реализация интерфейса Deque, который расширяет интерфейс Queue методами, позволяющими реализовать конструкцию вида LIFO (last-in-first-out).

![image](https://github.com/Oknel-Vap/Interview_questions/assets/116596752/140037ff-f180-46a7-9b4b-e0d26129251c)

Интерфейс Map реализован классами:

+ Hashtable — хэш-таблица, методы которой синхронизированы. Не позволяет использовать null в качестве значения или ключа и не является упорядоченной.
+ HashMap — хэш-таблица. Позволяет использовать null в качестве значения или ключа и не является упорядоченной.
+ LinkedHashMap — упорядоченная реализация хэш-таблицы.
+ TreeMap — реализация, основанная на красно-чёрных деревьях. Является упорядоченной и предоставляет возможность управлять порядком элементов в коллекции при помощи объекта Comparator, либо сохраняет элементы с использованием «natural ordering».
+ WeakHashMap — реализация хэш-таблицы, которая организована с использованием weak references для ключей (сборщик мусора автоматически удалит элемент из коллекции при следующей сборке мусора, если на ключ этого элемента нет жёстких ссылок).

[к оглавлению](#коллекции)

## Почему Map это не Collection, в то время как List и Set являются Collection?

"Потому что они несовместимы". В интерфейсе Collection описан метод add(Object o). Также, Map имеют методы keySet, valueSet, которых нет в Collections.

Collection представляет собой совокупность некоторых элементов. Map - это совокупность пар «ключ-значение».

Интерфейс Map<K, V> представляет отображение или, иначе говоря, словарь, где каждый элемент представляет пару "ключ-значение" (НЕ явл. наследником Collection).

Такие коллекции облегчают поиск элемента, если нам известен ключ - уникальный идентификатор объекта.

Коллекция (List и Set) представляет собой совокупность некоторых элементов (обычно экземпляров одного класса).

Map — это совокупность пар "ключ" - "значение". Соответственно некоторые методы интерфейса Collection нельзя использовать в Map.

Например, метод remove(Object o) в интерфейсе Collection предназначен для удаления элемента, тогда как такой же метод remove(Object key) в интерфейсе Map - удаляет элемент по заданному ключу.

[к оглавлению](#коллекции)

## В чем разница между классами java.util.Collection и java.util.Collections?

Collections - набор статических методов для работы с коллекциями.

Collection - один из основных интерфейсов Java Collections Framework.

java.util.CollectionS – это клаСС, набор статических методов для работы с коллекциями.
Этот класс состоит исключительно из статических методов, которые работают с коллекциями или возвращают их. Он содержит полиморфные алгоритмы, которые работают с коллекциями, «обертки», которые возвращают новую коллекцию, поддерживаемую указанной коллекцией, и несколько других случаев.

Все методы этого класса вызывают исключение NullPointerException, если предоставленные им коллекции или объекты класса имеют значение null.

java.util.Collection – один из основных интерфейсов Java Collections Framework.
public interface Collection<E> extends Iterable<E> это корневой интерфейс в иерархии коллекций. JDK не предоставляет каких-либо прямых реализаций этого интерфейса: он предоставляет реализации более конкретных под-интерфейсов, таких как Set и List.

Этот интерфейс обычно используется для передачи коллекций и управления ими там, где требуется максимальная универсальность.

Справка: Все классы реализации Collection общего назначения (которые обычно реализуют Collection косвенно через один из его под-интерфейсов) должны предоставлять два «стандартных» конструктора:
+ конструктор void (без аргументов), который создает пустую коллекцию
+ и конструктор с одним аргументом типа Коллекция, которая создает новую коллекцию с теми же элементами, что и ее аргумент.

Класс java.util.Collection является интерфейсом, который представляет собой общий контракт для всех типов коллекций в Java. Он определяет основные методы для работы с коллекциями, такие как добавление элементов, удаление, доступ и другие операции.

Класс java.util.Collections, напротив, является утилитарным классом, предоставляющим набор статических методов для работы и манипулирования различными типами коллекций. Он предлагает методы для сортировки, перетасовки, поиска минимального и максимального элементов, создания неизменяемых коллекций и других операций над коллекциями.

Таким образом, класс Collection определяет общие методы для работы с коллекциями, а класс Collections предоставляет утилиты для работы с конкретными коллекциями, в том числе и с теми, которые реализуют интерфейс Collection.

Сортировка списка:
```java
List<Integer> numbers = new ArrayList<>(Arrays.asList(3, 1, 5, 2, 4));
Collections.sort(numbers);
System.out.println(numbers);  // Вывод: [1, 2, 3, 4, 5]
```
Таким образом, java.util.Collection и java.util.Collections предоставляют разные наборы методов для работы с коллекциями. В случае объединения этих пакетов между собой было бы много лишнего кода и сложностей при работе с коллекциями, так как у некоторых коллекций есть специфичные методы, которые не могут быть применены ко всем коллекциям.

[к оглавлению](#коллекции)

## Какая разница между итераторами с fail-fast и fail-safe поведением? (С примерами)

https://stackoverflow.com/questions/3768554/is-iterating-concurrenthashmap-values-thread-safe

fail-fast поведение означает, что при возникновении ошибки или состояния, которое может привести к ошибке, система немедленно прекращает дальнейшую работу и уведомляет об этом.

Использование fail-fast подхода позволяет избежать недетерминированного поведения программы в течение времени. В Java Collections API некоторые итераторы ведут себя как fail-fast и выбрасывают ConcurrentModificationException, если после его создания была произведена модификация коллекции, т.е. добавлен или удален элемент напрямую из коллекции, а не используя методы итератора.

Реализация такого поведения осуществляется за счет подсчета количества модификаций коллекции (modification count):

+ при изменении коллекции счетчик модификаций так же изменяется;
+ при создании итератора ему передается текущее значение счетчика;
+ при каждом обращении к итератору сохраненное значение счетчика сравнивается с текущим, и, если они не совпадают, возникает исключение.
+ Итераторы по умолчанию для Collections из java.util package , такие как ArrayList , HashMap и т. д., Являются Fail-Fast
```java
ArrayList<Integer> numbers =//... 

Iterator<Integer> iterator = numbers.iterator(); 

while (iterator.hasNext()) { 

Integer number = iterator.next(); 

numbers.add(50); 

}
```
В приведенном выше фрагменте кода ConcurrentModificationException генерируется в начале следующего цикла итерации после выполнения модификации. итераторы fail-safe не вызывают никаких исключений при изменении структуры, потому что они работают с клоном коллекции вместо оригинала.

Итератор коллекции CopyOnWriteArrayList и итератор представления keySet коллекции ConcurrentHashMap являются примерами итераторов fail-safe.

Короткий ответ: Fail-fast итератор генерирует исключение ConcurrentModificationException, если коллекция меняется во время итерации, а fail-safe – нет.

Подробнее: https://www.youtube.com/watch?v=PILSlTw4ZDc

Это не какие-то отдельные типы, а характеристики разных реализаций интерфейса Iterator. Они определяют, как поведет себя итератор при изменении перебираемой последовательности.

Fail-fast – «БЫСТРЫЙ» итератор. Когда после его создания коллекция как-либо изменилась (добавление, изменение, удаление элемента), он падает с ошибкой без лишних разбирательств.
Так работает итератор класса ArrayList, при изменении он выбрасывает ConcurrentModificationException. Рекомендуется не основывать логику программы на fail-fast отказах, и использовать их только как признак ошибки реализации.

<img width="520" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/1271b102-f7b8-49ba-9d21-2b6c99f6bbb7">

Fail-safe – «УМНЫЙ» итератор. Обычно плата  за отказоустойчивость – возможная неконсистентность данных («слабая консистентность»).
Итератор класса ConcurrentHashMap работает с копией данных, он не выбросит исключение при изменении коллекции, но может не увидеть часть свежих изменений.
Плата за отсутствие ошибок других fail-safe итераторов может отличаться, детали всегда можно найти в документации коллекций. Пример кода ниже.

<img width="636" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/f47d984c-9425-42f0-b52f-b9b2af80d92f">

Реализация такого поведения осуществляется за счет подсчета количества модификаций коллекции (modification count):

+ при изменении коллекции счетчик модификаций также изменяется;
+ при создании итератора ему передается текущее значение счетчика;
+ при каждом обращении к итератору сохраненное значение счетчика сравнивается с текущим, и, если они не совпадают, возникает исключение.

Приведите примеры итераторов, реализующих поведение fail-safe:

Итератор коллекции CopyOnWriteArrayList и итератор предоставления keySet коллекции ConcurrentHashMap являются примерами итераторов fail-safe.

Fail-safe итераторы - это тип итераторов, которые создают копию коллекции, над которой происходит итерация, и выполняют итерацию по этой копии, а не по оригинальной коллекции. Таким образом, они предотвращают возникновение ошибок, связанных с модификацией коллекции во время итерации.

При использовании fail-safe итераторов разрешается изменять или удалять элементы коллекции во время итерации без генерации исключений ConcurrentModificationException, которые могут возникнуть при использовании fail-fast итераторов. Вместо этого, fail-safe итераторы работают с состоянием коллекции на момент создания копии, поэтому любые изменения, внесенные после начала итерации, не будут отражены в итераторе.

Каким будет результат выполнения данного кода?

<img width="365" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/b69b81ba-37af-44fe-a73b-0249145f26de">

 Ответ:
Before [one, one and a half, two, two and a half, three and a half] Exception in thread "main" java.util.ConcurrentModificationException 

То есть будет выполнен код до итератора, а в самом итераторе вылетит исключение.

Итератор работы с ArrayList не позволяет изменять список во время итерации, так что все элементы, которые были созданы до итерации, будут напечатаны.

В данном случае, до возникновения исключения ConcurrentModificationException, будут напечатаны:

Before [one, one and a half, two, two and a half, three and a half] Exception in thread "main" java.util.ConcurrentModificationException 

При попытке добавить элемент в список возникнет исключение, связанное с попыткой изменить список, по которому итерируемся, так как итератор для ArrayList изначально это fail-fast итератор.
В таком случае необходимо использовать fail-safe итераторы, они работают с клоном коллекции, которую потребовалось изменить.

В данном случае можно использовать CopyOnWriteArrayList.

[к оглавлению](#коллекции)

## Чем различаются Enumeration (устаревший) и Iterator?

Хотя оба интерфейса и предназначены для обхода коллекций между ними имеются существенные различия:

+ с помощью Enumeration нельзя удалять элементы;
+ в Iterator исправлены имена методов для повышения читаемости кода (Enumeration.hasMoreElements() соответствует Iterator.hasNext(), Enumeration.nextElement() соответствует Iterator.next() и т.д);
+ Enumeration присутствуют в устаревших классах, таких как Vector/Stack, тогда как Iterator есть во всех современных классах-коллекциях.

Это два интерфейса в пакете java.util используются для обхода элементов коллекции. Хотя они выполняют одну и ту же функцию, между ними существуют некоторые различия.

Используя Enumeration, вы можете только перемещаться по коллекции, а с помощью Итератора можете также удалить элемент при обходе коллекции.

Методы – это основное различие между интерфейсами Enumeration и Iterator. Можно сказать, что Iterator – это расширенная версия Enumeration.

<img width="624" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/9f717afb-0de3-4943-9173-67aaee2f8723">

Enumeration — это устаревший интерфейс, используемый для обхода только устаревших классов, таких как Vector, HashTable и Stack.

Поскольку Iterator НЕ является устаревшим, то именно он используется для обхода большинства классов в Collection Framework. Например, для обхода ArrayList, LinkedList, HashSet, LinkedHashSet, TreeSet, HashMap, LinkedHashMap, TreeMap и т. д.

Итератор является «быстрым» fail-fast итератором, то есть будет выброшено исключение ConcurrentModificationException, если коллекция изменится во время итерации с применением собственного метода remove(). Напротив, Enumeration не выбросит никаких исключений, даже если коллекция изменяется во время итерации.

Согласно Java API Docs, итератор всегда предпочтительнее перечисления:
+ Функции Enumeration дублируются интерфейсом Iterator. Кроме того, Iterator добавляет операцию удаления и имеет более короткие имена методов.
+ В новых реализациях следует рассмотреть возможность использования Iterator вместо Enumeration.

[к оглавлению](#коллекции)

## Как избежать ConcurrentModificationException во время перебора коллекции?

+	Попробовать подобрать другой итератор,  работающий по принципу fail-safe. К примеру, для List можно использовать ListIterator.
+	Использовать ConcurrentHashMap и CopyOnWriteArrayList
+	Преобразовать список в массив и перебирать массив
+	Блокировать изменения списка на время перебора с помощью блока synchronized 

Отрицательная сторона последних двух вариантов – это ухудшение производительности

[к оглавлению](#коллекции)

## Как между собой связаны Iterable, Iterator и for-each?

https://javarush.com/quests/lectures/questsyntaxpro.level13.lecture01

Интерфейс Iterable имеет только один метод - iterator(), который возвращает объект-Iterator. 

Iterable<T> Iterator<T>iterator() Возвращает объект-итератор.

Класс Iterator отвечает за безопасный проход по списку элементов, имеет всего 4 метода:

+ forEachRemaining(Consumer<? super E> action) - Performs the given action for each remaining element until all elements have been processed or the action throws an exception.
+ hasNext() — возвращает true или false в зависимости от того, есть ли в списке следующий элемент, или мы уже дошли до последнего.
+ next() — возвращает следующий элемент списка
+ remove() — удаляет элемент из списка

Классы, реализующие интерфейс Iterable, могут применяться в конструкции for-each, которая использует Iterator.
```java
// Iterating over collection 'c' using Iterator 

for (Iterator i = c.iterator(); i.hasNext(); ) 

System.out.println(i.next());
```

+ Interface Iterable<T> – это интерфейс, который реализуют коллекции, у него есть метод iterator<T>, который возвращает объект Итератор по элементам типа T.
+ Iterator — объект с состоянием итерации (бегунок, курсор, указатель).
Он позволяет проверить, есть ли еще больше элементов, используя hasNext(), и перейти к следующему элементу (если есть), используя next(). Так же есть метод remove().
+ forEach — это разновидность цикла for, метод интерфейса Iterable. Выполняет заданное действие для каждого элемента Iterable до тех пор, пока все элементы не будут обработаны или действие не вызовет исключение.

default void forEach(Consumer<? Super T> action)

В Java интерфейс Iterable используется для определения типа, который может быть итерирован (перебран). Интерфейс Iterable определяет только один метод - iterator(), который возвращает объект типа Iterator.

Интерфейс Iterator используется для итерации (перебора) элементов коллекции. Он предоставляет методы для проверки наличия следующего элемента (hasNext()), получения следующего элемента (next()) и удаления текущего элемента (remove()). Объект типа Iterator является внутренней реализацией для выполнения итерации по коллекции.

for-each - это синтаксический сахар (syntactic sugar) в Java, который позволяет перебирать элементы коллекции удобным способом. Он использует интерфейс Iterable и объект типа Iterator внутри. Когда вы используете for-each, вы неявно вызываете метод iterator() на коллекции, чтобы получить Iterator, а затем перебираете элементы коллекции с помощью методов hasNext() и next().

[к оглавлению](#коллекции)

## Можно ли итерируясь по ArrayList удалить элемент? Какое вылетит исключение?

Если не через iterator, например через for each - то будет исключение 

В Java для удаления элементов во время перебора нужно использовать специальный объект — итератор (класс Iterator)
```java
for (Cat cat: cats) { 

if (cat.name.equals(\"Бегемот\")) { 

cats.remove(cat); 

} 

} 

java.util. 

ConcurrentModificationException 

Iterator<Cat> catIterator = cats.iterator();//создаем итератор 

while(catIterator.hasNext()) {//до тех пор, пока в списке есть элементы 

Cat nextCat = catIterator.next();//получаем следующий элемент 

System.out.println(nextCat);//выводим его в консоль 

}
```
<img width="500" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/bbfb1167-10d8-4dd7-a544-8459a2b90658">

Да, можно, но единственный способ удалить элемент из коллекции при обходе, не получив при этом ConcurrentModificationException или неопределенное поведение – удалить с помощью remove() того же инстанса итератора.

[к оглавлению](#коллекции)

## Как удалить элемент из ArrayList при итерации?

Единственный способ удалить элемент из коллекции при обходе, не получив при этом ConcurrentModificationException или неопределенное поведение – удалить с помощью remove() того же инстанса итератора.

Некоторые коллекции (CopyOnWriteArrayList и ConcurrentHashMap), адаптированные под многопоточную среду и имеют fail-safe итераторы.

[к оглавлению](#коллекции)

## Как поведёт себя коллекция, если вызвать iterator.remove()?

Если вызову iterator.remove() предшествовал вызов iterator.next(), то iterator.remove() удалит элемент коллекции, на который указывает итератор, в противном случае будет выброшено IllegalStateException().
```java
Iterator<String> it = names.iterator(); 

while (it.hasNext()) { 

String el = it.next(); 

if (el.equals()) { 

for (String el: names) { 

if (el.equals()) { 

names.remove(el); // WRONG! 

} it.remove(); // it’s norm 

} 

}
```

В Java, если вызвать метод iterator.remove() на коллекции, поведение будет зависеть от конкретного типа коллекции и от того, был ли предварительно вызван метод next() на итераторе.

+ Если метод next() еще не вызывался на итераторе или был вызван после последнего вызова next(), вызов iterator.remove() приведет к IllegalStateException, так как не было текущего элемента для удаления.
+ Если предварительно был вызван метод next() на итераторе, то вызов iterator.remove() удалит последний элемент, который был возвращен методом next().

Некоторые конкретные реализации коллекций могут поддерживать удаление элементов посредством iterator.remove() без предварительного вызова next(). В таких случаях вызов iterator.remove() удалит текущий элемент итератора.

Важно отметить, что вызов iterator.remove() изменяет коллекцию, на которой был создан итератор. Если после вызова iterator.remove() производится изменение коллекции (например, добавление или удаление элементов), то возникнет исключение ConcurrentModificationException.

[к оглавлению](#коллекции)

## Чем Set отличается от List?

Set описывает неупорядоченную коллекцию, не содержащую повторяющихся элементов List представляет собой коллекцию, в которой допустимы дублирующие значения. Элементы такой коллекции пронумерованы, начиная от нуля, к ним можно обратиться по индексу.

Set и List в Java являются двумя разными интерфейсами коллекций.

+ Уникальные элементы: Основное отличие между Set и List заключается в том, что Set не допускает наличие дублирующихся элементов, в то время как в List элементы могут повторяться.
+ Порядок элементов: В Set элементы не имеют определенного порядка, в отличие от List, где сохраняется порядок добавления элементов.
+ Доступ к элементам: List предоставляет доступ к элементам по индексу, что позволяет получать элементы по их позиции в списке. Set не предоставляет такой функциональности, поскольку порядок элементов в Set не определен.
+ Дублирование элементов: При попытке добавить дублирующийся элемент в Set, операция будет проигнорирована. В List же можно добавить несколько одинаковых элементов.

В целом, отличие между Set и List заключается в способе хранения и доступе к элементам, а также в возможности дублирования элементов

List – упорядоченный список с возможностью содержания дубликатов и доступа по индексу (random access, произвольно получить элемент по индексу).

Set – не обязательно упорядоченное множество уникальных (с точки зрения equals) значений. Чтобы из Set получить элемент, используется Iterator.

[к оглавлению](#коллекции)

## Расскажите про интерфейс Set.

Set — переводится как "множество". От очереди и списка Set отличается бОльшей абстракцией над хранением элементов.

Set — как мешок с уникальными предметами, где  неизвестно, как лежат предметы и в каком порядке они легли.

В Java такой набор представлен интерфейсом java.util.Set

Set — "collection that contains NO duplicate elements".
Интересно, что сам интерфейс Set не добавляет новых методов к интерфейсу Collection, а лишь уточняет требования (про отсутствие дубликатов).

В основе Set лежит Map, у которого:
+ ключи – это элементы множества Set
+ значения – это константа-заглушка
```java
// Объект класса Object, каждый раз выступающий в роли значения в Map
private static final Object PRESENT = new Object();
```
Почему так? Так как Map хранит пары ключ-значения, а набору Set нужны только значения, то элемент Set занимает место ключа, а место значения Java заполняет пустым объектом (new Object).

<img width="711" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/161c76be-0262-4dbd-9f05-277f7af0deb2">

Set представляет собой неупорядоченную коллекцию, которая не может содержать дублирующиеся данные. Является программной моделью математического понятия «множество». Set не добавляет новых методов, только вносит изменения в унаследованные. Множество, как и список, и любую коллекцию (и не только) можно обойти в цикле for-each:
```java
for (Integer number : intSet) { 

System.out.println(number); 

}
```
Но вот доступ по индексу (порядковому номеру) (метод list.get(int index)) есть только у List, у Set этого метода нет. Это связано с тем, что порядок элементов во множестве не определён.

Интерфейс Set включает следующие методы:

+ add(Object o) Добавление элемента в коллекцию, если он отсутствует. Возвращает true, если элемент добавлен. 
+ addAll(Collection c) Добавление элементов коллекции, если они отсутствуют. 
+ clear() Очистка коллекции. 
+ contains(Object o) Проверка присутствия элемента в наборе. Возвращает true, если элемент найден. 
+ containsAll(Collection c) Проверка присутсвия коллекции в наборе. Возвращает true, если все элементы содержатся в наборе. 
+ equals(Object o) Проверка на равенство.
+ hashCode() Получение hashCode набора.
+ isEmpty() Проверка наличия элементов. Возвращает true если в коллекции нет ни одного элемента. 
+ iterator() Функция получения итератора коллекции. 
+ remove(Object o) Удаление элемента из набора. 
+ removeAll(Collection c) Удаление из набора всех элементов переданной коллекции. 
+ retainAll(Collection c) Удаление элементов, не принадлежащих переданной коллекции. 
+ size() Количество элементов коллекции 
+ toArray() Преобразование набора в массив элементов. 
+ toArray(T[] a) Преобразование набора в массив элементов. В отличии от предыдущего метода, который возвращает массив объектов типа Object, данный метод возвращает массив объектов типа, переданного в параметре.

Основные реализации интерфейса Set в Java включают HashSet, TreeSet и LinkedHashSet.

+ HashSet - реализация на основе хэш-таблицы. Элементы в HashSet'е не упорядочены, итерация происходит в произвольном порядке. Операции добавления, удаления и поиска элементов производятся с почти постоянной временной сложностью O(1).
+ TreeSet - реализация на основе дерева (красно-черное дерево). Элементы в TreeSet'е хранятся в отсортированном порядке, что позволяет эффективно выполнять операции поиска, вставки и удаления элементов во время выполнения. Временная сложность этих операций составляет O(log n).
+ LinkedHashSet - реализация, которая объединяет функции HashSet и LinkedList. Элементы в LinkedHashSet'е хранятся в порядке добавления, что позволяет эффективно выполнять операции поиска, вставки и удаления элементов. Временная сложность этих операций также составляет O(1).

[к оглавлению](#коллекции)

## Расскажите про реализации интерфейса Set

![image](https://github.com/Oknel-Vap/Interview_questions/assets/116596752/fd384984-eecd-4dc4-a7e8-380c5e1a38b5)

В множествах Set каждый элемент хранится только в одном экземпляре, а разные реализации Set используют разный порядок хранения элементов. 

Все классы, реализующие интерфейс Set, внутренне поддерживаются реализациями Map.

Set имеет несколько связанных с собой интерфейсов.

Реализации **SortedSet** дают линейный порядок множества. Элементы упорядочены по возрастанию. Порядок либо натуральный (элементы реализуют интерфейс Comparable), либо его определяет переданный в конструктор Comparator.

Этот интерфейс добавляет методы получения подмножества от указанного элемента (tailSet), до элемента (headSet), и между двумя (subSet). Подмножество включает нижнюю границу, не включает верхнюю.

<img width="309" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/a75ed3c9-32f2-4720-973e-c7170bfabe52">

SortedSet расширяется интерфейсом **NavigableSet** для итерации по порядку, получения ближайшего снизу (floor), сверху (ceiling), большего (higher) и меньшего (lower) заданному элемента.

SortedSet расширен методами навигации, сообщающими о ближайших совпадениях для заданных целей поиска.

NavigableSet добавляет к привычному iterator (который идёт от меньшего к большему) итератор для обратного порядка — descendingIterator.

Кроме того, NavigableSet позволяет при помощи метода descendingSet получить вид на себя (View), в котором элементы идут в обратном порядке (через полученный элемент можно изменять элементы изначального Set). Интересно, что NavigableSet, подобно Queue, умеет получать и убирать элементы из набора: pollFirst (минимальный) и pollLast (максимальный).

Какие еще есть реализации?
⦁	на основе хэш-кода — HashSet
⦁	двусвязного списка — LinkedHashSet
⦁	на основе красно-чёрного дерева — TreeSet

В HashSet порядок элементов определяется по сложному алгоритму. 

TreeSet - объекты хранятся отсортированными по возрастанию в порядке сравнения

LinkedHashSet - хранение элементов в порядке добавления. 

Множества часто используются для проверки принадлежности, чтобы вы могли легко проверить, принадлежит ли объект заданному множеству, поэтому на практике обычно выбирается реализация HashSet, оптимизированная для быстрого поиска.

**HashSet**

Класс HashSet реализует интерфейс Set, основан на хэш-таблице, а также поддерживается с помощью экземпляра HashMap. В HashSet элементы не упорядочены, нет никаких гарантий, что элементы будут в том же порядке спустя какое-то время.

HashSet хранит элементы с помощью HashMap. Хоть и для добавления элемента в HashMap он должен быть представлен в виде пары «ключ-значение», в HashSet добавляется только значение.

Операции добавления, удаления и поиска будут выполняться за константное время при условии, что хэш-функция правильно распределяет элементы по «корзинам».

Хэш-функция — это функция, сужающая множество значений объекта до некоторого подмножества целых чисел. Класс Object имеет метод hashCode(), который используется классом HashSet для эффективного размещения объектов, заносимых в коллекцию. В классах объектов, заносимых в HashSet, этот метод должен быть переопределен (override). HashSet хранит элементы таким образом, чтобы элемент можно было очень быстро найти.

Методы contains и indexOf у ArrayList проходят последовательно по элементам списка в поисках нужного элемента, а метод contains у HashSet ищет элемент многократно быстрее, так как использует совсем другой подход: элементы находятся в так называемых «корзинах» (на иллюстрации — 16 серых корзин), которые выбираются исходя из значений самих элементов (на иллюстрации — 7 зелёных элементов множества).

![image](https://github.com/Oknel-Vap/Interview_questions/assets/116596752/519ea4d4-e650-473b-88b0-fd0284e45568)

Конструкторы HashSet :

+ Создание пустого набора с начальной емкостью (16) и со значением коэффициента загрузки (0.75) по умолчанию public HashSet();
+ Создание множества из элементов коллекции public HashSet(Collection c);
+ Создание множества с указанной начальной емкостью и со значением коэффициента загрузки по умолчанию (0.75) public HashSet(int initialCapacity);
+ Создание множества с указанными начальной емкостью и по умолчанию 16, коэффициентом загрузки по умолчанию 0.75 public HashSet(int initialCapacity, float loadFactor);

Методы аналогичны методам ArrayList за исключением того, что метод add(Object o) добавляет объект в множество только в том случае, если его там нет. Возвращаемое методом значение — true, если объект добавлен, и false, если нет.

Порядок добавления объектов во множество будет непредсказуемым. HashSet использует хэширование для ускорения выборки. Если вам нужно, чтобы результат был отсортирован, то пользуйтесь TreeSet.

Реализация HashSet не синхронизируется. Если многократные потоки получают доступ к набору хеша одновременно, а один или несколько потоков должны изменять набор, то он должен быть синхронизирован внешне. Это лучше всего выполнить во время создания, чтобы предотвратить случайный несинхронизируемый доступ к набору:
```java
Set<E> set = Collections.synchronizedSet(new HashSet<E>());
```
**LinkedHashSet**

Класс LinkedHashSet расширяет класс HashSet, не добавляя никаких новых методов. Класс поддерживает связный список элементов набора в том порядке, в котором они вставлялись. Это позволяет организовать упорядоченную итерацию вставки в набор.

![image](https://github.com/Oknel-Vap/Interview_questions/assets/116596752/69172603-9f08-4910-9d62-63d7b9d8d479)

Также, как и HashSet, LinkedHashSet не синхронизируется. Поэтому при использовании данной реализации в приложении с множеством потоков, часть из которых может вносить изменения в набор, следует на этапе создания выполнить синхронизацию.

**TreeSet**

![image](https://github.com/Oknel-Vap/Interview_questions/assets/116596752/63e34236-1fbc-456d-9315-bc215b301c18)

Как работают деревья https://www.youtube.com/watch?v=0BUX_PotA4c

Статья на JavaRush https://javarush.com/quests/lectures/questcollections.level06.lecture07

Балансировка деревьев https://fkti5301.github.io/exam_tickets_aisd_2017_kolinko/tickets/12.html

Проще говоря, TreeSet это отсортированная коллекция, которая расширяет класс AbstractSet и реализует интерфейс NavigableSet.

Особенности:

+ Хранит уникальные элементы
+ Не сохраняет порядок вставки элементов
+ Сортирует элементы в порядке возрастания
+ не потокобезопасный

TreeSet не поддерживает добавление null, однако если бы вы написали свой собственный компаратор, который поддерживает null, то не было бы никаких проблем использовать null в качестве ключа

В этой реализации объекты сортируются и хранятся в порядке возрастания в соответствии с их естественным порядком. TreeSet использует самобалансирующееся двоичное дерево поиска.

По сравнению с HashSet производительность TreeSet находится на нижней стороне. Такие операции, как add , remove и search , занимают O (log n) время, в то время как такие операции, как печать n элементов в отсортированном порядке, требуют O (n) время.

Будучи самобалансирующимся двоичным деревом поиска, каждый узел двоичного дерева содержит дополнительный бит, который используется для определения цвета узла, которыйявляется красным или черным. Во время последующих вставок и удалений эти «цветные» биты 

помогают обеспечить более или менее сбалансированное дерево.

**SortedSet**

По умолчанию сортировка производится привычным способом, но можно изменить это поведение через интерфейс Comparable.

**EnumSet**

Это специализированная реализация интерфейса Set, предназначенная для работы с перечислениями (enum). Она сохраняет элементы перечисления в битовых полях и обеспечивает эффективные операции над ними.

Когда мы планируем использовать EnumSet , мы должны учитывать некоторые важные моменты:

+ Он может содержать только перечисление значения , и все значения должны принадлежать одному и тому же перечислению
+ Он не позволяет добавлять нулевые значения , вызывая Исключение NullPointerException при попытке сделать это
+ Это не потокобезопасно , поэтому нам нужно синхронизировать его внешне, если потребуется
+ Элементы хранятся в том порядке, в котором они объявлены в перечисление
+ Он использует отказоустойчивый итератор , который работает с копией, поэтому он не будет вызывать исключение ConcurrentModificationException , если коллекция будет изменена при итерации по ней

https://vertex-academy.com/tutorials/ru/perechisleniya-enum-v-java-chast-3/

https://javascopes.com/java-enumset-d8c9c94b/

https://hr-vector.com/java/enumset

**CopyOnWriteArraySet**

Эта реализация представляет собой потокобезопасный вариант множества, который обеспечивает консистентность данных даже при параллельных изменениях. CopyOnWriteArraySet защищает каждую операцию записи копированием всего массива, что может привести к значительному потреблению памяти и переносу накладных расходов на операции чтения. Она является хорошим выбором в приложениях, где операции чтения являются гораздо более частыми, чем операции записи.

[к оглавлению](#коллекции)

## Зачем нужны и чем отличаются интерфейсы Comparable и Comparator?

Comparable делает наши объекты «сравнимыми» и создает для них наиболее естественный порядок сортировки, который будет использоваться в большинстве случаев.

Comparator — это отдельный класс-«сравниватель» (перевод немного корявый, но зато понятный).

<img width="398" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/046d87a8-0c84-45c1-993e-fa19c2978aa5">

Обрати внимание: мы указали интерфейс Comparable<Car>, а не просто Comparable. Это типизированный интерфейс, то есть, требует указания конкретного класса, с которым он связан.

В принципе, <Car> можно из интерфейса и убрать, но тогда он по умолчанию сравнивает объекты Object. Вместо метода compareTo(Car o) у нас в классе будет:

<img width="362" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/646f8999-5f1e-4d9a-b613-0fa112f7f421">

Наверное, ты обратил внимание, что метод compareTo() возвращает значение int, а не boolean. 

Пусть тебя это не удивляет. Дело в том, что сравнение двух объектов дает нам 3 возможных варианта:
+ а < b
+ a > b
+ a == b.

У boolean же есть всего 2 значения — true и false, что неудобно для сравнения объектов. 

С int все намного проще. Если возвращаемое значение > 0, значит a > b. Если результат compareTo < 0, значит а < b. Ну а если результат == 0, значит два объекта равны: a == b.

Реализованный в Comparable метод сравнения называют «natural ordering» — естественной сортировкой. Это потому, что в методе compareTo() ты описываешь наиболее распространенный способ сравнения, который будет использоваться для объектов этого класса в твоей программе.

Natural Ordering уже присутствует в Java. Например, Java знает, что строки чаще всего сортируют по алфавиту, а числа — по возрастанию их значения. Поэтому если вызвать на списке чисел или строк метод sort(), так они и будут отсортированы.

Какие плюсы у Comparator?

Во-первых, совместимость с написанным кодом. Мы создали новый, специфический метод сортировки, и при этом сохранили действующий, который будет использоваться в большинстве случаев.

Во-вторых, гибкость. Мы можем добавлять сколько угодно сортировок.

**Интерфейс Comparable** (сравнимый) содержит один единственный метод int compareTo(E item), который сравнивает текущий объект с объектом, переданным в качестве параметра.
Если этот метод возвращает отрицательное число, то текущий объект будет располагаться перед тем, который передается через параметр. Если метод вернет положительное число, то, наоборот, после второго объекта. Если метод возвратит ноль, значит, оба  объекта равны.

**Интерфейс Comparator** содержит ряд методов, ключевым из которых является метод compare(), который возвращает числовое значение - если оно отрицательное, то объект a предшествует объекту b, иначе - наоборот. А если метод возвращает ноль, то объекты равны.

Для применения интерфейса нам сначала надо создать класс компаратора, который реализует этот интерфейс.

Например, сортируем дома по цене. Cоздадим объект класса PriceComparator, а потом вызовем у ArrayList метод sort(), который принимает на вход объект класса, реализующего интерфейс Comparator и отсортируем ArrayList.

<img width="465" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/223ed585-1164-45c4-b859-66dd5e69ab30">

 В консоли получим:

 <img width="455" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/5e40d3d7-677e-4dc8-8195-579260f6a292">

РАЗНИЦА:
+ Comparable реализуется ВНУТРИ класса. По сути, определяет обычный/естественный порядок сравнения объектов. ОДИН метод compareTo();
+ Comparator - реализуется ВНЕ класса. Можно реализовать разные варианты сортировки, основанные на сравнении различных полей (свойств объектов). Имеет РЯД методов, ключевой их них – compare();

Comparable - имплементится самим классом, когда нужен натуральный порядок сортировки. Пример - класс String.

Comparator - имплементится другими классами. Дает возможность отделить реализацию сравнения от класса и сделать несколько реализаций сравнения по разным параметрам для одного класса.

<img width="490" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/ee24d64b-9e25-4bee-9aae-ddf0be5e5385">

 [к оглавлению](#коллекции)

## В чем отличия TreeSet и HashSet?

TreeSet обеспечивает упорядоченно хранение элементов в виде красно-черного дерева. Сложность выполнения основных операций не хуже O(log(N)) (Логарифмическое время).

HashSet использует для хранения элементов такой же подход, что и HashMap, за тем отличием, что в качестве ключа используется добавляемый элемент, а в качестве значения — объект-пустышка (new Object()), кроме того HashSet не поддерживает упорядоченное хранение элементов и обеспечивает временную сложность выполнения операций аналогично HashMap.

<img width="165" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/8da3d1b0-61db-4ebd-bc09-4461b1123ef2">

Класс HashSet реализует интерфейс Set, основан на хэш-таблице (оптимизирован для быстрого поиска). Не запоминает порядок добавления элементов. Может хранить null.

Класс TreeSet реализует интерфейс SortedSet реализован на основе красно-чёрного дерева (хранит элементы в отсортированном по возрастанию порядке).

TreeSet и HashSet - это две реализации интерфейса Set в языке программирования Java, которые служат для хранения уникальных элементов без дубликатов. Однако они имеют несколько отличий внутренней структуры и характеристик.

1. Упорядоченность элементов:
   
   + HashSet: Элементы в HashSet не имеют определенного порядка. Порядок добавления элементов может не совпадать с порядком, в котором они будут храниться внутри набора. Порядок элементов в HashSet определяется хэш-кодами элементов.
   + TreeSet: Элементы в TreeSet хранятся в отсортированном порядке. Они автоматически сортируются по их естественному порядку (если элементы реализуют интерфейс Comparable) или по заданному компаратору (если он был предоставлен при создании TreeSet).

2. Производительность операций:
   
   + HashSet: Вставка, удаление и поиск элементов в HashSet происходят за O(1) в среднем случае (константное время), если хэш-функция хорошо распределена и конфликтов мало.
   + TreeSet: Вставка, удаление и поиск элементов в TreeSet выполняются в O(log n), где n - количество элементов в наборе. Это обусловлено необходимостью поддерживать отсортированное дерево.

3. Интерфейс:
   
   + HashSet: Предоставляет только базовые методы для добавления, удаления и поиска элементов.
   + TreeSet: Помимо базовых методов, также предоставляет дополнительные методы для работы с элементами в отсортированном порядке, такие как first(), last(), headSet(), tailSet() и другие.

4. Использование памяти:
   
   + HashSet: Обычно требует меньше памяти, чем TreeSet, так как не нужно хранить дополнительные данные для поддержания порядка элементов.
   + TreeSet: Требует дополнительной памяти для хранения структуры данных, обеспечивающей отсортированность элементов.
     
5. Сравнение элементов:
   + HashSet: Определяет уникальность элементов на основе методов `hashCode()` и `equals()`. Два объекта считаются равными (или дубликатами) в HashSet, если их хэш-коды равны и метод `equals()` возвращает `true`.
   + TreeSet: Определяет уникальность элементов с помощью метода `compareTo()` или компаратора. Два объекта считаются равными (или дубликатами) в TreeSet, если метод `compareTo()` (или компаратор) возвращает `0`.

Поэтому, если вы хотите использовать собственные критерии для сравнения элементов (например, когда элементы не реализуют интерфейс Comparable), вам придется использовать TreeSet и предоставить соответствующий компаратор, который определит порядок элементов.

В итоге, выбор между HashSet и TreeSet зависит от ваших конкретных потребностей:

- Используйте HashSet, если вам не нужна упорядоченность элементов, и вы хотите максимальную производительность операций вставки, удаления и поиска, а также у ваших объектов определены корректные методы `hashCode()` и `equals()` для определения уникальности.
- Используйте TreeSet, если вам требуется упорядоченность элементов, или если вам нужны собственные критерии для сравнения элементов, которые не определены через интерфейс Comparable.

Имейте в виду, что каждая реализация имеет свои особенности, и выбор будет зависеть от требований и характеристик вашего приложения.

Выбор между HashSet и TreeSet зависит от конкретных требований вашего приложения. Если вам не требуется упорядоченность элементов и вы хотите максимизировать производительность операций вставки, удаления и поиска, то лучше выбрать HashSet. Если же вам нужны элементы в отсортированном порядке или вам необходимо использовать некоторые дополнительные методы для работы с элементами в отсортированном виде, то лучше использовать TreeSet.

 [к оглавлению](#коллекции)

## Чем LinkedHashSet отличается от HashSet?

Класс LinkedHashSet расширяет класс HashSet, не добавляя никаких новых методов. Класс поддерживает связный список элементов набора в том порядке, в котором они вставлялись. Это позволяет организовать упорядоченную итерацию вставки в набор.

LinkedHashSet и HashSet - это две реализации интерфейса Set в языке программирования Java. Обе они предназначены для хранения уникальных элементов без дубликатов, но у них есть некоторые отличия:

1. Порядок элементов:

   + HashSet: Элементы в HashSet не имеют определенного порядка. Порядок добавления элементов может не совпадать с порядком, в котором они будут храниться внутри набора. Порядок элементов в HashSet определяется хэш-кодами элементов.
   + LinkedHashSet: Элементы в LinkedHashSet хранятся в порядке их добавления. Это означает, что элементы будут расположены в том порядке, в котором они были вставлены в набор. Таким образом, порядок элементов сохраняется.

2. Производительность операций:

   + HashSet: Вставка, удаление и поиск элементов в HashSet происходят за O(1) в среднем случае (константное время), если хэш-функция хорошо распределена и конфликтов мало.
   + LinkedHashSet: Вставка, удаление и поиск элементов в LinkedHashSet выполняются за O(1) в среднем случае, так как элементы хранятся в хэш-таблице, но при этом сохраняется порядок элементов. Таким образом, LinkedHashSet может быть чуть медленнее HashSet из-за дополнительных манипуляций с порядком элементов.

3. Использование памяти:

   + HashSet: Обычно требует меньше памяти, чем LinkedHashSet, так как LinkedHashSet должен хранить дополнительные данные для поддержания порядка элементов.
   + LinkedHashSet: Требует дополнительной памяти для хранения порядка добавления элементов.

4. Итерация:

   + HashSet: Итерация по элементам HashSet не гарантирует определенный порядок. Вы получите элементы в произвольном порядке, зависящем от хэш-кодов элементов и внутренней структуры хэш-таблицы.
   + LinkedHashSet: Итерация по элементам LinkedHashSet происходит в порядке их добавления, что может быть полезным в некоторых случаях, когда вам важен порядок элементов.

Выбор между LinkedHashSet и HashSet зависит от требований вашего приложения. Если вам не важен порядок элементов и вы хотите максимизировать производительность операций вставки, удаления и поиска, то лучше выбрать HashSet. Если вам важен порядок элементов и вам нужны элементы в порядке их добавления, то LinkedHashSet может быть более подходящим выбором.

<img width="327" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/d3d11fb2-9e9c-4523-9169-91f12a1a53fe">

LinkedHashSet отличается от HashSet только тем, что в его основе лежит LinkedHashMap вместо HashMap.

Благодаря этому порядок элементов при обходе коллекции является идентичным порядку добавления элементов (insertion-order, то есть хранит элементы в порядке добавления).
При добавлении элемента, который уже присутствует в LinkedHashSet (т.е. с одинаковым ключом), порядок обхода элементов не изменяется.

<img width="840" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/d361e4b0-073f-4b7a-9e0c-cbc41588142c">

Хеш-таблица (Hash table) и связанный список (linked list) имплементируют интерфейс Set с предсказуемым порядком итерации. LinkedHashSet отличается от HashSet тем, что поддерживает двусвязный список, проходящий через все его записи. 

Этот связанный список определяет порядок итерации, то есть порядок, в котором элементы были вставлены в набор (порядок вставки, insertion-order).

Обратите внимание, что порядок вставки не изменяется, если элемент повторно вставляется в набор. Элемент e повторно вставляется в множество s, если s.add(e) вызывается, когда s.contains(e) возвращает значение true непосредственно перед вызовом).

 [к оглавлению](#коллекции)

 ## Что будет, если добавлять элементы в TreeSet по возрастанию?

В основе TreeSet лежит красно-черное дерево, которое умеет само себя балансировать. В итоге, TreeSet все равно в каком порядке вы добавляете в него элементы, преимущества этой структуры данных будут сохраняться

 [к оглавлению](#коллекции)

## Что будет в этом случае?

<img width="818" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/b48ec84d-1fd3-47c1-966c-d853e07292a8">

Подсказка: как обеспечивается уникальность элементов в TreeSet? Метод compare() Ответ: получим только один элемент списка, так как в TreeSet будет добавлен только "1", потому что уникальность и порядок обеспечиваются методом compare(), который возвращает 0, если объекты одинаковые.

[к оглавлению](#коллекции)

## Как устроен HashSet, сложность основных операций.

В основе HashSet лежит HashMap, у которого:
+ ключи – это элементы HashSet
+ значения – это константа-заглушка
```java
// Объект класса Object, каждый раз выступающий в роли значения в Map
private static final Object PRESENT = new Object();
```
HashSet хранит элементы таким образом, чтобы элемент можно было очень быстро найти. Метод contains() у HashSet ищет элемент быстро, так как под капотом HashMap:

элементы находятся в так называемых корзинах/бакетах/entry, которые выбираются исходя из значений самих элементов(поиск бакета по хэшкоду, см. далее HashMap).
На рисунке 16 серых корзин/бакетов/узлов/нод и 7 зелёных элементов множества.

<img width="838" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/ac9b611e-8196-4dd8-abc5-df1777fe38bb">

Операции добавления, удаления и поиска будут выполняться за константное время О(1) (то есть быстро) при условии, что хэш-функция правильно распределяет элементы по
«корзинам». Для получения элементов из Set используется Iterator, операции быстрые.

Внимание, у Set нет метода get()! – часто спрашивают =)

<img width="849" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/16f8b276-9143-4dd0-ae46-3cca4e769f8f">

Несколько важных пунктов о HashSet:
+ Класс реализует интерфейс Set, он может  хранить только уникальные значения
+ Может хранить NULL – значения
+ Порядок добавления элементов вычисляется с помощью хэш-кода
+ HashSet также реализует интерфейсы Serializable и Cloneable

Для поддержания постоянного времени выполнения операций время, затрачиваемое на действия с HashSet, должно быть прямо пропорционально количеству элементов в HashSet + «емкость» встроенного экземпляра HashMap (количество «корзин»).

Поэтому для поддержания производительности очень важно не устанавливать слишком высокую начальную ёмкость (или слишком низкий коэффициент загрузки).

Коэффициент загрузки = Количество хранимых элементов в таблице / размер хэш-таблицы Например, если изначальное количество ячеек в таблице равно 16, и коэффициент загрузки равен 0,75, то из этого следует, что когда количество заполненных ячеек достигнет 12, их количество автоматически увеличится.

Не является структурой данных с встроенной синхронизацией, поэтому если с ним работают одновременно несколько потоков, и как минимум один из них пытается внести изменения, необходимо обеспечить синхронизированный доступ извне.
```java
Set s = Collections.synchronizedSet(new HashSet(...));
```
HashSet - это структура данных в Java, реализующая интерфейс Set и использующая хэш-таблицу для хранения уникальных элементов. В HashSet элементы не допускают повторений, и порядок элементов не гарантируется (он может меняться при различных операциях).

Устройство HashSet:
- В основе HashSet лежит хэш-таблица, которая состоит из массива и списков связанных элементов (bucket). Когда элемент добавляется в HashSet, вычисляется его хэш-код, и элемент помещается в соответствующую ячейку массива. Если в этой ячейке уже есть элементы (коллизия), то элемент добавляется в список, связанный с этой ячейкой.

Сложность основных операций в HashSet:
1. Вставка (добавление элемента): O(1) в среднем, O(n) в худшем случае. Вставка элемента в хэш-таблицу требует вычисления хэш-кода и нахождения правильной ячейки массива для вставки. В среднем добавление выполняется за постоянное время O(1), но в случае коллизий (несколько элементов с одинаковым хэшем), возможно придется пройтись по списку связанных элементов, что займет линейное время O(n), где n - количество элементов в списке.

2. Удаление элемента: O(1) в среднем, O(n) в худшем случае. При удалении элемента также вычисляется его хэш-код, находится ячейка массива и выполняется поиск в списке (при коллизиях). В среднем удаление элемента выполняется за постоянное время O(1), но в худшем случае придется пройтись по списку связанных элементов, что займет линейное время O(n), где n - количество элементов в списке.

3. Поиск элемента: O(1) в среднем, O(n) в худшем случае. При поиске элемента сначала вычисляется его хэш-код, находится ячейка массива и выполняется поиск в списке (при коллизиях). В среднем поиск элемента выполняется за постоянное время O(1), но в худшем случае придется пройтись по списку связанных элементов, что займет линейное время O(n), где n - количество элементов в списке.

Общая сложность операций в HashSet зависит от равномерности хэш-функции и количества коллизий. В большинстве случаев, если хэш-функция хорошо распределяет элементы по ячейкам массива и коллизии редки, операции в HashSet выполняются очень эффективно. Однако в худшем случае, когда все элементы попадают в одну ячейку и образуют длинный список, сложность операций может стать линейной, что следует учитывать при выборе подходящей структуры данных для конкретной задачи.

[к оглавлению](#коллекции)

## Как устроен LinkedHashSet, сложность основных операций

LinkedHashSet расширяет класс HashSet, в основе лежит LinkedHashMap - порядок элементов при обходе коллекции является идентичным порядку добавления элементов (insertion-order). В среднем сложность поиска, вставки удаления - константное время O(1), в худшем случае это O(n).

Класс LinkedHashSet расширяет класс HashSet, не добавляя никаких новых методов. Класс поддерживает связный список элементов множества в том порядке, в котором они вставлялись. Это позволяет организовать упорядоченную итерацию вставки в набор.

LinkedHashSet - это класс в Java, который представляет собой реализацию интерфейса Set, и обеспечивает хранение элементов в порядке их вставки, а также предотвращает дублирование элементов.

Устройство LinkedHashSet:
LinkedHashSet основан на хэш-таблице, которая использует хэш-коды элементов для быстрого доступа к ним. Кроме того, LinkedHashSet также содержит двунаправленный связанный список, который поддерживает порядок вставки элементов и обеспечивает устойчивость итерации (в порядке вставки).

Сложность основных операций LinkedHashSet:
Предположим, что n - количество элементов в LinkedHashSet.

1. Добавление (вставка) элемента: O(1) (среднее время) и O(n) (худшее время). В среднем вставка происходит за константное время, но если возникают коллизии (несколько элементов с разными значениями хэш-кодов, но одинаковыми хэш-индексами), то производится поиск свободного места в хэш-таблице, что может занять линейное время в худшем случае.

2. Удаление элемента: O(1) (среднее время) и O(n) (худшее время). Как и вставка, удаление обычно выполняется за константное время, но в худшем случае может потребоваться проходить по связанным элементам в случае коллизий.

3. Поиск элемента (contains): O(1) (среднее время) и O(n) (худшее время). Поиск элемента по хэш-таблице выполняется за константное время в среднем, но в худшем случае может потребоваться просматривать связанные элементы.

4. Итерация по LinkedHashSet: O(n). Итерация осуществляется в порядке вставки, и вам потребуется просмотреть каждый элемент один раз.

Итак, хотя основные операции LinkedHashSet обычно выполняются за константное время, необходимо учитывать, что в худшем случае (когда возникают коллизии) они могут занимать линейное время.

[Доп.материал №1](https://javahungry.blogspot.com/2015/09/how-linkedhashset-works-internally-in-java.html)

[к оглавлению](#коллекции)

## Как устроен TreeSet, сложность основных операций

TreeSet имплементирует интерфейс NavigableMap, что и обуславливает его поведение, обеспечивает упорядоченное хранение элементов в виде красно-черного дерева. 

Сложность выполнения основных операций не хуже O(log(n)) (логарифмическое время).

В основе TreeSet лежит TreeMap, у которого:
⦁	ключи – это элементы TreeSet
⦁	значения – это константа-заглушка

HashSet не может гарантировать, что данные будут отсортированы, так как работает по другому алгоритму. Если сортировка для вас важна, то используйте TreeSet.

<img width="604" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/6f61f338-91b7-481f-a680-e81569f05440">

TreeSet - это класс в Java, который реализует интерфейс (public interface NavigableSet<E> extends SortedSet<E>), а вообще public class TreeSet<E>
extends AbstractSet<E> implements NavigableSet<E>, Cloneable, Serializable. Он использует структуру данных красно-черное дерево для хранения элементов, и поэтому поддерживает элементы в отсортированном порядке.

Устройство TreeSet:

TreeSet базируется на красно-черном дереве, которое является сбалансированным двоичным деревом поиска. Это дерево обладает следующими свойствами:

1. Каждый узел является либо красным, либо черным.
2. Корень и листья (NIL-узлы) дерева являются черными.
3. Если узел красный, то оба его дочерних узла черные.
4. Для каждого узла все простые пути от него до листьев содержат одинаковое количество черных узлов.

Сложность основных операций TreeSet:

Предположим, что n - количество элементов в TreeSet.

1. Добавление (вставка) элемента: O(log n). Вставка элемента в TreeSet требует поиска правильной позиции в красно-черном дереве, что выполняется за время, пропорциональное высоте дерева. Так как красно-черное дерево является сбалансированным, высота дерева log(n), где n - количество элементов, и, следовательно, вставка выполняется за логарифмическое время.

2. Удаление элемента: O(log n). Удаление элемента из TreeSet также требует поиска узла с заданным значением и удаления его из красно-черного дерева. Поиск выполняется за время O(log n) в сбалансированном дереве.

3. Поиск элемента (contains): O(log n). Поиск элемента в TreeSet также выполняется за логарифмическое время, так как требуется пройти по уровням дерева для поиска заданного значения.

4. Итерация по TreeSet: O(n) (это логично, так будет у всех). Итерация по TreeSet в отсортированном порядке требует посещения каждого элемента дерева, что занимает линейное время.

Обратите внимание, что все операции TreeSet работают во время выполнения логарифмической сложности благодаря сбалансированности красно-черного дерева. Это делает TreeSet эффективным для операций, связанных с поиском, вставкой и удалением элементов в отсортированном множестве.

Класс TreeSet реализует интерфейс NavigableSet, который поддерживает элементы в отсортированном по возрастанию порядке.

1. Элементы хранятся в отсортированном порядке по возрастанию

2. Под капотом использует TreeMap

3. Для хранения объектов использует бинарное красно-черное дерево

4. Сортировка происходит благодаря тому, что все добавляемые элементы реализуют интерфейсы Comparator и Comparable (в TreeSet элементы должны реализовывать интерфейс Comparable или быть предоставлены пользовательским компаратором при создании TreeSet)

> Если элементы не реализуют интерфейс Comparable, вы можете создать TreeSet с пользовательским компаратором, реализующим интерфейс Comparator. Компаратор определяет пользовательский порядок сортировки для объектов, которые не имеют естественного порядка, или когда вы хотите использовать другой порядок сортировки, отличный от естественного.

Временная сложность базовых операций add(), remove(), contains() медленнее, чем в хэш-множествах, но быстрее, чем в списках: O(log(n))
```java
public class TreeSet<E> extends AbstractSet<E>
implements NavigableSet<E>, Cloneable, Serializable
```
+ Если TreeSet пустой – можно положить единственное значение null
+ При этом все операции кроме size() и clear() перестанут работать.
+ В непустой TreeSet положить null уже нельзя из-за вызова compareTo()

[к оглавлению](#коллекции)

## Расскажите про интерфейс List

![image](https://github.com/Oknel-Vap/Interview_questions/assets/116596752/d639a8c4-57c6-4355-823d-dcb38a2dd9e8)

Это тип данных, в котором каждый элемент содержит какой-то объект, а также ссылку на следующий элемент списка.

Интерфейс List сохраняет последовательность добавления элементов и позволяет осуществлять доступ к элементу по индексу.

Основные характеристики интерфейса List:

1. Упорядоченность: Элементы в списке хранятся в порядке их вставки, что позволяет управлять порядком элементов.

2. Дублирование: Списки могут содержать дубликаты элементов. Это означает, что вы можете добавлять несколько одинаковых элементов в список.

3. Индексирование: Каждый элемент в списке имеет свой уникальный индекс, начиная с 0. Это позволяет получать доступ к элементам по их индексу и выполнять различные операции, такие как вставка, удаление, замена элементов и другие операции на основе индексов.

List добавляет следующие методы:

+ void add(int index, Е obj) - вставляет obj в вызывающий список в позицию, указанную в index. Любые ранее вставленные элементы за указанной позицией вставки смещаются вверх. То есть никакие элементы не перезаписываются.
+ bооlеаn addAll (int index,Collection<? extends Е> с) - вставляет все элементы в вызывающий список, начиная с позиции, переданной в index. Все ранее существовавшие элементы за точкой вставки смещаются вверх. То есть никакие элементы не перезаписываются. Возвращает true, если вызывающий список изменяется, и false в противном случае.
+ Е get (int index) - возвращает объект, сохраненный в указанной позиции вызывающего списка.
+ int indexOf(Object obj) - возвращает индекс первого экземпляра obj в вызывающем списке. Если obj не содержится в списке, возвращается 1. 
+ int lastlndexOf(Object obj) - возвращает индекс последнего экземпляра obj в вызывающем списке. Если obj не содержится в списке, возвращается 1.
+ Listlterator listlterator() - возвращает итератор, указывающий на начало списка.
+ Listlterator listlterator(int index) - возвращает итератор, указывающий на заданную позицию в списке.
+ Е remove(int index) - удаляет элемент из вызывающего списка в позиции index и возвращает удаленный элемент. Результирующий список уплотняется, то есть элементы, следующие за удаленным, сдвигаются на одну позицию назад.
+ Е set (int index, Е obj) - присваивает obj элементу, находящемуся в списке в позиции index.
+ default void sort(Comparator<? super E> c) - сортирует список, используя заданный компаратор (добавлен в версии JDК 8).
+ List subList (int start, int end) - возвращает список, включающий элементы от start до end-1 из вызывающего списка. Элементы из возвращаемого списка также сохраняют ссылки в вызывающем списке.

![image](https://github.com/Oknel-Vap/Interview_questions/assets/116596752/c9f0944a-5ac0-4e70-8987-ada215d5a191)

List – список или упорядоченная последовательность элементов, позволяющая хранить дубликаты и null. Каждый элемент имеет индекс (от нуля и дальше), поиск по индексу.

<img width="990" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/ffc1b975-de6d-4307-a135-c0ed5cfa6f58">

<img width="771" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/a5b9cf5b-094e-4939-a45f-28d9a3687fcc">

[к оглавлению](#коллекции)

## Как устроен ArrayList, сложность основных операций.

ArrayList хранит элементы в динамическом массиве. Элементы ArrayList могут быть абсолютно любых типов в том числе и null.

Основное преимущество такой коллекции над массивом – это расширяемость – увеличение длины при надобности.

Если в этом массиве заканчивается место, то создаётся второй массив побольше, куда копируются все элементы из первого. Затем второй массив занимает место первого, а первый – выбрасывается (будет уничтожен сборщиком мусора).

Длина нового массива рассчитывается так (3*n)/2+1, где n – это длина старого массива. Т.е. если старый массив был длиной 100 элементов, то новый будет 300/2+1 = 151

При добавлении элемента в середину ArrayList, все элементы справа от него копируются на 1 позицию вправо, а затем в пустую ячейку добавляется новый элемент.

По возможности, избегайте операций вставки в середину коллекции. Ведь системе приходится заново пересчитывать индексы элементов.

При удалении элемента из середины, все элементы справа от него копируются на 1 позицию влево. Сам массив не укорачивается (можно укоротить через trimToSize()).

Особенности:

+ Быстрый доступ к элементам по индексу за время O(1);
+ Доступ к элементам по значению за линейное время O(n);
+ Медленный, когда вставляются и удаляются элементы из «середины» списка;
+ Позволяет хранить любые значения в том числе и null;
+ Не синхронизирован.

ArrayList – это динамический массив, т.е. может менять свой размер во время исполнения программы, при этом не обязательно указывать размерность при создании объекта. Элементы ArrayList могут быть абсолютно любых типов в том числе и null.

Используем тогда, когда нам нужна структура, похожая на массив, но где нам нужно добавлять/удалять/изменять элементы. Получение и изменение элементов выполняется быстро, поскольку эти операции просто обращаются к соответствующему элементу массива». В основе ArrayList лежит массив Object (элементами явл. Объекты типа Object).

Ёмкость capacity массива по дефолту – 10 мест (не путать размер и ёмкость).
Размер массива – это сколько по факту лежит элементов в массиве, а ёмкость – это потенциально возможное кол-во мест).

<img width="1067" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/19d3a51c-294f-4546-95c8-dd2190b34907">

<img width="865" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/cfd5a9e2-b684-4f3f-92e5-deba055e2324">

<img width="871" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/9da488c9-8af3-4aa2-b20d-cba002b0c851">

Если вызывается конструктор без параметров, то по умолчанию будет создан массив из 10-ти элементов типа Object (с приведением к типу, разумеется), индексы от 0 до 9 (Сейчас и пустой ArrayList, созданный без явного указания capacity, массива из 10 элементов не содержит и создаёт его только после начала заполнения).
```java
elementData = (E[]) new Object[10];
```
Можно использовать конструктор ArrayList(capacity) и указать свою начальную емкость.

**Добавление элементов list.add("0");**

Внутри метода add(value) происходят следующие вещи:
+ проверяется, достаточно ли места в массиве для вставки нового элемента
```java
ensureCapacity(size + 1);
```
+ добавляется элемент в конец (согласно значению size) массива
```java
elementData[size++] = element;
```
<img width="678" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/045f98dd-c9fe-400e-86b1-7fcb17b455c2">
 
Если места в массиве недостаточно, новая емкость рассчитывается по формуле (oldCapacity * 3) / 2 + 1.

Второй момент — это копирование элементов. Оно осуществляется с помощью нативного метода System.arraycopy(), который написан не на языке Java.

<img width="685" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/cbbb7b1d-1227-4bb8-9eb7-111488256f3b">

**Добавление в «середину» списка (list.add(5, "100");)**

Добавление элемента на позицию с определенным индексом происходит в три этапа:
+ проверяется, достаточно ли места в массиве для вставки нового элемента
```java
ensureCapacity(size+1);
```
+ подготавливается место для нового элемента с помощью System.arraycopy();
```java
System.arraycopy(elementData, index, elementData, index + 1, size - index);
```
+ перезаписывается значение у элемента с указанным индексом
```java
elementData[index] = element; size++;
```
В случаях, когда происходит вставка элемента по индексу и при этом в вашем массиве нет свободных мест, то вызов System.arraycopy() случится дважды: первый в ensureCapacity(), второй в самом методе add(index, value), что явно скажется на скорости всей операции добавления.

В случаях, когда в исходный список необходимо добавить другую коллекцию, да еще и в «середину», стоит использовать метод addAll(index, Collection). И хотя, данный метод скорее всего вызовет System.arraycopy() три раза, в итоге это будет гораздо быстрее поэлементного добавления.

**Удаление элементов**

Удалять элементы можно двумя способами:
+ по индексу remove(index)
+ по значению remove(value)

С удалением элемента по индексу всё достаточно просто: list.remove(5);

+ Сначала определяется, какое количество элементов надо скопировать
```java
int numMoved = size - index - 1;
```
+ затем копируем элементы используя System.arraycopy()
```java
System.arraycopy(elementData, index + 1, elementData, index, numMoved);
```
+ уменьшаем размер массива и забываем про последний элемент
```java
elementData[--size] = null; // Let gc do its work
```
При удалении по значению, в цикле просматриваются все элементы списка, до тех пор, пока не будет найдено соответствие. Удален будет лишь первый найденный элемент.

При удалении элементов текущая величина capacity не уменьшается, что может привести к своеобразным утечкам памяти. Поэтому не стоит пренебрегать методом trimToSize().

Сложность операций `ArrayList`:

+ Добавление элемента в конец списка (`add(E element)`) выполняется за константное время O(1).
+ Вставка элемента в середину списка (`add(int index, E element)`) может потребовать времени O(n), так как элементы после указанного индекса должны быть перемещены для освобождения места для нового элемента.
+ Получение элемента по индексу (`get(int index)`) выполняется за константное время O(1), так как массив имеет прямой доступ к элементам по индексу.
+ Удаление элемента из конца списка (`remove(int index)`) выполняется за константное время O(1).
+ Удаление элемента из середины списка (`remove(int index)`) может потребовать времени O(n), так как элементы после указанного индекса должны быть перемещены.

Обратите внимание, что "константное время" означает, что время выполнения операции остается неизменным независимо от размера списка, за исключением случаев, когда пересоздание массива необходимо.

<img width="461" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/3adac325-401b-4968-a716-af647294624c">


Доп.источник №1 - https://habr.com/ru/articles/128269/


[к оглавлению](#коллекции)

## Как устроен LinkedList, сложность основных операций

Доп.источник - https://habr.com/ru/articles/127864/

Связный список состоит из одинаковых элементов, которые хранят данные и хранят ссылки на следующий и предыдущий элементы. Внутри класса LinkedList существует static inner класс Entry, с помощью которого создаются новые элементы. Узлы двусвязного списка, как в случае с `LinkedList` в Java, хранятся в куче (heap). Куча является областью памяти, где хранятся объекты и данные, созданные во время выполнения программы. Каждый узел содержит данные и ссылки на предыдущий и следующий узлы, и все они располагаются в этой области памяти

![image](https://github.com/Oknel-Vap/Interview_questions/assets/116596752/161a05f7-ba21-431b-b60d-69bcac550054)

Вся работа с LinkedList сводится к изменению ссылок.

Однако, у LinkedList есть отдельные методы для работы с началом и концом списка, которых нет в ArrayList: addFirst(), addLast(): методы для добавления элемента в начало/конец списка Вставка и удаление в середину LinkedList устроены гораздо проще, чем в ArrayList. Мы просто переопределяем ссылки соседних элементов, а ненужный элемент “выпадает” из цепочки ссылок.

Особенности:

+ Из LinkedList можно организовать стэк, очередь, или двойную очередь, со временем доступа O(1) [константное время - поскольку выполняется единственная команда для его обнаружения];
+ На вставку и удаление из середины списка, получение элемента по индексу или значению потребуется линейное время O(n) [линейное время - Например, процедура, суммирующая все элементы списка, требует время, пропорциональное длине списка]. Однако, на добавление и удаление из середины списка, используя ListIterator.add() и ListIterator.remove(), потребуется O(1) (O(1), когда итератор уже «дошел» до нужного элемента. Если посмотреть в доку, то там сказано, что будет удален последний элемент, возвращенный методом next() (или previous()). А вот чтобы дойти до нужного элемента потребуется О(n/2) = O(n).);
+ Позволяет добавлять любые значения в том числе и null. Для хранения примитивных типов использует соответствующие классы-оберки;
+ Не синхронизирован.
+ LinkedList содержит все те методы, которые определены в интерфейсах List, Queue, Deque.

Некоторые из них:

+ addFirst() / offerFirst(): добавляет элемент в начало списка
+ addLast() / offerLast(): добавляет элемент в конец списка
+ removeFirst() / pollFirst(): удаляет первый элемент из начала списка
+ removeLast() / pollLast(): удаляет последний элемент из конца списка
+ getFirst() / peekFirst(): получает первый элемент
+ getLast() / peekLast(): получает последний элемент

> Из своего опыта скажу, что даже в тех случаях, когда он по идее должен был дать прирост в производительности — т.е. большой список с частым удалением и добавлением элементов в середину и начало списка — ArrayList все равно оказывался быстрее.

> Объяснение простое: ArrayList внутри себя использует System.arrayCopy — нативную функцию, которая отрабатывает на удивление шустро. В то же время для LinkedList'а приходится переопределять несколько указателей, но это не самое главное. Все эти указатели на предыдущего и следующего обходятся сборщиком мусора. Из-за этого растет время, необходимое для стадии маркинга, а с учетом того, что в одном списке оказываются элементы из разных поколений, вся процедура затягивается еще больше.

В Java `LinkedList` - это класс, представляющий двусвязный список. Он содержит узлы, каждый из которых хранит данные элемента и ссылки на предыдущий и следующий узлы.

Устройство `LinkedList`:

+ У `LinkedList` есть указатель на первый и последний элементы, которые называются головой (`head`) и хвостом (`tail`).
+ Каждый узел содержит данные элемента и ссылки на предыдущий и следующий узлы. Узел без предыдущего узла является головным, а узел без следующего узла - хвостовым.

Сложность операций `LinkedList`:

+ Добавление элемента в конец списка (`add(E element)`) выполняется за константное время O(1). Это достигается путем создания нового узла, обновления ссылок предыдущего хвостового узла и обновления ссылки хвостового узла на новый узел.
+ Вставка элемента в середину списка (`add(int index, E element)`) выполняется за O(n), так как в худшем случае может потребоваться пройти по списку от головы до нужного индекса, чтобы вставить новый узел.
+ Получение элемента по индексу (`get(int index)`) выполняется за O(n), так как может потребоваться пройти по списку от головы до нужного индекса, чтобы найти нужный элемент.
+ Удаление элемента из конца списка (`remove()`) выполняется за константное время O(1), так как имеется ссылка на последний элемент списка.
+ Удаление элемента по индексу (`remove(int index)`) выполняется за O(n), так как в худшем случае может потребоваться пройти по списку от головы до нужного индекса, чтобы удалить узел.

<img width="461" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/3adac325-401b-4968-a716-af647294624c">

Обратите внимание, что `LinkedList` обладает быстрыми операциями вставки и удаления в начало и конец списка, но медленными операциями доступа по индексу. Если вам нужен быстрый доступ к элементам по индексу, `ArrayList` может быть более эффективным выбором. Однако `LinkedList` может быть полезен, если вам нужны частые операции вставки и удаления элементов в середине списка. Выбор между `ArrayList` и `LinkedList` зависит от конкретных потребностей вашей программы.

Что следует помнить о LinkedList, решая, использовать ли данную коллекцию:
+	не синхронизирована
+	позволяет хранить любые объекты, в том числе null и повторяющиеся
+	за константное время O(1) выполняются операции вставки и удаления первого и последнего элемента и операции вставки и удаления элемента из середины списка (не учитывая время поиска позиции элемента, который осуществляется за линейное время)
+	за линейное время O(n) выполняются операции поиска элемента по индексу и по значению

<img width="637" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/a6e7d4d7-62bb-45eb-92cb-f2f65d4e73b4">

<img width="826" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/a5d47f51-c451-4bdc-9dfb-0026f3de8bde">

[к оглавлению](#коллекции)

## Почему LinkedList реализует и List, и Deque?

<img width="544" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/4c978f76-b056-463a-b928-37ddbe0ca2ee">

LinkedList – список связанных элементов, каждый из которых хранит ссылки на следующий и предыдущий элементы в списке, цепочке. Бывает односвязный и двусвязный списки.
ВАЖНО! В каком порядке элементы добавлены, в таком они и находятся. LinkedList — класс, реализующий два интерфейса — List и Deque.

Это обеспечивает возможность создания двунаправленной очереди из любых (в том числе и null) элементов. Каждый объект, помещенный в связанный список, является узлом (нодом). Каждый узел содержит элемент, ссылку на предыдущий и следующий узел. Фактически связанный список состоит из последовательности узлов, каждый из которых предназначен для хранения объекта определенного при создании типа.

Причина заключается в иерархии наследования интерфейсов:

1. `List`: Это интерфейс, представляющий упорядоченную коллекцию элементов, которая может содержать дубликаты. Он определяет методы для работы с элементами, такие как добавление, удаление, доступ по индексу и т.д. `LinkedList` реализует этот интерфейс, потому что оно предоставляет связанный список, который отлично подходит для таких операций.

2. `Deque`: Это интерфейс, который представляет двустороннюю очередь (double-ended queue). Он расширяет интерфейс `Queue` и определяет методы для работы с элементами с обоих концов очереди. `LinkedList` также реализует этот интерфейс, потому что связанный список позволяет эффективно добавлять и удалять элементы как с начала, так и с конца списка, что соответствует концепции двусторонней очереди.

Таким образом, `LinkedList` является структурой данных, которая сочетает в себе функциональность и `List`, и `Deque`, что делает его универсальным инструментом для различных задач. Он предоставляет операции для работы с элементами в середине списка, а также поддерживает добавление и удаление элементов с обоих концов списка, что делает его удобным для множества сценариев.

![image](https://github.com/Oknel-Vap/Interview_questions/assets/116596752/9225a08d-5726-4447-a88d-310c0f39adab)

<img width="620" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/aedfda14-87c2-4027-88f5-8d39f5a7823b">

[к оглавлению](#коллекции)

## Чем отличаются ArrayList и LinkedList?

<img width="594" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/a796bd4e-d791-4727-aaec-06d51dbb188c">

Вопрос проверяет знание особенностей реализации ArrayList и LinkedList и эффективности операций в этих разных реализациях.

В вопрос иногда добавляют Vector – пере-синхронизированный и устаревший вариант ArrayList, который лучше заменить Collections.synchronizedList() .

ArrayList хранит данные в массиве, LinkedList в связанном списке. Из этого вытекает разница в эффективности разных операций:
+ ArrayList лучше справляется с изменениями в середине и ростом в пределах capacity
+ LinkedList – на краях. В целом обычно ArrayList лучше.

Стоит добавить, что для работы на краях лучше использовать реализации специально для этого спроектированного интерфейса Deque: например, реализующую кольцевой буфер* ArrayDeque

<img width="981" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/973c8fc0-5d08-445c-9f1e-8f1b6a75021e">

ArrayList это список, реализованный на основе массива, а LinkedList — это классический двусвязный список, основанный на объектах с ссылками между ними.

ArrayList:
+ доступ к произвольному элементу по индексу за константное время O(1);
+ доступ к элементам по значению за линейное время O(N);
+ вставка в конец в среднем производится за константное время O(1);
+ удаление произвольного элемента из списка занимает значительное время т.к. при этом все элементы, находящиеся «правее» смещаются на одну ячейку влево (реальный размер массива (capacity) не изменяется);
+ вставка элемента в произвольное место списка занимает значительное время т.к. при этом все элементы, находящиеся «правее» смещаются на одну ячейку вправо;
минимум накладных расходов при хранении.

LinkedList:
+ на получение элемента по индексу или значению потребуется линейное время O(N);
+ на добавление и удаление в начало или конец списка потребуется константное O(1);
+ вставка или удаление в/из произвольного место константное O(1);
+ требует больше памяти для хранения такого же количества элементов, потому что кроме самого элемента хранятся еще указатели на следующий и предыдущий элементы списка.

В целом, LinkedList в абсолютных величинах проигрывает ArrayList и по потребляемой памяти, и по скорости выполнения операций. LinkedList предпочтительно применять, когда нужны частые операции вставки/удаления или в случаях, когда необходимо гарантированное время добавления элемента в список.

Для ArrayList или для LinkedList операция добавления элемента в середину (list.add(list.size()/2, newElement)) медленнее?

Для ArrayList:
+ проверка массива на вместимость. Если вместимости недостаточно, то увеличение размера массива и копирование всех элементов в новый массив (O(N));
+ копирование всех элементов, расположенных правее от позиции вставки, на одну позицию вправо (O(N));
+ вставка элемента (O(1)).

Для LinkedList:
+ поиск позиции вставки (O(N));
+ вставка элемента (O(1)).

В худшем случае вставка в середину списка эффективнее для LinkedList. В остальных - скорее всего, для ArrayList, поскольку копирование элементов осуществляется за счет вызова быстрого системного метода System.arraycopy().

[к оглавлению](#коллекции)

## Что такое Queue?

> В Java Queue - это интерфейс, представляющий структуру данных, которая работает по принципу "первым пришел, первым ушел" (FIFO - First-In-First-Out). Он используется для хранения элементов в определенном порядке, где элемент, добавленный первым, будет удален первым, а элемент, добавленный последним, будет удален последним.

Queue - это очередь, которая обычно (но необязательно) строится по принципу FIFO (First-In-First-Out) - соответственно извлечение элемента осуществляется с начала очереди, вставка элемента в конец очереди.

Хотя этот принцип нарушает, к примеру, PriorityQueue, использующая «natural ordering» или переданный Comparator при вставке нового элемента.

Особенностью PriorityQueue является возможность управления порядком элементов. По-умолчанию, элементы сортируются с использованием «natural ordering», но это поведение может быть переопределено при помощи объекта Comparator, который задаётся при создании очереди. 

Данная коллекция не поддерживает null в качестве элементов.

Используя PriorityQueue, можно, например, реализовать алгоритм Дейкстры для поиска кратчайшего пути от одной вершины графа к другой. Либо для хранения объектов согласно определённого свойства.

<img width="217" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/b962f45b-0fa8-4a6d-837c-60e58d26b851">

`PriorityQueue` в Java реализует структуру данных, называемую бинарной кучей (binary heap), для поддержки операций с приоритетами. Бинарная куча представляет собой специальный вид бинарного дерева, в котором каждый узел имеет значение, а также выполняются условия на уровне приоритетов: значение каждого узла больше или равно значений его дочерних узлов (если это мин-куча) или меньше или равно (если это макс-куча).

`PriorityQueue` может быть реализован как мин-куча или как макс-куча в зависимости от задачи. В случае мин-кучи, наименьший элемент (с наивысшим приоритетом) находится в корне кучи. В случае макс-кучи, наибольший элемент находится в корне.

Основные операции, поддерживаемые бинарной кучей и соответственно `PriorityQueue`, включают:

1. Вставка (Insertion): Новый элемент добавляется в конец кучи и затем "восстанавливается" структура кучи путем перестроения дерева вверх, чтобы сохранить условия приоритета.

2. Извлечение минимального (максимального) элемента (Extraction): Корень кучи, который содержит наименьший (наибольший) элемент, извлекается. Затем последний элемент заменяет корень, и куча перестраивается вниз, чтобы восстановить условия приоритета.

3. Получение минимального (максимального) элемента без извлечения (Peek): Возвращает значение корневого элемента (с наивысшим приоритетом), не удаляя его из кучи.

4. Изменение приоритета: В некоторых реализациях `PriorityQueue` можно изменять приоритет элементов, что может потребовать переупорядочивания элементов в куче.

Бинарные кучи обеспечивают эффективное выполнение операций вставки и извлечения элементов с наивысшим приоритетом, обычно за время O(log n), где n - количество элементов в куче. Это делает `PriorityQueue` полезной структурой данных для решения задач, связанных с приоритетами, таких как планирование задач, поиск наименьшего (наибольшего) элемента и др.

public interface Queue<E> extends Collection<E>

Queue – это односторонняя очередь, когда элементы можно получить в том порядке, в котором добавляли. FIFO (первым вошёл, первым вышел).

Согласно Javadoc очереди, очередь добавляет следующие методы:

<img width="1034" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/98dc7fd2-5ebd-4d3c-b4aa-4a9327f38d5c">

[к оглавлению](#коллекции)

## Что такое Dequeue? Чем отличается от Queue?

Deque (Double Ended Queue) расширяет Queue и согласно документации, это линейная коллекция,поддерживающая вставку/извлечение элементов с обоих концов. Помимо этого, реализации интерфейса Deque могут строится по принципу FIFO, либо LIFO.

Реализации и Deque, и Queue обычно не переопределяют методы equals() и hashCode(), вместо этого используются унаследованные методы класса Object, основанные на сравнении ссылок.

Deque (Double Ended Queue) – это двусторонняя очередь, т.е. можно вставлять/получать элементы как из начала, так и с конца. Расширяет Queue.
Согласно документации, это линейная коллекция, поддерживающая вставку/извлечение элементов с обоих концов (реализация: LIFO, либо FIFO).

Реализации и Deque, и Queue обычно НЕ переопределяют методы equals() и hashCode(), вместо этого используются унаследованные методы класса Object, основанные на сравнении ссылок.

`Queue` является интерфейсом в Java, представляющим структуру данных "очередь" (FIFO - First In, First Out). Он определяет методы для добавления, удаления и получения элементов из очереди. Сравнение или хеширование элементов в очереди может не иметь смысла, поскольку их расположение и порядок в очереди являются главными атрибутами для этой структуры данных. Когда мы работаем с очередью, обычно нам не важно сравнивать ее содержимое на равенство или получать уникальный хеш каждого элемента. Поэтому в интерфейсе `Queue` нет объявления методов `equals()` и `hashCode()`. Однако реализации конкретных классов, которые реализуют этот интерфейс, могут переопределить эти методы в соответствии с своими потребностями.

Вывод: Классы выбирают, переопределять или не переопределять методы `equals()` и `hashCode()` в зависимости от того, какие семантики сравнения или хеширования им нужны для правильной работы со своими данными. В случае с `Queue`, такие методы, как правило, не требуются, потому что они ориентированы на управление порядком элементов, а не на их содержимое. 

Реализации интерфейсов Deque и Queue в Java обычно не переопределяют методы `equals()` и `hashCode()` по нескольким причинам:

1. Сравнение содержимого: Метод `equals()` используется для сравнения содержимого двух объектов и определения, равны ли они. В случае Deque и Queue, сравнение содержимого не всегда имеет смысл, так как объекты могут содержать разные элементы, но по-прежнему считаться эквивалентными. Например, две очереди или деки с одним и тем же набором элементов могут быть реализованы с использованием разных внутренних структур данных, что может привести к различиям в их хэш-кодах.

2. Изменяемость и порядок элементов: Deque и Queue могут быть изменяемыми структурами данных, и их содержимое может меняться с течением времени. В таких случаях переопределение `equals()` и `hashCode()` может вызвать проблемы согласованности хэш-кодов, если элементы изменяются во время хранения в хэш-таблице или при использовании в других структурах данных.

3. Интерфейсные различия: Deque и Queue предоставляют различные контракты и методы, которые могут не соответствовать ожидаемым поведениям в методах `equals()` и `hashCode()`. Например, Queue поддерживает методы, связанные с операциями вставки и удаления элементов из начала или конца очереди, что может привести к различиям в поведении, которое обычно ожидается от методов `equals()` и `hashCode()`.

4. Общее использование: Обычно Deque и Queue используются в качестве структур данных для управления элементами в определенном порядке. Отношение эквивалентности элементов может быть определено с учетом только их значений, но не самих структур данных. Это означает, что стандартные реализации `equals()` и `hashCode()`, которые определены в базовом классе `Object`, будут работать достаточно хорошо для таких случаев.

Если вам все же нужно выполнить сравнение содержимого двух Deque или Queue, вы можете вручную перебрать элементы и сравнить их поочередно. Однако обратите внимание, что переопределение `equals()` и `hashCode()` для изменяемых структур данных может быть нетривиальной задачей и должно быть сделано осторожно, чтобы избежать проблем согласованности и производительности.

Queue – это односторонняя очередь, которая обычно (но необязательно) строится по принципу FIFO (First-In-First-Out). Соответственно извлечение элемента осуществляется с начала очереди, а вставка элемента в конец очереди.

<img width="460" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/206e53c9-0dd0-4800-80d5-378d424be61b">

Хотя этот принцип нарушает, к примеру PriorityQueue, использующая «natural ordering» или переданный Comparator при вставке нового элемента.

<img width="1063" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/a4ee4627-189b-42b3-8c1a-7d2f962a91b7">

Отличие между `Deque` и `Queue` заключается в поддерживаемых операциях. В частности:

1. `Queue` - поддерживает операции добавления элементов только в конец очереди (`offer()` или `add()`) и удаления элементов только из начала очереди (`poll()` или `remove()`). Это соответствует структуре данных "очередь" (FIFO).

2. `Deque` - поддерживает операции добавления и удаления элементов как в начало, так и в конец очереди. Таким образом, это более гибкая структура данных, которая может использоваться как стек (LIFO) или очередь (FIFO), в зависимости от способа использования методов.

[к оглавлению](#коллекции)

## Приведите пример реализации Dequeue.

[Поясняющее видео на ютуб](https://youtu.be/5_f5foEXiYY)

LinkedList, а еще ->

ArrayDeque (также известный как «Array Double Ended Queue», произносится как «ArrayDeck») - это особый вид растущего массива, который позволяет нам добавлять или удалять элементы с обеих сторон.

Реализация ArrayDeque может использоваться как Stack (последний пришел-первый вышел) или Queue (первый пришел-первый вышел) 

Под капотом ArrayDeque поддерживается массив, который удваивает свой размер при заполнении.

Первоначально, массив инициализируется с размером 16. Он реализован как двусторонняя очередь, где он поддерживает два указателя, а именно голову и хвост.

ArrayDeque:
+ Это не потокобезопасный 
+ Нулевые элементы не принимаются (так как методы этого класса (например, poll() — удаление элемента из начала очереди) используют null как признак пустоты коллекции)
+ Работает значительно быстрее, чем синхронизированный Stack
+ Более быстрая очередь, чем LinkedList из-за лучшей локализации. Большинство операций амортизировали сложность с постоянным временем
+ Iterator , возвращаемый ArrayDeque , является отказоустойчивым
+ ArrayDeque автоматически удваивает размер массива, когда head и хвостовой указатель встречает друг друга при добавлении элемента
```java
Deque<Integer> stack = new ArrayDeque<>(); 

stack.push(1); 
stack.push(2); 
stack.push(3); 

while (!stack.isEmpty()) { 

System.out.println(stack.pop()); 

} 

Результат: 

3 

2 

1
```
Еще немного про null значения:

> Реализации очереди могли быть разработаны так, чтобы разрешать записи null, но это было не так. Это компромисс в дизайне: "гибкость", заключающаяся в возможности вставлять записи null, по сравнению с громоздким интерфейсом программирования, заключающимся в необходимости проверять, содержит ли очередь какие-либо элементы, прежде чем вы сможете вызвать метод, который частично используется для определения, содержит ли очередь какие-либо элементы.
>
> Подсказка кроется в названии 'poll'. Если poll не может выполнить 'удалить и вернуть; в противном случае указать, что возвращать нечего', то poll не является полезным методом; проверка на пустоту, за которой следует существующий вызов 'remove', выполняет эту работу.
>
> Поэтому я полагаю, что разработчики очередей имели в виду очередь, которая содержала "вещи", а не отсутствие вещей (т. Е. они восприняли слово буквально) и приняли это ограничение для удобства вызова опроса с одним методом. Короче говоря, ваш ответ (IMO) "да, это причина", но я думаю, что причина веская.
>
> Мне нравится ответ, но все же List не был разработан таким образом, и у него почти такая же функциональность . Там они не придерживались "содержащихся вещей, а не отсутствия вещей".. Я знаю, что это довольно личный вопрос, но тогда почему в List вообще есть null?
>
> Все, что я могу сказать, это то, что с 'queue' и 'list' связана очень разная семантика, даже если существуют структуры данных, которые можно использовать для обоих. Из документа для queue: Коллекция, предназначенная для хранения элементов перед обработкой. и для List: Упорядоченная коллекция (также известная как последовательность). … Пользователь может обращаться к элементам по их целочисленному индексу Интерфейсы предназначены для удовлетворения различных потребностей. Что касается того, почему List разрешает нули: поскольку отсутствует необходимость в методе poll(), нет причин запрещать нули. "Метод poll()" - это не та концепция, которая действительно сочетается со "списком".

Выводы

На основании рассмотренных нами интерфейсов и реализаций можно сделать вывод, что для самой простой реализации очереди Queue следует выбрать LinkedList. Eсли требуется как-то сортировать элементы внутри очереди, то подойдёт PriorityQueue. Если же нам нужна функциональность стека, то надо использовать интерфейс Deque и одну из его реализаций: LinkedList или ArrayDeque

Например, класс ArrayDeque<E>.

Этот класс представляют обобщенную двунаправленную очередь, наследуя функционал от класса AbstractCollection и применяя интерфейс Deque.

В классе ArrayDeque определены следующие конструкторы:
+	ArrayDeque(): создает пустую очередь
+	ArrayDeque(Collection<? extends E> col): создает очередь, наполненную элементами из коллекции col
+	ArrayDeque(int capacity): создает очередь с начальной емкостью capacity.
Если мы явно не указываем начальную емкость, то емкость по умолчанию будет равна 16

Пример использования класса:

<img width="536" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/11e5b823-564f-4150-a323-5058710733b0">

`ArrayDeque` и `ArrayList` оба представляют собой динамические структуры данных в Java. Однако, хотя они имеют схожие названия и могут путать, они обладают разными свойствами и предназначены для разных целей.

`ArrayList` — это список, реализованный в виде динамического массива. Это означает, что `ArrayList` внутренне использует обычный массив для хранения элементов, и при необходимости он может изменять свой размер, чтобы вместить больше элементов. Однако операции добавления и удаления элементов из середины списка или в начале списка могут быть дорогими, так как требуется перемещение всех элементов, расположенных после добавляемого или удаляемого элемента.

`ArrayDeque`, с другой стороны, реализует двустороннюю очередь, также известную как дек (deque). Это структура данных, которая позволяет добавлять и удалять элементы как с начала, так и с конца очереди за константное время. Внутренне `ArrayDeque` не использует один большой массив, как `ArrayList`, но скорее использует массивы меньшего размера в качестве блоков, связанных между собой. Это позволяет быстро выполнять операции добавления и удаления как в начале, так и в конце дека.

Таким образом, хотя обе структуры данных имеют некоторое сходство, `ArrayDeque` более оптимизирована для операций добавления и удаления элементов как в начале, так и в конце, в то время как `ArrayList` больше подходит для случаев, когда требуется простой список с операциями доступа по индексу.

[к оглавлению](#коллекции)

## Какая коллекция реализует FIFO? 

Queue

FIFO - First-In-First-Out (первый пришел, первым ушел). По этому принципу обычно построена такая структура данных, как очередь (java.util.Queue).

[к оглавлению](#коллекции)

## Какая коллекция реализует LIFO?

<img width="211" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/8c2a668b-f552-4d0d-9aa8-c3081aff7d65">

Еще LinkedList и ArrayDeque

Stack работает по схеме LIFO (последним вошел, первым вышел, как стопка книг). Всякий раз, когда вызывается новый метод, содержащий примитивные значения или ссылки на объекты, то на вершине стека под них выделяется блок памяти.

Stack реализует дополнительные методы: peek (взглянуть, посмотреть), pop (вытолкнуть), push (затолкать).

Класс Vector является поток безопасным. Это означает, что, если один поток работает над Vector, ни один другой поток не сможет его удержать. В отличие от ArrayList, только один поток может выполнять операцию по вектору за раз. ArrayList не синхронизирован, что означает, что в ArrayList одновременно могут работать несколько потоков. Таким образом, вы не получите исключение ConcurrentModificationException. Если потоковая реализация не нужна, рекомендуется использовать ArrayList вместо Vector.

Значение Vector по умолчанию удваивает размер его массива, в то время как ArrayList увеличивает его размер массива на 50 процентов. В зависимости от того, как вы используете эти классы, вы можете получить большой удар производительности при добавлении новых элементов.

Кстати, на понимание стэков есть интересная задача, описанная в книге "Карьера программиста" (Cracking Coding Interview) Используя структуру "стэк" (LIFO) нужно реализовать структуру "очередь" (FIFO). Вот как это можно сделать:

<img width="968" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/a6b3d1a2-90e7-42ed-832e-029d31bf2d3b">

В Java коллекция, реализующая LIFO (Last-In-First-Out), называется стеком (Stack). Стек представляет собой структуру данных, в которой последний добавленный элемент будет первым, который будет удален. Стек в Java реализован с использованием класса `java.util.Stack`.

Однако следует отметить, что в современных версиях Java рекомендуется вместо `Stack` использовать класс `java.util.ArrayDeque`, который также может быть использован как стек и как двусторонняя очередь (Deque). `ArrayDeque` предоставляет более эффективную реализацию стека и поддерживает более широкий спектр операций.

Пример использования `ArrayDeque` в качестве стека:

```java
import java.util.ArrayDeque;
import java.util.Deque;

public class StackExample {
    public static void main(String[] args) {
        Deque<Integer> stack = new ArrayDeque<>();

        stack.push(1);    // Добавление элемента на вершину стека
        stack.push(2);
        stack.push(3);

        System.out.println(stack.pop());  // Удаление и получение элемента с вершины стека (3)
        System.out.println(stack.pop());  // Удаление и получение элемента с вершины стека (2)
    }
}
```

В этом примере мы использовали методы `push()` для добавления элементов на вершину стека и `pop()` для удаления элементов с вершины стека.

Класс `java.util.Vector` также реализует структуру данных стека, а именно LIFO (Last-In-First-Out). Vector представляет собой динамический массив объектов, который автоматически увеличивается по мере необходимости. Он является одной из старых коллекций Java и был представлен в более ранних версиях Java.

Важно отметить, что хотя Vector предоставляет реализацию стека, в современных приложениях обычно рекомендуется предпочитать `ArrayDeque` или `LinkedList` вместо `Vector`. В частности, `ArrayDeque` предоставляет более эффективную реализацию стека, а также других структур данных, и в большинстве случаев работает быстрее и требует меньше памяти.

[к оглавлению](#коллекции)

## Оцените количество памяти на хранение одного примитива типа byte в LinkedList?

Каждый элемент LinkedList хранит ссылку на предыдущий элемент, следующий элемент и ссылку на данные.
```java
private static class Node<E> {	// 8 байт
E item;	// 4 байта
Node<E> next;	// 4 байта
Node<E> prev;	// 4 байта
//...	Итого 24 байта (кратно 8) для хранения элемента в списке
}
```
Плюс 16 байт для хранения упакованного объекта Byte (8 байт заголовок и 8 байт для значений из пула int). Итого 40 байт для 32-битной JVM
Итого 64 байта для 64-битной JVM

Для 32-битных систем каждая ссылка занимает 32 бита (4 байта). Сам объект (заголовок) вложенного класса Node занимает 8 байт. 4 + 4 + 4 + 8 = 20 байт, а т.к. размер каждого объекта в Java кратен 8, соответственно получаем 24 байта. Примитив типа byte занимает 1 байт памяти, но в 

JCF примитивы упаковываются: объект типа Byte занимает в памяти 16 байт (8 байт на заголовок объекта, 1 байт на поле типа byte и 7 байт для кратности 8). Также напомню, что значения от -128 до 127 кэшируются и для них новые объекты каждый раз не создаются. Таким образом, в x32 JVM 24 байта тратятся на хранение одного элемента в списке и 16 байт - на хранение упакованного объекта типа Byte. Итого 40 байт. 

Для 64-битной JVM каждая ссылка занимает 64 бита (8 байт), размер заголовка каждого объекта составляет 16 байт (два машинных слова). Вычисления аналогичны: 8 + 8 + 8 + 16 = 40байт и 24 байта (объект). Итого 64 байта.

[к оглавлению](#коллекции)

## Оцените количество памяти на хранение одного примитива типа byte в ArrayList?

ArrayList основан на массиве, для примитивных типов данных осуществляется автоматическая упаковка значения, поэтому 16 байт тратится на хранение упакованного объекта и 4 байта (8 для x64) - 

на хранение ссылки на этот объект в самой структуре данных. Таким образом, в x32 JVM 4 байта используются на хранение одного элемента и 16 байт - на хранение упакованного объекта типа Byte.

Для x64 - 8 байт и 24 байта соотвтетсвенно.

х32=20байт 

х64=32байт

[к оглавлению](#коллекции)

## Как устроена HashMap, сложность основных операций? (Расскажите про принцип корзин)

Хабр - https://habr.com/ru/articles/128017/

![image](https://github.com/Oknel-Vap/Interview_questions/assets/116596752/481825bd-4366-46f7-af74-cab7cfb1fe3d)

<img width="601" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/3c4a4d3b-d653-43a4-b2f4-d0c2ac7d6b98">

Hashtable — реализация такой структуры данных, как хэш-таблица. Она не позволяет использовать null в качестве значения или ключа. Эта коллекция была реализована раньше, чем Java Collection Framework, но в последствии была включена в его состав. Как и другие коллекции из Java 1.0, Hashtable является синхронизированной (почти все методы помечены как synchronized). Из-за этой особенности у неё имеются существенные проблемы с производительностью и, начиная с Java 1.2, в большинстве случаев рекомендуется использовать другие реализации интерфейса Map ввиду отсутствия у них синхронизации.

HashMap — коллекция является альтернативой Hashtable. Двумя основными отличиями от Hashtable являются то, что HashMap не синхронизирована и HashMap позволяет использовать null как в качестве 

ключа, так и значения. Так же как и Hashtable, данная коллекция не является упорядоченной: порядок хранения элементов зависит от хэш-функции. Добавление элемента выполняется за константное время O(1), но время удаления, получения зависит от распределения хэш-функции. В идеале является константным, но может быть и линейным O(n).

LinkedHashMap — это упорядоченная реализация хэш-таблицы. Здесь, в отличии от HashMap, порядок итерирования равен порядку добавления элементов. Данная особенность достигается благодаря двунаправленным связям между элементами (аналогично LinkedList). Но это преимущество имеет также и недостаток — увеличение памяти, которое занимет коллекция.

TreeMap — реализация Map основанная на красно-чёрных деревьях. Как и LinkedHashMap является упорядоченной. По-умолчанию, коллекция сортируется по ключам с использованием принципа \"natural ordering\", но это поведение может быть настроено под конкретную задачу при помощи объекта Comparator, который указывается в качестве параметра при создании объекта TreeMap.

WeakHashMap — реализация хэш-таблицы, которая организована с использованием weak references. Другими словами, Garbage Collector автоматически удалит элемент из коллекции при следующей сборке мусора, если на ключ этого элеметна нет жёстких ссылок.

![image](https://github.com/Oknel-Vap/Interview_questions/assets/116596752/2414b519-88fb-4bfa-a415-9cb9db4da4f9)

![image](https://github.com/Oknel-Vap/Interview_questions/assets/116596752/1b54cb58-022d-400f-aa12-5cb4fc3a39e6)

HashMap<K,V> - это КЛАСС в Java коллекции интерфейсов и классов (Java Collection Framework), который реализует interface Map<K,V> ( пары ключей и значений (key & value)):
+	КЛЮЧИ элементов должны быть уникальными (и IMUTEABLE), может быть null.
+	ЗНАЧЕНИЯ элементов могут повторяться. Значение может быть null.

HashMap НЕ запоминает порядок добавления элементов в коллекцию.

НЕ синхронизируемая! Нельзя использовать в условиях многопоточности, для этого есть ConcurrentHashMap.

Почему так популярен? HashMap быстро работает, и большинство операций выполняется за фиксированное или константное O(1) время благодаря оптимизированному доступу к данным.

«КАК ЭТО УСТРОЕНО?» — часто спрашивают, посмотреть видео https://youtu.be/kk_9md24Ttk

**Словарик HashMap**

Хеш-таблица – это структура данных, реализующая интерфейс ассоциативного массива (абстрактная модель «ключ – значение» или entry), которая обеспечивает очень быструю вставку и поиск: независимо от количества элементов вставка и поиск (а иногда и удаление) выполняются за время, близкое к константе – O(1).

Хеш-функция hashCode() задаёт связь между значением элемента и его позицией в хеш- таблице.

Table — массив типа Entry[] (вход), который является хранилищем для элементов корзин/бакетов (хранящих ссылки на списки/цепочки значений).

Size — Количество нод/узлов HashMap-а (не путать с ёмкостью массива).

<img width="454" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/0ce11623-555b-4d78-82a3-4e658187b962">

Capacity – это ёмкость созданного массива Entry[], значение по умолчанию 16 элементов (идентификатор от 0 до 15 мест для корзин или бакетов). Укажем больше, будет больше.

Корзины или бакеты («buckets») – это элементы массива (ячейки), которые используются для хранения отдельно взятых узлов (или цепочек узлов).

Внутри каждой ячейки массива (корзины или бакета) лежит односвязный список LinkedList, либо лежит красное-черное дерево при перестроении (класс TreeMap). Максимальная длина связанного списка – цепочка узлов из 8 значений.

Узел представляет собой объект вложенного (в класс HashMap) класса Node (или TreeNode при древовидной структуре), имплементирует интерфейс Map.Entry<K,V>, содержит поля: hash, key, value, next.

LoadFactor — коэффициент загрузки. Значение по умолчанию 0.75 является хорошим компромиссом между временем доступа и объемом хранимых данных; Чем больше LoadFactor, тем больше экономия памяти под массив, но поиск элемента будет занимать также больше времени.

Вы можете указать свои емкость и коэффициент загрузки, используя конструкторы HashMap(capacity) и HashMap(capacity, loadFactor). Максимальная емкость, которую вы сможете установить, равна половине максиального значения int. Почему? Тип данных хэш-кода.

Threshold — предельное количество элементов, при достижении которого, размер хэш- таблицы увеличивается вдвое, рассчитывается по формуле (capacity * loadFactor).

**Структура**

<img width="733" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/98f2271a-0416-4ca5-9d88-754634c85b55">

В основе HashMap лежит массив. Элементами этого массива являются структуры односвязного списка LinkedList, которые заполняются элементами.

При помещении нового элемента (k/v), ищется нужная корзина. Если в корзине пусто, то помещаем туда новый объект.

Если занято, то находим нужную корзину и проверяем первый объект, который там лежит.
+	Если такой элемент в цепочке существует, его значение перезаписывается.
+	Если место занято и объект не совпадает с нашим, то размещаем наш объект в следующем узле (она же нода, она же entry) в цепочке списка одной корзины (см. №3), для добавления нового узла/ноды будет вызван метод addEntry().

Нода содержит поля и хранит инфо: hash, key, value, next (ссылка на следующий узел). 

**Хэш-код**

Перед тем, как что-то сделать с объектом вычисляется его НОВЫЙ хэш-код. Для генерации используется  метод hash(hashCode), в  который передается key.hashCode().

<img width="1167" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/2991183a-3cd5-42e8-be74-fb256d557fe5">

Почему бы просто не вычислить код с помощью hashCode()?

Это сделано из-за того, что hashCode() можно реализовать так, что только нижние биты int'a будут заполнены. Например, для Integer, Float – если мы в HashMap кладем маленькие значения, то у них и биты хеш-кодов будут заполнены только нижние. В таком случае ключи в HashMap будут иметь тенденцию скапливаться в нижних ячейках, а верхние будут оставаться пустыми, что не очень эффективно.

На то, в какой бакет попадёт новая запись, влияют только младшие биты хеша. Поэтому и придумали различными манипуляциями подмешивать старшие биты хеша в младшие, чтобы улучшить распределение по бакетам (чтобы старшие биты родного хеша объекта начали вносить коррективы в то, в какой бакет попадёт объект) и, как следствие, производительность. Потому и придумана дополнительная функция hash внутри HashMap.

Пример (h – hashcode):

<img width="1190" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/a42775a2-ceba-42a8-962d-fa607bf096db">

Вопрос: как узнать, в какую корзину попадёт элемент, если значение его хэш-кода 51?

Ответ: остаток от деления на кол-во корзин (т.к. 51 % 16 = 3 (проверка 3 * 16 = 48 + 3)) 

**Как происходит сравнение при добавлении элемента? Аналогично при поиске (получить).**

Рассчитав и зная индекс в массиве, мы получаем список (цепочку) элементов, привязанных к этой корзине (ячейке). Хэш и ключ нового элемента поочередно сравниваются с хэшами и ключами элементов из списка и, при совпадении этих параметров, значение элемента перезаписывается.

Сравниваем КЛЮЧ нашего объекта с первым в цепочке объектом:

<img width="647" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/94193c3f-6958-4406-9f58-51ba9b00f7a6">

+ проверка по хэшу (хэш ключа, естественно)
+	ссылочное сравнение (ключей)
+	если предыдущий пункт выдал false, то проверка на equals (иногда задают вопрос, где используется equals при добавлении объекта в мапу. Вот тут как раз)))
Т.к. equals - дорогая операция, поэтому в самом конце)

 Если же предыдущий шаг не выявил совпадений, будет вызван метод addEntry(hash, key, value, index) для добавления нового элемента.

 <img width="424" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/bec753fc-207c-47f4-af71-b535f2dc4591">

Если при добавлении элемента в качестве ключа был передан null, действия будут отличаться. Будет вызван метод putForNullKey(value), внутри которого нет вызова методов hash() и indexFor() (потому как все элементы с null-ключами всегда помещаются в корзину[0]), но есть такие действия:

+ Все элементы цепочки, привязанные к корзине[0], поочередно просматриваются в поисках элемента с ключом null.
+ Если такой элемент в цепочке существует, его значение перезаписывается.
+ Если элемент с ключом null не был найден,  будет вызван уже знакомый метод addEntry().

<img width="410" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/854e7893-f87b-4856-bd2c-d425e8639742">

**Если при добавлении элемента возникает коллизия.**

Ситуация, когда разные ключи попадают в один и тот же бакет (даже с разными хешами), называется коллизией или столкновением. Даже если хеш-таблица больше, чем набор данных, и была выбрана хорошая хеш-функция, это не гарантирует того, что коллизии не возникнут. Да и значение хеша ограничено диапазоном значений типа int (порядка 4 млрд.). Полученное новое значение также нужно куда-то записать, и для этого нужно определить, куда именно оно будет записано. Это называется решением коллизии.

Существует два подхода:

**external chaining или метод цепочек (реализован в HashMap)** — т.е. в ячейке на самом деле содержится список (chain). А уже в списке может содержаться несколько значений (не обязательно с одинаковым хеш-кодом).

**linear probing или метод открытой адресации (реализован в IdentityHashMap)** – заключается в поиске первой пустой ячейки после той, на которую указала хеш-функция;

[к оглавлению](#коллекции)

##  Что такое бинарное дерево?

Двоичное дерево — структура данных, в которой каждый узел (родительский) имеет не более двух потомков (правый и левый наследник).

<img width="1174" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/95708a94-0d8b-46e6-b183-cc73c68072f9">

Двоичное дерево поиска строится по определенным правилам:
+	каждый узел имеет не более двух детей;
+	каждое значение, меньшее, чем значение узла, становится левым ребенком или ребенком левого ребенка; 

[к оглавлению](#коллекции)

## Когда и как происходит перестроение мапы в дерево?

Первоначальный размер HashMap = 16 бакетов (напомню, бакет – это ячейка массива).
Когда массив заполняется на 75%, то есть заполняются 12/16 бакетов (16*0,75 = 12, т.к. loadFactory = 0,75), размер массива увеличивается в 2 раза, т.е. становится 32 бакета.

И так далее (64, 128 …). При увеличении размера массива все объекты, уже содержащиеся в HashMap, будут перераспределены по новым бакетам, с учётом их нового количества.
Каждый бакет содержит в себе ноды (пары ключ-значение), когда нодов становится 8, а бакетов 64, то структура Node перестраивается в красно-черное дерево (TreeNode).

Обратное перестроение TreeNode Node случается, если количество нод в цепочке <6 Протестировать визуализацию дерева https://www.cs.usfca.edu/~galles/visualization/RedBlack.html

[к оглавлению](#коллекции)

##  Каковы особенности красно-чёрного дерева?

<img width="505" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/fc9f7c6a-bdc3-4d61-828c-16d26b0b0d63">

+	Оба поддерева являются бинарными деревьями поиска
+	Левые потомки должны быть меньше своего корневого узла, а правый узел всегда больше левого или равен ему (за счёт этого обеспечивается быстрый бинарный поиск)
+	Каждый узел окрашен либо в красный, либо в черный цвет  (в структуре данных узла появляется доп. поле – бит цвета).
+	Корень и листья (так называемые NULL-узлы) окрашены в черный цвет.
+	Каждый красный узел должен иметь два черных дочерних узла. Красные узлы в качестве дочерних могут иметь только черные.
+	Пути от узла к его листьям должны содержать одинаковое количество черных узлов (это черная высота).
+	При нарушении этого порядка дерево перебалансируется.

Про одинаковые элементы (почему идет в правую часть, а не в левую, как везде пишут), в коде реализации красно-черного дерева в java написано:

<img width="315" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/24b0b841-89fe-4263-a362-336b5ac467a8">

при осуществлении поиска, если ключ меньше, то идем налево, иначе направо. То же самое указано и при вставке элемента (https://github.com/Bibeknam/algorithmtutorprograms/blob/master/data-structures/red-black-trees/RedBlackTree.java)

[к оглавлению](#коллекции)

## Сложность основных операций HashMap?

Что имеется в виду? https://javarush.ru/groups/posts/2496-podrobnihy-razbor-klassa-hashmap

<img width="1129" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/d978b84d-91d8-45ed-83c0-3e92313793d5">

Красная зона – ужасно O(n^2); O(2^n); O(n!) Оранжевая – плохо: O(n log n)

Жёлтая – справедливо, оправдано: O(n) или линейное время Салатовый – хорошо O(log n)

Зелёный – превосходно! О(1) или константа

Сравнение производительности разных коллекций по ссылке (аккуратно, можно зависнуть): https://www.bigocheatsheet.com/

<img width="1176" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/46a16c44-8bee-41e5-87da-f7b735c7e675">

Что происходит внутри HashMap.put()?

+	Вычисляется хэш ключа. Если ключ null, хэш считается равным 0. Чтобы достичь лучшего распределения, результат вызова hashCode() «перемешивается»: его старшие 
биты XOR-ятся на младшие. XOR (^) – это математический оператор. Применяется к логическим операциям.
+ Значения внутри хэш-таблицы хранятся в специальных структурах данных – нодах, в массиве. Из хэша высчитывается номер бакета – индекс для значения в этом массиве. Полученный хэш обрезается по текущей длине массива. Длина – всегда степень двойки, так что для скорости используется битовая операция &.
+	В бакете ищется нода. В ячейке массива лежит не просто одна нода, а связка всех нод, которые туда попали. Исполнение проходит по этой связке (цепочке или дереву), и ищет ноду с таким же ключом. Ключ сравнивается с имеющимися сначала на ==, затем на equals.
+	Если нода найдена – её значение просто заменяется новым. Работа метода на этом завершается.
+	Если ноды с таким же ключом в бакете пока нет – добавляемая пара ключ- значение запаковывается в новый объект типа Node, и прикрепляется к структуре существующих нод бакета. Ноды составляют структуру за счет того, что в ноде хранится ссылка на следующий элемент (для дерева – следующие элементы). Кроме самой пары и ссылок, чтобы потом не считать заново, записывается и хэш ключа.
+ В случае, когда структурой была цепочка, а не дерево, и длина цепочки превысила 7 элементов – происходит процедура treeification – превращение списка в самобалансирующееся дерево. В случае коллизии это ускоряет доступ к элементам на чтение с O(n) до O(log(n)). У comparable-ключей для балансировки используется их естественный порядок. Другие ключи балансируются по порядку имен их классов и значениям identityHashCode-ов. Для маленьких хэш-таблиц (< 64 бакетов) «одеревенение» заменяется увеличением (см. п.8).
+ Если новая нода попала в пустую ячейку, заняла новый бакет – увеличивается счетчик структурных модификаций. Изменение этого счетчика сообщит всем итераторам контейнера, что при следующем обращении они	должны выбросить ConcurrentModificationException.
+ Когда количество занятых бакетов массива превысило пороговое (capacity * load factor), внутренний массив увеличивается вдвое, а для всего содержимого выполняется рехэш – все имеющиеся ноды перераспределяются по бакетам по тем же правилам, но уже с учетом нового размера.

Закрепление или самопроверка https://itsobes.ru/JavaSobes/tags/kollektsii/

<img width="1154" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/64ae109f-5827-4368-bfec-df4a28279380">

[к оглавлению](#коллекции)

## Что такое LinkedHashMap?

Хабр - https://habr.com/ru/articles/129037/

LinkedHashMap - упорядоченная реализация хэш-таблицы. Здесь, в отличии от HashMap, порядок итерирования равен порядку добавления элементов.

Данная структура может слегка уступать по производительности родительскому HashMap, при этом время выполнения операций add(), contains(), remove() остается константой — O(1). Понадобится чуть больше места в памяти для хранения элементов и их связей, но это совсем небольшая плата за дополнительные фишечки. Он также принимаетнулевой ключ, а также нулевые значения.

LinkedHashMap не синхронизирована.

Вообще, из-за того что всю основную работу на себя берет родительский класс, серьезных отличий в реализации HashMap и LinkedHashMap не много. Можно упомянуть о парочке мелких:

+ Методы transfer() и containsValue() устроены чуть проще из-за наличия двунаправленной связи между элементами;
+ В классе LinkedHashMap.Entry реализованы методы recordRemoval() и recordAccess() (тот самый, который помещает элемент в конец при accessOrder = true). В HashMap оба этих метода пустые.
```java
Map<Integer, String> linkedHashMap = new LinkedHashMap<Integer, String>(); linkedHashMap.put(1, "obj1");
linkedHashMap.put(15, "obj15");
```
![image](https://github.com/Oknel-Vap/Interview_questions/assets/116596752/45b9d8c7-0062-4862-a694-cf8b140b406b)

Только что созданный объект linkedHashMap, помимо свойств унаследованных от HashMap (такие как table, loadFactor, threshold, size, entrySet и т.п.), так же содержит два доп. свойства:

+ header — «голова» двусвязного списка. При инициализации указывает сам на себя;
+ accessOrder — указывает каким образом будет осуществляться доступ к элементам при использовании итератора. При значении true — по порядку последнего доступа. При значении false доступ осуществляется в том порядке, в каком элементы были вставлены.

Реализация LinkedHashMap отличается от HashMap поддержкой двухсвязного списка, определяющего порядок итерации по элементам структуры данных. По умолчанию элементы списка упорядочены согласно их порядку добавления в LinkedHashMap (insertion-order). Однако порядок итерации можно изменить, установив параметр конструктора accessOrder в значение true. В этом случае доступ осуществляется по порядку последнего обращения к элементу (access-order). Это означает, что при вызове методов get() или put() элемент, к которому обращаемся, перемещается в конец списка. При добавлении элемента, который уже присутствует в LinkedHashMap (т.е. с одинаковым ключом), порядок итерации по элементам не изменяется.

Задачки, что будет в консоли (ответ в жёлтой заливке)? https://youtu.be/5Iu4ZUcrJ0g

+ Порядок в HashMap не гарантируется, в отличие от LinkedHashMap.
+ Поля и конструктор (capacity, loadFactor, order).
+ Класс несинхронизированный (многопоточность не поддерживает).

<img width="1153" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/9e7cd10d-bf52-483a-9693-f5ca8d7fdfea">

<img width="1151" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/9eff143f-9935-4d16-b9c8-f32afd937267">

[к оглавлению](#коллекции)

## Как устроена TreeMap, сложность основных операций?

<img width="322" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/0d035fe3-d605-4c98-84da-d81df3b960ab">

Реализация интерфейса Map — TreeMap позволяет хранить данные в структурированном виде с возможностью навигации.

Древовидная структура: под капотом TreeMap использует структуру данных, которая называется красно-чёрное дерево.

Имплементируя интерфейсы NavigableMap и SortedMap, TreeMap получает дополнительный функционал, которого нет в HashMap, но плата за это — производительность.

Хоть класс TreeMap является самым многофункциональным, он не всегда может хранить null в качестве ключа. Кроме этого, время доступа к элементам TreeMap будет самым длительным. Поэтому если НЕ нужно хранить данные в отсортированном виде, лучше использовать HashMap или LinkedHashMap.

<img width="1106" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/81fe242d-a9c0-4de9-967b-2f1e0b904475">

Пример использования TreeMap: https://javarush.ru/groups/posts/2584-osobennosti-treemap

<img width="1112" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/a4c47f31-1887-4b0b-90c7-2982efe5486e">

Класс TreeMap<K, V> представляет отображение в виде дерева. Он наследуется от класса AbstractMap и реализует интерфейс NavigableMap, а следовательно, также и интерфейс SortedMap. Поэтому в отличие от коллекции HashMap в TreeMap все объекты автоматически сортируются по возрастанию их ключей.

Время доступа и извлечения элементов достаточно мало, что делает класс TreeMap блестящим выбором для хранения больших объемов отсортированной информации, которая должна быть быстро найдена.

Класс TreeMap имеет следующие конструкторы:
```java
TreeMap(): создает пустое отображение в виде дерева
TreeMap(Map<? extends K,? extends V> map): создает дерево, в которое добавляет все элементы из отображения map
TreeMap(SortedMap<K, ? extends V> smap): создает дерево, в которое добавляет все элементы из отображения smap
TreeMap(Comparator<? super K> comparator): создает пустое дерево, где все добавляемые элементы впоследствии будут отсортированы компаратором.
```
Кроме собственно методов интерфейса Map класс TreeMap реализует методы интерфейса NavigableMap. Например, мы можем получить все объекты до или после определенного ключа с помощью методов headMap и tailMap. Также мы можем получить первый и последний элементы и провести ряд дополнительных манипуляций с объектами

SortedMap — интерфейс, который расширяет Map и добавляет методы, актуальные для отсортированного набора данных:
```java
firstKey(): возвращает ключ первого элемента мапы;
lastKey(): возвращает ключ последнего элемента;
headMap(K end): возвращает мапу, которая содержит все элементы текущей, от начала до элемента с ключом end;
tailMap(K start): возвращает мапу, которая содержит все элементы текущей, начиная с элемента start и до конца;
subMap(K start, K end): возвращает мапу, которая содержит все элементы текущей,начиная с элемента start и до элемента с ключом end.
```
NavigableMap — интерфейс, который расширяет SortedMap и добавляет методы для навигации между элементами мапы:
```java
firstEntry(): возвращает первый пару “ключ-значение”;
lastEntry(): возвращает последнюю пару “ключ-значение”;
pollFirstEntry(): возвращает и удаляет первую пару;
pollLastEntry(): возвращает и удаляет последнюю пару;
ceilingKey(K obj): возвращает наименьший ключ k, который больше или равен ключу obj. Если такого ключа нет, возвращает null;
floorKey(K obj): возвращает самый большой ключ k, который меньше или равен ключу obj. Если такого ключа нет, возвращает null;
lowerKey(K obj): возвращает наибольший ключ k, который меньше ключа obj. Если такого ключа нет, возвращает null;
higherKey(K obj): возвращает наименьший ключ k, который больше ключа obj. Если такого ключа нет, возвращает null;
ceilingEntry(K obj): аналогичен методу ceilingKey(K obj), только возвращает пару “ключ-значение” (или null);
floorEntry(K obj): аналогичен методу floorKey(K obj), только возвращает пару “ключ-значение” (или null);
lowerEntry(K obj): аналогичен методу lowerKey(K obj), только возвращает пару “ключ-значение” (или null);
higherEntry(K obj): аналогичен методу higherKey(K obj), только возвращает пару “ключ-значение” (или null);
descendingKeySet(): возвращает NavigableSet, содержащий все ключи, отсортированные в обратном порядке;
descendingMap(): возвращает NavigableMap, содержащую все пары, отсортированные в обратном порядке;
navigableKeySet(): возвращает объект NavigableSet, содержащий все ключи в порядке хранения;
headMap(K upperBound, boolean incl): возвращает мапу, которая содержит пары от начала и до элемента upperBound. Аргумент incl указывает, нужно ли включать элемент upperBound в возвращаемую мапу;
tailMap(K lowerBound, boolean incl): функционал похож на предыдущий метод, только возвращаются пары от lowerBound и до конца;
subMap(K lowerBound, boolean lowIncl, K upperBound, boolean highIncl): как и в предыдущих методах, возвращаются пары от lowerBound и до upperBound, аргументы lowIncl и highIncl указывают, включать ли граничные элементы в новую мапу.
```
[к оглавлению](#коллекции)

## Что такое WeakHashMap?

является реализацией интерфейса Map на основе хеш-таблиц, с ключами из WeakReference тип.

Запись в WeakHashMap будет автоматически удалена, если ее ключ больше не используется в обычном режиме. Это означает, что не существует ни одной ссылки, указывающая на этот ключ. Когда процесс сборки мусора (GC) отбрасывает ключ, его запись эффективно удаляется с карты, поэтому 

этот класс ведет себя несколько иначе, чем другие реализации Map. 

Применение – реализация простого кэша.

<img width="1097" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/2808ac01-5376-46cb-83df-a42f03e41455">

[к оглавлению](#коллекции)

## В чем разница между HashMap и WeakHashMap? Для чего используется WeakHashMap? 

`HashMap` и `WeakHashMap` являются двумя разными реализациями интерфейса `Map` в языке программирования Java. Они имеют схожее назначение - хранение пар "ключ-значение", но имеют разные характеристики и применение.

1. **HashMap**:
   - `HashMap` - это структура данных, которая хранит пары ключ-значение в хэш-таблице.
   - Основное свойство `HashMap` - сильные ссылки на ключи и значения. Это означает, что если объекты, используемые в качестве ключей или значений, больше нигде не используются, они не будут автоматически удалены из `HashMap`. Это может привести к утечкам памяти, если объекты перестают использоваться, но остаются в `HashMap`.

2. **WeakHashMap**:
   - `WeakHashMap` - это специализированная версия `HashMap`, которая использует слабые ссылки на ключи.
   - Основное свойство `WeakHashMap` - слабые ссылки на ключи. Это означает, что если объекты, используемые в качестве ключей, больше нигде не используются и на них есть только слабые ссылки, они могут быть автоматически удалены из `WeakHashMap` сборщиком мусора Java.
   - `WeakHashMap` может быть полезен в случаях, когда вы хотите связать данные с объектами, но не хотите, чтобы эти объекты удерживались в памяти, если на них больше нет сильных ссылок. Примеры включают кэширование, где данные могут быть автоматически выгружены из кэша, если нет других сильных ссылок на ключи.

Использование `WeakHashMap` особенно ценно в ситуациях, где объекты-ключи могут быть временно или динамически создаваемыми, и вы хотите избежать утечек памяти при их автоматическом удалении, когда на них больше нет активных ссылок.

Коротко говоря, `HashMap` подходит для общих случаев хранения данных, а `WeakHashMap` полезен, когда вам нужно связать данные с объектами, но не хотите предотвращать сборку мусора и хотите, чтобы объекты автоматически удалялись, когда на них больше нет сильных ссылок.

В Java существует 4 типа ссылок:
+	сильные (Strong reference)
+	мягкие (SoftReference)
+	слабые (WeakReference)
+	фантомные (PhantomReference)

Особенности каждого типа ссылок связаны с работой Garbage Collector. Если объект можно достать только с помощью цепочки WeakReference (то есть на него отсутствуют сильные и мягкие ссылки), то данный объект будет помечен на удаление.

WeakHashMap — это структура данных, реализующая интерфейс Map и основанная на использовании WeakReference для хранения ключей. Таким образом, пара «ключ-значение» будет удалена из WeakHashMap, если на объект- ключ более не имеется сильных ссылок.

> В качестве примера использования такой структуры данных можно привести следующую ситуацию: допустим имеются объекты, которые необходимо расширить дополнительной информацией, при этом изменение класса этих объектов нежелательно, либо невозможно. Добавляем каждый объект в WeakHashMap в качестве ключа, а в качестве значения - нужную информацию. Пока на объект имеется сильная ссылка (либо мягкая), можно проверять хэш-таблицу и извлекать информацию. Как только объект будет удален, то WeakReference для этого ключа будет помещен в ReferenceQueue и затем соответствующая запись для этой слабой ссылки будет удалена из WeakHashMap.

В WeakHashMap используются WeakReferences, а почему бы не создать SoftHashMap на SoftReferences?

SoftHashMap представлена в сторонних библиотеках, например, в Apache Commons.

В WeakHashMap используются WeakReferences, а почему бы не создать PhantomHashMap на PhantomReferences?

PhantomReference при вызове метода get() возвращает всегда null (объект недостижим), поэтому тяжело представить назначение такой структуры данных. Фантомные ссылки — это безопасный способ узнать, что объект удален из памяти.

[к оглавлению](#коллекции)

## Как работает HashMap при попытке сохранить в него два элемента по ключам с одинаковым hashCode(), но для которых equals() == false?

По значению hashCode() вычисляется индекс ячейки массива, в список которой этот элемент будет добавлен. Перед добавлением осуществляется проверка на наличие элементов в этой ячейке. Если элементы с таким hashCode() уже присутствует, но их equals() методы не равны, то элемент будет добавлен в конец списка.

[к оглавлению](#коллекции)

## Что будет, если мы кладем в HashMap ключ, у которого equals и hashCode определены некорректно?

Некорректно equals и hashcode - не найдем корзину и не найдем элемент.

Если некорректно equals – как минимум найдем корзину хэш-таблицы, в которой объект будет лежать, Если некорректно hascode - помещая некий объект в хэш-таблицу, мы рискуем не получить его обратно по ключу.

<img width="1089" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/87e8aa87-cf89-4847-80de-3ad2ae3a9da7">

[к оглавлению](#коллекции)

## Возможна ли ситуация, когда HashMap выродится в список даже с ключами имеющими разные hashCode()?

Это возможно в случае, если метод indexFor(hash, tableLength), определяющий номер корзины будет возвращать одинаковые значения. 

[к оглавлению](#коллекции)

## Почему нельзя использовать byte[] в качестве ключа в HashMap?

Хэш-код массива не зависит от хранимых в нем элементов, а присваивается при создании массива (метод вычисления хэш-кода массива не переопределен и вычисляется по стандартному Object.hashCode() на основании адреса массива).

Также у массивов не переопределен equals и выполняется сравнение указателей. Это приводит к тому, что обратиться к сохраненному с ключом-массивом элементу не получится при использовании другого массива такого же размера и с такими же элементами, доступ можно осуществить лишь в одном случае — при использовании той же самой ссылки на массив, что использовалась для сохранения элемента.

Потому что new byte[] {1} != new byte[] {1}. Так же, их метод для получения хеш кода унаследованы от Object'а, что значит, что каждый новый массив имеет новый хеш код. Следовательно, когда, мы спросим у хеш мапы значение по ключу new byte[] {1}, то получим null, даже если там есть значение по ключу массива байтов с единицой.

Чтобы использовать объект в качестве ключа в `HashMap`, объект должен корректно реализовывать методы `hashCode()` и `equals()`. Поэтому рекомендуется использовать примитивные типы данных или иммутабельные объекты (такие как строки, числа и другие стандартные объекты), которые обеспечивают правильное хэширование и равенство ключей в `HashMap`. Если вы хотите использовать массив байтов как ключ, лучше обернуть его в объект, который корректно реализует методы `hashCode()` и `equals()`, например, в класс `ByteArrayWrapper`(этот класс из Spring - Package org.springframework.data.redis.connection.util).

[к оглавлению](#коллекции)

## Будет ли работать HashMap, если все добавляемые ключи будут иметь одинаковый hashCode()?

Да, будет, но в этом случае HashMap вырождается в связный список и теряет свои преимущества.

[к оглавлению](#коллекции)

## Какое худшее время работы метода get(key) для ключа, которого нет /который есть в HashMap?

O(N). 

Худший случай - это поиск ключа в HashMap, вырожденного в список по причине совпадения ключей по hashCode() и для выяснения хранится ли элемент с определённым ключом может потребоваться перебор всего списка.

[к оглавлению](#коллекции)
