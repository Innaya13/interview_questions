[Вопросы для собеседования](https://github.com/Oknel-Vap/Interview_questions/blob/main/QUESTIONS.md#interview_questions)

# ООП в Java

+ [Какие виды классов есть в java?](#какие-виды-классов-есть-в-java)
+ [Расскажите про вложенные классы. В каких случаях они применяются?](#расскажите-про-вложенные-классы-в-каких-случаях-они-применяются)
+ [Что такое «локальный класс»? Каковы его особенности?](#что-такое-локальный-класс-каковы-его-особенности)
+ [Что такое «анонимные классы»? Где они применяются?](#что-такое-анонимные-классы-где-они-применяются)
+ [Каким образом из вложенного класса получить доступ к полю внешнего класса?](#каким-образом-из-вложенного-класса-получить-доступ-к-полю-внешнего-класса)
+ [Что такое перечисления (enum)?](#что-такое-перечисления-enum)
+ [Как проблема ромбовидного наследования решена в java?](#как-проблема-ромбовидного-наследования-решена-в-java)
+ [Что такое конструктор по умолчанию?](#что-такое-конструктор-по-умолчанию)
+ [Могут ли быть приватные конструкторы? Для чего они нужны?](#могут-ли-быть-приватные-конструкторы-для-чего-они-нужны)
+ [Расскажите про классы-загрузчики и про динамическую загрузку классов.](#расскажите-про-классы-загрузчики-и-про-динамическую-загрузку-классов)
+ [Чем отличаются конструкторы по-умолчанию, конструктор копирования и конструктор с параметрами?](#чем-отличаются-конструкторы-по-умолчанию-конструктор-копирования-и-конструктор-с-параметрами)
+ [Какие модификаторы доступа есть в Java? Какие применимы к классам?](#какие-модификаторы-доступа-есть-в-java-какие-применимы-к-классам-паблик-дефолт)
+ [Что означает модификатор static?](#что-означает-модификатор-static)
+ [Может ли статический метод быть переопределён или перегружен?](#может-ли-статический-метод-быть-переопределён-или-перегружен)
+ [Могут ли нестатические методы перегрузить статические?](#могут-ли-нестатические-методы-перегрузить-статические)
+ [Можно ли сузить уровень доступа/тип возвращаемого значения при переопределении метода?](#можно-ли-сузить-уровень-доступатип-возвращаемого-значения-при-переопределении-метода)
+ [Что можно изменить в сигнатуре метода при переопределении? Можно ли менять модификаторы (throws и тп)?](#что-можно-изменить-в-сигнатуре-метода-при-переопределении-можно-ли-менять-модификаторы-throws-и-тп)
+ [Могут ли классы быть статическими?](#могут-ли-классы-быть-статическими)
+ [Что означает модификатор final? К чему он может быть применим?](#что-означает-модификатор-final-к-чему-он-может-быть-применим)
+ [Что такое абстрактные классы? Чем они отличаются от обычных?](#что-такое-абстрактные-классы-чем-они-отличаются-от-обычных)
+ [Может ли быть абстрактный класс без абстрактных методов?](#может-ли-быть-абстрактный-класс-без-абстрактных-методов)
+ [Могут ли быть конструкторы у абстрактных классов? Для чего они нужны?](#могут-ли-быть-конструкторы-у-абстрактных-классов-для-чего-они-нужны)
+ [Что такое интерфейсы? Какие модификаторы по умолчанию имеют поля и методы интерфейсов?](#что-такое-интерфейсы-какие-модификаторы-по-умолчанию-имеют-поля-и-методы-интерфейсов)
+ [Чем интерфейсы отличаются от абстрактных классов? В каких случаях следует использовать абстрактный класс, а в каких интерфейс?](#чем-интерфейсы-отличаются-от-абстрактных-классов)
+ [Может ли один интерфейс наследоваться от другого? От двух других?](#может-ли-один-интерфейс-наследоваться-от-другого-от-двух-других)
+ [Что такое дефолтные методы интерфейсов? Для чего они нужны?](#что-такое-дефолтные-методы-интерфейсов-для-чего-они-нужны)
+ [Как решается проблема ромбовидного наследования при наследовании интерфейсов при наличии default методов?](#как-решается-проблема-ромбовидного-наследования-при-наследовании-интерфейсов-при-наличии-default-методов)
+ [Каков порядок вызова конструкторов и блоков инициализации с учётом иерархии классов?](#каков-порядок-вызова-конструкторов-и-блоков-инициализации-с-учётом-иерархии-классов)
+ [Зачем нужны и какие бывают блоки инициализации?](#зачем-нужны-и-какие-бывают-блоки-инициализации)
+ [Для чего в Java используются статические блоки инициализации?](#для-чего-в-java-используются-статические-блоки-инициализации)
+ [Что произойдет, если в блоке инициализации возникнет исключительная ситуация?](#что-произойдет-если-в-блоке-инициализации-возникнет-исключительная-ситуация)
+ [Какое исключение выбрасывается при возникновении ошибки в блоке инициализации класса?](#какое-исключение-выбрасывается-при-возникновении-ошибки-в-блоке-инициализации-класса)
+ [Что такое класс Object?](#что-такое-класс-object)
+ [Какие методы есть у класса Object (перечислить все)? Что они делают?](#какие-методы-есть-у-класса-object-перечислить-все-что-они-делают)
+ [Расскажите про equals и hashcode](#расскажите-про-equals-и-hashcode)
+ [Каким образом реализованы методы hashCode() и equals() в классе Object?](#каким-образом-реализованы-методы-hashcode-и-equals-в-классе-object)
+ [Зачем нужен equals(). Чем он отличается от операции ==?](#зачем-нужен-equals-чем-он-отличается-от-операции-)
+ [Правила переопределения equals()](#правила-переопределения-equals)
+ [Что будет, если переопределить equals() не переопределяя hashCode()? Какие могут возникнуть проблемы?](#что-будет-если-переопределить-equals-не-переопределяя-hashcode)
+ [Какой контракт между hashCode() и equals()?](#какой-контракт-между-hashcode-и-equals)
+ [Для чего нужен метод hashCode()?](#для-чего-нужен-метод-hashcode)
+ [Правила переопределения метода hashcode().](#правила-переопределения-метода-hashcode)
+ [Есть ли какие-либо рекомендации о том, какие поля следует использовать при подсчете hashCode()?](#есть-ли-какие-либо-рекомендации-о-том-какие-поля-следует-использовать-при-подсчете-hashcode)
+ [Могут ли у разных объектов быть одинаковые hashCode()?](#могут-ли-у-разных-объектов-быть-одинаковые-hashcode)
+ [Почему нельзя реализовать hashcode() который будет гарантированно уникальным для каждого объекта?](#почему-нельзя-реализовать-hashcode-который-будет-гарантированно-уникальным-для-каждого-объекта)
+ [Есть класс Point{int x, y;}. Почему хэш-код в виде 31 * x + y предпочтительнее чем x + y?](#есть-класс-pointint-x-y-почему-хэш-код-в-виде-31--x--y-предпочтительнее-чем-x--y)
+ [Чем a.getClass().equals(A.class) отличается от a instanceOf A.class](#чем-agetclassequalsaclass-отличается-от-a-instanceof-aclass)


## Какие виды классов есть в Java?

+ Top level class (Обычный класс):
  - Abstract class (Абстрактный класс);
  - Final class (Финализированный класс).
+ Interfaces (Интерфейс). Enum (Перечисление).
+ Nested class (Вложенный класс):
  - Static nested class (Статический вложенный класс);
  - Member inner class (Простой внутренний класс);
  - Local inner class (Локальный класс);
  - Anonymous inner class (Анонимный вложенный класс).
    
> К классам верхнего уровня модификатор static неприменим.

Существуют четыре категории вложенных классов, каждая из которых занимает свое место. Если вложенный класс должен быть виден за пределами одного метода или он слишком длинный для того, чтобы его можно было удобно разместить в границах метода, используйте класс-член. Если каждому экземпляру класса-члена необходима ссылка на включающий его экземпляр, делайте его нестатическим, в остальных случаях он должен быть статическим. Предположим, что класс находится внутри метода. Если вам нужно создавать экземпляры этого класса только в одном месте программы и уже есть тип, который характеризует это класс, сделайте его анонимным классом. В противном случае, это должен быть локальный класс.

[Статья на Хабр](https://habr.com/ru/articles/439648/)

[к оглавлению](#ООП-в-Java)

## Расскажите про вложенные классы. В каких случаях они применяются?

Класс называется вложенным (Nested class), если он определен внутри другого класса.

Вложенный класс должен создаваться только для того, чтобы обслуживать обрамляющий его класс.

Если вложенный класс оказывается полезен в каком-либо ином контексте, он должен стать классом верхнего уровня.

Вложенные классы имеют доступ ко всем (в том числе приватным) полям и методам внешнего класса, но не наоборот. Из-за этого разрешения использование вложенных классов приводит к некоторому нарушению инкапсуляции.

Существуют четыре категории вложенных классов:

+ Static nested class (Статический вложенный класс);
+ Member inner class (Простой внутренний класс);
+ Local inner class (Локальный класс);
+ Anonymous inner class (Анонимный класс).
  
Такие категории классов, за исключением первого, также называют внутренними (Inner class).

Внутренние классы ассоциируются не с внешним классом, а с экземпляром внешнего.

Каждая из категорий имеет рекомендации по своему применению:

+ Cтатический: если вложенный класс должен быть виден за пределами одного метода или он слишком длинный для того, чтобы его можно было удобно разместить в границах одного метода и если каждому экземпляру такого класса необходима ссылка на включающий его экземпляр.

Вложенный статический класс в Java используется, когда ссылка на каждый обрамляющий экземпляр класса не нужна. Вложенный статический класс имеет доступ только к статическим членам внешнего класса и не может напрямую обращаться к нестатическим членам или методам обрамляющего класса. Также статический вложенный класс не имеет доступа к экземплярам внешнего класса, поэтому он может использоваться, например, для создания вспомогательных классов или для группировки логически связанных классов внутри внешнего класса.

+ Нестатический: если ссылка на обрамляющий класс не требуется. Доступ к полям стат. и нестат. класса.
+ Локальный: если класс необходим только внутри какого-то метода и требуется создавать экземпляры этого класса только в этом методе.
+ Анонимный: если к тому же применение класса сводится к использованию лишь в одном месте и уже существует тип, характеризующий этот класс.

В языке Java вы можете объявлять классы внутри других классов, и такие классы называются вложенными классами или внутренними классами. Вложенные классы предоставляют дополнительные уровни абстракции и организации кода. Вот некоторые случаи, когда вложенные классы могут быть применены:

1. Логическая связь: Вложенные классы могут использоваться для создания логической связи между классами. Например, если у вас есть класс `Car`, то внутри него можно объявить вложенный класс `Engine`, который представляет собой логическую часть автомобиля. Такая организация позволяет группировать связанный код в одном месте и улучшает читаемость и понимание программы.

2. Инкапсуляция: Вложенные классы могут быть использованы для обеспечения инкапсуляции и скрытия деталей реализации. Вы можете объявить вложенный класс `private`, чтобы он был доступен только внутри внешнего класса. Это позволяет ограничить доступ к частям кода и сделать их недоступными для других классов.

3. Улучшенная читаемость: Использование вложенных классов может повысить читаемость кода, особенно когда вложенный класс используется только внутри внешнего класса. Это позволяет группировать связанный код вместе и уменьшает количество классов на верхнем уровне.

4. Реализация интерфейсов: Вложенные классы могут реализовывать интерфейсы, что позволяет создавать компактные и связанные по смыслу реализации. Например, внутри класса `List` можно объявить вложенный класс `Iterator`, который реализует интерфейс `Iterator` для обхода элементов списка.

5. Локальные классы и анонимные классы: Вложенные классы могут быть объявлены внутри методов, что позволяет создавать локальные классы. Локальные классы полезны, когда вам нужно определить класс, который используется только внутри определенного метода. Анонимные классы - это особый тип локальных классов, которые могут быть созданы без явного объявления имени класса. Они часто используются при реализации интерфейсов или абстрактных классов на лету.

Вложенные классы предоставляют гибкость и организацию кода, позволяя создавать более модульные и понятные программы. Однако, их следует использовать с умом и только там, где они действительно улучшают структуру и читаемость кода.
  
[к оглавлению](#ООП-в-Java)

## Что такое локальный класс? Каковы его особенности?

Local inner class (Локальный класс) - это вложенный класс, который может быть декларирован в любом блоке, в котором разрешается декларировать переменные. Как и простые внутренние классы (Member inner class) локальные классы имеют имена и могут использоваться многократно. Как и анонимные классы, они имеют окружающий их экземпляр только тогда, когда применяются в нестатическом контексте.

Локальные классы имеют следующие особенности:

+ Видны только в пределах блока, в котором объявлены;
+ Не могут быть объявлены как private/public/protected или static;
+ Не могут иметь внутри себя статических объявлений (полей, методов, классов);
+ Имеют доступ к полям и методам обрамляющего класса;
+ Могут обращаться к локальным переменным и параметрам метода, если они объявлены с модификатором final.

Локальный класс - это класс, объявленный внутри метода или блока кода. Он имеет ограниченную область видимости и доступен только внутри того метода или блока, в котором он объявлен. Вот некоторые особенности локальных классов:

1. Ограниченная область видимости: Локальные классы видны только внутри метода или блока кода, в котором они объявлены. Это означает, что другие методы или блоки кода не могут обращаться к локальному классу.

2. Доступ к переменным внешнего метода: Локальные классы имеют доступ к переменным внешнего метода, но только к тем, которые объявлены как `final` или эффективно финализированы (т.е. их значение не меняется после присвоения). Это связано с тем, что локальные классы могут продолжать существовать после завершения метода и могут ссылаться на переменные, которые уже вышли из области видимости.

3. Возможность реализации интерфейсов и наследования: Локальные классы могут реализовывать интерфейсы и наследоваться от других классов. Это позволяет создавать компактные и связанные по смыслу реализации внутри метода.

4. Доступ к членам внешнего класса: Локальные классы имеют доступ к членам внешнего класса, включая приватные члены. Это позволяет локальному классу использовать и изменять состояние внешнего класса.

5. Возможность использования анонимных классов: Локальные классы могут быть анонимными, то есть они могут быть объявлены без явного имени класса. Анонимные классы особенно полезны, когда вам нужно создать экземпляр класса, реализующего интерфейс или абстрактный класс, непосредственно внутри метода.

Локальные классы полезны, когда вам нужно определить класс, который используется только внутри определенного метода или блока кода. Они помогают улучшить организацию кода, сделать его более модульным и понятным. Однако, следует помнить ограниченную область видимости локальных классов и правила доступа к переменным внешнего метода.

Локальные классы не могут быть статическими, потому что они связаны с экземпляром внешнего класса или метода, в котором они объявлены. Статические классы, с другой стороны, не связаны с конкретным экземпляром и могут быть использованы независимо от создания экземпляра внешнего класса.

Когда вы объявляете локальный класс, он имеет доступ к переменным и методам внешнего класса или метода, включая их нестатические члены. Он может использовать и изменять состояние внешнего класса или метода. Если локальный класс был статическим, то такой доступ к нестатическим членам внешнего класса или метода был бы невозможен, поскольку статические члены не зависят от конкретного экземпляра.

Более того, локальные классы имеют доступ к локальным переменным внешнего метода, даже после завершения метода. Если локальный класс был статическим, то он не мог бы иметь доступ к локальным переменным, поскольку они существуют только во время выполнения метода.

Итак, локальные классы не могут быть статическими, потому что их особенности и связь с внешним классом или методом не совместимы с использованием статических членов. Если вам нужно создать статический класс внутри другого класса, вы можете объявить его как вложенный статический класс, а не как локальный класс.

[к оглавлению](#ООП-в-Java)

## Что такое анонимные классы? Где они применяются?

Это вложенный локальный класс без имени, который разрешено декларировать в любом месте обрамляющего класса, разрешающем размещение выражений. Создание экземпляра анонимного класса происходит одновременно с его объявлением. В зависимости от местоположения анонимный класс ведет себя как статический либо как нестатический вложенный класс - в нестатическом контексте появляется окружающий его экземпляр.

Анонимные классы имеют несколько ограничений:

+ Их использование разрешено только в одном месте программы - месте его создания;
+ Применение возможно только в том случае, если после порождения экземпляра нет необходимости на него ссылаться;
+ Реализует лишь методы своего интерфейса или суперкласса, т.е. не может объявлять каких-либо новых методов, так как для доступа к ним нет поименованного типа.

Анонимные классы обычно применяются для:
+ создания объекта функции (function object), например реализация интерфейса Comparator;
+ создания объекта процесса (process object), такого как экземпляры классов Thread, Runnable и подобных;
+ в статическом методе генерации;
+ инициализации открытого статического поля final, которое соответствует сложному перечислению типов, когда для каждого экземпляра в перечислении требуется отдельный подкласс.

[к оглавлению](#ООП-в-Java)

## Каким образом из вложенного класса получить доступ к полю внешнего класса?

Статический вложенный класс имеет прямой доступ только к статическим полям обрамляющего класса. В статическом вложенном классе можно получить доступ только к статическим полям и методам внешнего класса. Для доступа к нестатическим полям внешнего класса из статического вложенного класса потребуется создать экземпляр внешнего класса.

Простой внутренний класс, может обратиться к любому полю внешнего класса напрямую. В случае, если у вложенного класса уже существует поле с таким же литералом, то обращаться к такому полю следует через ссылку на его экземпляр.

Например: Outer.this.field.

[к оглавлению](#ООП-в-Java)

## Что такое перечисления (Enum)?

Перечисления представляют набор логически связанных констант.

Объявление перечисления происходит с помощью оператора enum, после которого идет название перечисления. Затем идет список элементов перечисления через запятую. Каждый из них явно объявлен как открытый статический финальный член класса. По сравнению с обычными классами, на Enum наложили одно серьезное ограничение — от него невозможно наследоваться.

values() - он возвращает массив всех констант перечисления

Особенности Enum классов:

+ Конструктор всегда private или default
+ Могут имплементировать интерфейсы
+ Не могут наследовать класс
+ Можем переопределить toString()
+ Нет public конструктора, поэтому нельзя создать экземпляр вне Enum
+ При equals() выполняется ==
+ ordinal() возвращает порядок элементов
+ Может использоваться в TreeSet и TreeMap т.к. Enum имплементирует Comparable
+ compareTo() имитирует порядок элементов предоставляемый ordinal()
+ Можно использовать в Switch Case
+ values() возвращает массив всех констант
+ Легко создать потокобезопасный синглтон без double check volatile переменных.

Да, в Java перечисления являются классами. Они являются специальным типом классов, предназначенных для представления фиксированного набора значений. При объявлении перечисления вы создаете новый класс, который наследуется от класса `java.lang.Enum`. Ваше перечисление может иметь поля, методы и конструкторы, как и любой другой класс.

Вот пример объявления простого перечисления в Java:

```java
enum ДеньНедели {
    ПОНЕДЕЛЬНИК,
    ВТОРНИК,
    СРЕДА,
    ЧЕТВЕРГ,
    ПЯТНИЦА,
    СУББОТА,
    ВОСКРЕСЕНЬЕ
}
```

В этом примере мы объявляем перечисление `ДеньНедели`, которое представляет дни недели. Каждый элемент перечисления (`ПОНЕДЕЛЬНИК`, `ВТОРНИК`, и т.д.) является константой типа `ДеньНедели`. Вы можете использовать эти константы, как и любые другие переменные, в вашем коде.

Например, вы можете создать переменную типа `ДеньНедели` и присвоить ей одно из значений перечисления:

```java
ДеньНедели сегодня = ДеньНедели.ПОНЕДЕЛЬНИК;
```

Теперь переменная `сегодня` содержит значение `ДеньНедели.ПОНЕДЕЛЬНИК`.

Поскольку перечисления являются классами, они могут иметь методы. Вы можете добавить методы к перечислению, чтобы выполнить определенные действия или получить информацию о константах перечисления.

```java
enum ДеньНедели {
    ПОНЕДЕЛЬНИК,
    ВТОРНИК,
    СРЕДА,
    ЧЕТВЕРГ,
    ПЯТНИЦА,
    СУББОТА,
    ВОСКРЕСЕНЬЕ;

    public boolean являетсяРабочимДнем() {
        return this != СУББОТА && this != ВОСКРЕСЕНЬЕ;
    }
}
```

В этом примере мы добавили метод `являетсяРабочимДнем()`, который возвращает `true`, если константа перечисления не является выходным днем (субботой или воскресеньем).

Таким образом, перечисления в Java представляют собой особый тип классов, который предназначен для представления фиксированного набора значений. Они могут иметь поля, методы и конструкторы, и их использование упрощает и улучшает читаемость кода.

[к оглавлению](#ООП-в-Java)

## Как проблема ромбовидного наследования решена в Java?

Интерфейсы, запрещено множественное наследование классов.

[к оглавлению](#ООП-в-Java)

## Что такое конструктор по умолчанию?

Если у какого-либо класса не определить конструктор, то компилятор сгенерирует конструктор без аргументов - так называемый «конструктор по умолчанию».

Если же программист создал для класса хоть один конструктор (не важно с параметрами или без) - конструктор по умолчанию не создается!

[к оглавлению](#ООП-в-Java)

## Могут ли быть приватные конструкторы? Для чего они нужны?

Приватный (помеченный ключевым словом private, скрытый) конструктор может использоваться публичным статическим методом генерации объектов данного класса.

Также доступ к нему разрешен вложенным классам и может использоваться для их нужд запрещает создание экземпляра класса вне методов самого класса, например, чтобы гарантировать существование только одного объекта определённого класса, предположим какого-то ресурса, например БД.

Для предотвращения создания экземпляра вне объекта в следующих случаях:

+ синглтон
+ factory метод
+ класс только для статических методов (служебный)
+ класс только для констант

+ Для предотвращения подкласса (расширения). Если вы создадите только частный конструктор, ни один класс не сможет расширить ваш класс, потому что он не может вызвать конструктор super(). Это своего рода синоним модификатора final.

+ Перегруженные конструкторы — в результате перегрузки методов и конструкторов некоторые из них могут быть закрытыми, а некоторые общедоступными. Особенно в случае, когда вы используете непубличный класс в своих конструкторах, вы можете создать общедоступный конструктор, который создает экземпляр этого класса, а затем передает его частному конструктору.

Да, вы правы. Перегруженные конструкторы могут иметь различные модификаторы доступа, включая приватный и общедоступный. Использование непубличного класса в конструкторе может быть полезным, когда требуется создать экземпляр этого класса и передать его в приватный конструктор.

Вот пример, демонстрирующий эту концепцию:

```java
public class MyClass {
    private AnotherClass anotherInstance;

    // Приватный конструктор, принимающий экземпляр AnotherClass
    private MyClass(AnotherClass anotherInstance) {
        this.anotherInstance = anotherInstance;
    }

    // Общедоступный конструктор, создающий экземпляр AnotherClass и передающий его в приватный конструктор
    public MyClass() {
        this(new AnotherClass());
    }
}

class AnotherClass {
    // Конструктор AnotherClass
    public AnotherClass() {
        // Инициализация AnotherClass
    }
}
```

В этом примере класс `MyClass` имеет приватный конструктор, который принимает экземпляр класса `AnotherClass`. Класс `MyClass` также имеет общедоступный конструктор без параметров. Внутри общедоступного конструктора создается экземпляр класса `AnotherClass` и передается в приватный конструктор `MyClass`.

Таким образом, пользователь может создать экземпляр `MyClass`, вызвав общедоступный конструктор, и внутри этого конструктора будет создан экземпляр `AnotherClass` и передан в приватный конструктор `MyClass`.

Этот подход позволяет контролировать создание экземпляров класса `MyClass` и обеспечивает гибкость при использовании непубличных классов в конструкторах.

[к оглавлению](#ООП-в-Java)

## Расскажите про классы-загрузчики и про динамическую загрузку классов.

Основа работы с классами в Java — классы-загрузчики, обычные Java-объекты, предоставляющие интерфейс для поиска и создания объекта класса по его имени во время работы приложения.

В начале работы программы создается 3 основных загрузчика классов:
+ базовый загрузчик (bootstrap/primordial). Загружает основные системные и внутренние классы JDK (Core API - пакеты Java.* (rt.jar и i18n.jar) . Важно заметить, что базовый загрузчик является «Изначальным» или «Корневым» и частью JVM, вследствие чего его нельзя создать внутри кода программы.
+ загрузчик расширений (extention). Загружает различные пакеты расширений, которые располагаются в директории <JAVA_HOME>/lib/ext или другой директории, описанной в системном параметре Java.ext.dirs. Это позволяет обновлять и добавлять новые расширения без необходимости модифицировать настройки используемых приложений. Загрузчик расширений реализован классом sun.misc.Launcher$ExtClassLoader.
+ системный загрузчик (system/application). Загружает классы, пути к которым указаны в переменной окружения CLASSPATH или пути, которые указаны в командной строке запуска JVM после ключей -classpath или -cp. Системный загрузчик реализован классом sun.misc.Launcher$AppClassLoader.

Классы, предоставленные расширениями (extension classes), и классы, находящиеся в класспате (classpath classes), имеют некоторые отличия. Вот некоторые из них:

1. Источник классов: Классы, предоставленные расширениями, поставляются с расширениями Java и обычно находятся в расширенной директории (extension directory). Классы, находящиеся в класспате, могут быть частью вашего приложения или внешних библиотек, и они указываются в класспути при запуске приложения.

2. Доступность: Классы из расширений обычно доступны для всех Java-приложений, запущенных на данной установке Java. Классы, находящиеся в класспате, доступны только для конкретного приложения, в котором они указаны в класспути.

3. Функциональность: Классы расширений предоставляют дополнительные возможности и функциональность, которые не входят в стандартную библиотеку Java. Например, расширение может добавить новые классы, интерфейсы, библиотеки или сервис-провайдеры. Классы, находящиеся в класспате, могут быть частью вашего приложения и предоставлять функциональность, специфичную для вашего приложения.

Пример класса, предоставленного расширением:

```java
// Класс из расширения
public class ExtensionClass {
    public void extensionMethod() {
        // Реализация метода
    }
}
```

Пример класса, находящегося в класспате:

```java
// Класс из класспата
public class ApplicationClass {
    public void applicationMethod() {
        // Реализация метода
    }
}
```

В приведенных примерах `ExtensionClass` является классом, предоставленным расширением, и может быть доступен для всех Java-приложений на данной установке Java. `ApplicationClass` является классом, находящимся в класспате, и доступен только для конкретного приложения, в котором он указан в класспути.

Оба типа классов могут использоваться в Java-приложениях с разными целями и в зависимости от требований вашего приложения.

Загрузчики классов являются иерархическими: каждый из них (кроме базового) имеет родительский загрузчик и в большинстве случаев, перед тем как попробовать загрузить класс самостоятельно, он посылает вначале запрос родительскому загрузчику загрузить указанный класс.

Такое делегирование позволяет загружать классы тем загрузчиком, который находится ближе всего к базовому в иерархии делегирования. Как следствие поиск классов будет происходить в источниках в порядке их доверия: сначала в библиотеке Core API, потом в папке расширений, потом в локальных файлах CLASSPATH.

Процесс загрузки класса состоит из трех частей:

+ Loading – на этой фазе происходит поиск и физическая загрузка файла класса в определенном источнике (в зависимости от загрузчика). Этот процесс определяет базовое представление класса в памяти. На этом этапе такие понятия как «методы», «поля» и т.д. пока не известны.
+ Linking – процесс, который может быть разбит на 3 части:
  - Bytecode verification – проверка байт-кода на соответствие требованиям, определенным в спецификации JVM. 
  - Class preparation – создание и инициализация необходимых структур, используемых для представления полей, методов, реализованных интерфейсов и т.п., определенных в загружаемом классе.
  - Resolving – загрузка набора классов, на которые ссылается загружаемый класс.
+ Initialization – вызов статических блоков инициализации и присваивание полям класса значений по умолчанию.

В Java все классы загружаются динамически, независимо от того, являются ли они статическими или нестатическими. Загрузка классов происходит во время выполнения программы по мере их необходимости.

Однако, статические члены класса (статические переменные и статические методы) инициализируются и связываются при первом обращении к классу или при инициализации класса, которая выполняется при запуске программы. Это происходит после загрузки класса и перед его использованием. Статические члены класса связаны с самим классом, а не с конкретным экземпляром класса.

Динамическая загрузка классов в Java означает, что классы загружаются и связываются во время выполнения программы по мере необходимости. Нестатические члены класса (нестатические переменные, методы, вложенные классы) также загружаются и связываются динамически, когда они используются в программе.

Таким образом, загрузка классов в Java является динамической, независимо от того, являются ли они статическими или нестатическими. Однако, инициализация и связывание статических членов класса происходит при первом обращении к классу или при инициализации класса, а не при каждом использовании класса в программе.

Динамическая загрузка классов производится через метод Class.forName(String className) или с использованием ClassLoader-а. Динамическая загрузка классов имеет смысл, когда требуется загрузить класс во время выполнения программы, когда нужно заменить класс, изменив, например, какую-то логику, не рестартуя приложения. Иногда может понадобиться загружать классы удаленно, например по http
```java
Class animalClass = Class.forName("org.dmitrievs.Cat") ;
//Создается класс с конструктором по умолчанию
myAnimal = (Cat) animalClass.newInstance(); 

//загружаем класс через ClassLoader
ClassLoader classLoader = MainClass.class.getClassLoader();
Class aClass = classLoader.loadClass("com.jenkov.MyClass");
myClass = (MyClass) aClass.newInstance();
```
Один и тот же ClassLoader не может повторно загружать один и тот же класс, поэтому для повторной закрузки используется новый загрузчик. 

Динамическая загрузка классов в Java имеет ряд особенностей:

+ отложенная (lazy) загрузка и связывание классов. Загрузка классов производится только при необходимости, что позволяет экономить ресурсы и распределять нагрузку.
проверка корректности загружаемого кода (type safeness). Все действия связанные с контролем использования типов производятся только во время загрузки класса, позволяя избежать дополнительной нагрузки во время выполнения кода.
+ программируемая загрузка. Пользовательский загрузчик полностью контролирует процесс получения запрошенного класса — самому ли искать байт-код и создавать класс или делегировать создание другому загрузчику. Дополнительно существует возможность выставлять различные атрибуты безопасности для загружаемых классов, позволяя таким образом работать с кодом из ненадежных источников.
+ множественные пространства имен. Каждый загрузчик имеет своё пространство имён для создаваемых классов. Соответственно, классы, загруженные двумя различными загрузчиками на основе общего байт-кода, в системе будут различаться.

Существует несколько способов инициировать загрузку требуемого класса:
+ явный: вызов ClassLoader.loadClass() или Class.forName() (по умолчанию используется загрузчик, создавший текущий класс, но есть возможность и явного указания загрузчика);
+ неявный: когда для дальнейшей работы приложения требуется ранее не использованный класс, JVM инициирует его загрузку.

[к оглавлению](#ООП-в-Java)

## Чем отличаются конструкторы по умолчанию, конструктор копирования и конструктор с параметрами?

У конструктора по умолчанию отсутствуют какие-либо аргументы. Конструктор копирования принимает в качестве аргумента уже существующий объект класса для последующего создания его клона.

Конструктор с параметрами имеет в своей сигнатуре аргументы (обычно необходимые для инициализации полей класса).

[к оглавлению](#ООП-в-Java)

## Какие модификаторы доступа есть в Java? Какие применимы к классам паблик дефолт?

+ private (приватный): члены класса доступны только внутри класса.
+ default, package-private, package level (доступ на уровне пакета): видимость класса/членов класса только внутри пакета. Является модификатором доступа по умолчанию
+ protected (защищённый): члены класса доступны внутри пакета и в наследниках.
+ public (публичный): класс/члены класса доступны всем.

Во время наследования возможно изменения модификаторов доступа в сторону большей видимости (для поддержания соответствия принципу подстановки Барбары Лисков).

 К кдассам применимы public и default, использовать protected не имеет смысла так как в джжава нельзя наследовать пакеты (а protected означает доступ наследиков). Но можно использовать все 4 модификатора к вложенным классам.

[к оглавлению](#ООП-в-Java)

## Что означает модификатор static?

Модификатор, применяемый к полю, блоку, методу, внутреннему классу, членам секции import. Данный модификатор указывает на привязку субъекта к текущему классу.

Модификатор static в Java означает, что переменная, метод или блок кода принадлежит классу, а не экземпляру класса. Это означает, что переменная или метод можно использовать без необходимости создавать объект класса.

Когда переменная объявлена с модификатором static, она становится общей для всех экземпляров класса. Все экземпляры класса совместно используют одну и ту же переменную, и если значение переменной изменяется в одном экземпляре, оно изменится для всех.

Когда метод объявлен с модификатором static, он может быть вызван без создания объекта класса. Такие методы называются статическими методами или методами класса. Они не могут обращаться к нестатическим переменным или вызывать нестатические методы класса.

Статические переменные и методы позволяют использовать данные и функциональность без необходимости создания экземпляра класса, что может быть полезно, например, при работе с математическими функциями или при реализации утилитарных методов. Однако их использование должно быть обосновано исходя из требований проекта и архитектуры программы.

Элемент, обозначенный ключевым словом static, принадлежит не объекту класса, а именно классу, и он загружается при загрузке самого класса.
 
Статические элементы — единственные на всю программу, а обычные — единственные на конкретный объект.
 
Статическими могут быть:
+ поля класса;
+ блок инициализации класса;
+ метод класса;
+ внутренние классы класса (однако, та ещё тавтология).

[к оглавлению](#ООП-в-Java)

## Может ли статический метод быть переопределён или перегружен?

Статический метод нельзя переопределить: он принадлежит классу и не наследуется, но в то же время его можно перегрузить.

Статические методы не могут быть переопределены в точном смысле слова, но они могут скрыть родительские статические методы (затирают) 

Да, могут быть перегружены. Мы можем иметь два или более статических метода с одинаковым именем, но с различиями в входных параметрах.

Перегружен - да. Всё работает точно так же, как и с обычными методами - 2 статических метода могут иметь одинаковое имя, если количество их параметров или типов различается.

Переопределён - нет. Выбор вызываемого статического метода происходит при раннем связывании (на этапе компиляции, а не выполнения) и выполняться всегда будет родительский метод, хотя синтаксически переопределение статического метода - это вполне корректная языковая конструкция.

В целом, к статическим полям и методам рекомендуется обращаться через имя класса, а не объект.

Статические методы в Java не могут быть переопределены в традиционном смысле, как это делается с нестатическими методами.

При определении метода в дочернем классе с тем же именем и параметрами, что и статический метод в родительском классе, это называется "скрытием" (hiding), а не переопределением. При вызове статического метода через ссылку на объект дочернего класса будет вызван статический метод этого дочернего класса, а не статический метод родительского класса.

Пример:
```java
class Parent {
    public static void staticMethod() {
        System.out.println("Статический метод класса Parent");
    }
}

class Child extends Parent {
    public static void staticMethod() {
        System.out.println("Статический метод класса Child");
    }
}

public class Main {
    public static void main(String[] args) {
        Parent.staticMethod(); // Выводит "Статический метод класса Parent"
        Child.staticMethod(); // Выводит "Статический метод класса Child"
        
        Parent parent = new Child();
        parent.staticMethod(); // Выводит "Статический метод класса Parent"
        
        Child child = new Child();
        child.staticMethod(); // Выводит "Статический метод класса Child"
    }
}
```
В этом примере Parent.staticMethod() вызывает статический метод класса Parent. Child.staticMethod() вызывает статический метод класса Child. Однако, при вызове parent.staticMethod(), хотя ссылка parent относится к объекту Child, будет вызван статический метод класса Parent, так как статические методы не подвержены полиморфизму. Таким образом, скрытие происходит только при вызове через ссылку родительского класса.

Сокрытие метода (method hiding) - это концепция в объектно-ориентированном программировании, когда подкласс объявляет метод с тем же именем и сигнатурой (типы параметров), что и метод в его суперклассе. В результате метод в суперклассе "скрывается" и переопределяется методом в подклассе.

Основной аспект сокрытия метода заключается в том, что вызов метода будет разрешаться на основе типа ссылки на объект, а не на основе типа самого объекта. Это означает, что если у вас есть ссылка на суперкласс, а объект на самом деле является экземпляром подкласса, вызов метода через эту ссылку будет вызывать метод из суперкласса, а не из подкласса.

[к оглавлению](#ООП-в-Java)

## Могут ли нестатические методы перегрузить статические?

Да. В итоге получится два разных метода. Статический будет принадлежать классу и будет доступен через его имя, а нестатический будет принадлежать конкретному объекту и доступен через вызов метода этого объекта.

При перегрузке методов в Java, методы должны иметь одно и то же имя, но разные сигнатуры (различные типы параметров или количество параметров).

Статические методы и нестатические методы имеют различные способы вызова и разные контексты выполнения. Статические методы связаны с классом, а не с экземпляром объекта, и их вызов осуществляется через имя класса. Нестатические методы, с другой стороны, связаны с экземпляром объекта и вызываются через ссылку на объект.

Поскольку статические методы и нестатические методы имеют разные способы вызова и контексты выполнения, они не могут перегружать друг друга. Компилятор Java будет рассматривать их как разные методы с разными сигнатурами.

[к оглавлению](#ООП-в-Java)

## Можно ли сузить уровень доступа/тип возвращаемого значения при переопределении метода?

При переопределении метода сужать модификатор доступа не разрешается, т.к. это приведет к нарушению принципа подстановки Барбары Лисков. Расширение уровня доступа возможно.

Сужать можно с Java 5 (и то, на самом деле компилятор в байткоде делает два метода с делегирование, в общем синтетический сахар) - https://translated.turbopages.org/proxy_u/en-ru.ru.3efb89b4-655220f6-209f88f3-74722d776562/https/stackoverflow.com/questions/14694852/can-overridden-methods-differ-in-return-type

Частично это можно отнести к причине, почему метод clone() был определен в классе Object,а не в интерфейсе Cloneable - пришлось бы постоянно заниматься рпиведением типа, так как в интерфейсе мы указали бы тип возвращаемого значения - Object. 


Можно изменять все, что не мешает компилятору понять какой метод родительского класса имеется в виду:

+ Изменять тип возвращаемого значения при переопределении метода разрешено только в сторону сужения типа (вместо родительского класса - наследника). При изменении типа, количества, порядка следования аргументов вместо переопределения будет происходить overloading (перегрузка) метода.
+ Секцию throws метода можно не указывать, но стоит помнить, что она остаётся действительной, если уже определена у метода родительского класса. Также, возможно добавлять новые исключения, являющиеся наследниками от уже объявленных или исключения RuntimeException. Порядок следования таких элементов при переопределении значения не имеет.

+ При переопределении метода нельзя сузить модификатор доступа к методу (например с public в MainClass до private в Class extends MainClass).
+ Изменить тип возвращаемого значения при переопределении метода нельзя (но можно использовать подтип, например, Integer вместо Number), будет ошибка attempting to use incompatible return type.

Например:
```java
public class Animal {

    public Animal eat() {
        System.out.println("animal eat");
        return null;
    }
    
    public Long calc() {
        return null;
    }

}
public class Dog extends Animal {

    public Dog eat() {
        return new Dog();
    }
/*attempting to use incompatible return type
    public Integer calc() {
        return null;
    }
*/
}
```
[к оглавлению](#ООП-в-Java)

## Что можно изменить в сигнатуре метода при переопределении? Можно ли менять модификаторы (throws и тп)?

В Java при переопределении метода можно изменять следующие аспекты в сигнатуре метода:

Возвращаемый тип:
Переопределенный метод должен иметь тот же возвращаемый тип или подтип. Однако, у методов, переопределяющих метод, возвращающий объект, можно использовать подтип этого объекта.

Модификатор доступа:
Переопределенный метод может иметь более широкий модификатор доступа, но не может иметь более строгий.

Производительность:
Переопределенный метод может добавить новые исключения в сигнатуру метода, но не может добавить или изменить исключения, указанные в суперклассе.

Аргументы метода:
Аргументы метода в переопределении должны иметь тот же тип и порядок, что и в методе суперкласса.

Таким образом, модификаторы могут быть изменены, но только в более широкий доступ, исключения могут быть добавлены, но не могут быть изменены или удалены, и возвращаемый тип и аргументы метода должны быть такими же или подтипами.

При изменении типа, количества, порядка следования аргументов вместо переопределения будет происходить overloading (перегрузка) метода. 

Секцию throws метода можно не указывать, но стоит помнить, что она остаётся действительной, если уже определена у метода родительского класса.

Также, возможно добавлять новые исключения, являющиеся наследниками от уже объявленных или исключения RuntimeException. Порядок следования таких элементов при переопределении значения не имеет.

При переопределении метода сужать модификатор доступа нельзя, т.к. это приведет к нарушению принципа подстановки Барбары Лисков. Расширение уровня доступа возможно.

Изменять тип возвращаемого значения при переопределении метода разрешено только в сторону сужения типа (вместо родительского класса - наследника).

[к оглавлению](#ООП-в-Java)

## Могут ли классы быть статическими?

В Java есть статические вложенные классы, но похоже, что вы ищете статический класс верхнего уровня. В Java нет способа сделать класс верхнего уровня статическим, но вы можете имитировать статический класс следующим образом:
+ Объявите свой класс final— предотвращает расширение класса, поскольку расширение статического класса не имеет смысла.
+ Создать конструктор private— предотвращает создание экземпляра клиентским кодом, поскольку нет смысла создавать экземпляр статического класса.
+ Сделать все члены и функции класса static. Поскольку класс не может быть создан, нельзя вызвать методы экземпляра или получить доступ к полям экземпляра.

Обратите внимание, что компилятор не помешает вам объявить экземпляр (нестатический) член. Проблема появится только в том случае, если вы попытаетесь вызвать член экземпляра

Что хорошего в статических классах? Хорошее использование статического класса заключается в определении одноразовых, служебных и/или библиотечных классов, создание экземпляров которых не имеет смысла. Отличным примером является класс Math, который содержит некоторые математические константы, такие как PI и E, и просто обеспечивает математические вычисления. Требование создания экземпляра в таком случае было бы ненужным и запутанным. См. Mathкласс и исходный код . Обратите внимание, что это finalи все его члены static. Если бы Java позволяла объявлять классы верхнего уровня, staticкласс Math действительно был бы статическим.

Да. Объект статического класса не хранит ссылку на конкретный экземпляр внешнего класса. Объект статического вложенного класса вполне может существовать сам по себе.

Статический вложенный класс может обращаться только к статическим полям и методам внешнего класса.

Объекты статического класса не содержат ссылок на объекты внешнего класса. А самих объектов мы можем создать сколько угодно.

Статические классы в Java используются для различных нужд. Некоторые из них:
+ Группировка утилитарных методов: Можно создать статический класс, в котором будут содержаться только статические методы, выполняющие определенные утилитарные функции. Это помогает организовать код, сделать его более читабельным и удобным в использовании. Примеры таких классов в стандартной библиотеке Java: Math, Collections, Arrays и т.д.
+ Вспомогательные классы: Статический класс может использоваться для создания вспомогательных классов, которые предоставляют некоторую функциональность для других классов. Например, класс TextUtils может содержать методы для работы со строками, такие как проверка на пустоту, сравнение и т.д.
+ Внутренние классы: Статический класс может быть вложен в другой класс. Это позволяет ограничить доступ к нему только из внешнего класса, а также уменьшить связность между классами, если статический класс не использует какие-либо ресурсы внешнего класса.
+ Паттерны проектирования: Некоторые паттерны проектирования используют статические классы для реализации своей функциональности. Например, одиночка (Singleton) и фабрика (Factory) могут быть реализованы с помощью статического класса.

В целом, статические классы используются там, где требуется организовать код, предоставить вспомогательную функциональность или реализовать паттерны проектирования.

[к оглавлению](#ООП-в-Java)

## Что означает модификатор final? К чему он может быть применим?

Модификатор final может применяться к переменным, параметрам методов, полям и методам класса или самим классам.

+ Класс не может иметь наследников;
+ Метод не может быть переопределен в классах наследниках;
+ Поле не может изменить свое значение после инициализации;
+ Параметры методов не могут изменять своё значение внутри метода;
+ Локальные переменные не могут быть изменены после присвоения им значения.

[к оглавлению](#ООП-в-Java)

## Что такое абстрактные классы? Чем они отличаются от обычных?

Класс помеченный модификатором abstract называется абстрактным классом.

Такие классы могут выступать только предками для других классов. Создавать экземпляры самого абстрактного класса не разрешается. При этом наследниками абстрактного класса могут быть как другие абстрактные классы, так и классы, допускающие создание объектов.

Метод помеченный ключевым словом abstract - абстрактный метод, т.е. метод, который не имеет реализации. Если в классе присутствует хотя бы один абстрактный метод, то весь класс должен быть объявлен абстрактным. 

Использование абстрактных классов и методов позволяет описать некий шаблон объекта, который должен быть реализован в других классах. В них же самих описывается лишь некое общее для всех потомков поведение.

НА ЗАМЕТКУ!!!

Особенности абстрактных классов:

+ Может быть конструктор (для вызовов по цепочке из наследников)
+ Имплементят интерфейсы, но не обязаны реализовывать их методы
+ Не могут быть final
+ Могут содержать static методы
+ Нельзя создать объект 
+ Абстрактные методы могут отсутствовать
+ Может содержать метод main()

[к оглавлению](#ООП-в-Java)

## Может ли быть абстрактный класс без абстрактных методов?

Да

[к оглавлению](#ООП-в-Java)

## Могут ли быть конструкторы у абстрактных классов? Для чего они нужны?

Да, иожет быть конструктор (для вызовов по цепочке из наследников).

Да, в абстрактном классе в Java можно объявить и определить конструкторы. Поскольку создавать экземпляры абстрактных классов нельзя, вызвать такой конструктор можно только при формировании цепочки конструкторов, то есть при создании экземпляра конкретного класса-реализации.

Но представьте, что интервьюер задаст затем вопрос: а какой смысл в конструкторе, если создать экземпляр абстрактного класса все равно нельзя? Дело в том, что его всё равно можно использовать для задания начальных значений общих переменных, объявленных в абстрактном классе и используемых различными реализациями.

Даже если вы не объявили никакого конструктора, компилятор добавит в абстрактный класс конструктор по умолчанию без аргументов. Без него ваш подкласс не скомпилируется, поскольку первый оператор в любом конструкторе представляет собой неявный вызов super() – конструктора суперкласса по умолчанию в языке Java.

Конструктор нужен для инициализации полей. Например, у абстрактного класса Car есть поле yearOfManufacture и model - эти поля будут у машины любой категории (Sedan, Truck и тп) -> каждому классу эти поля нет смысла писать. 
В итоге ты будешь пользовать не конструктором new Car(2014, Tesla M), а методом super(2014, Tesla M ) в конструкторе твоего неабстрактного класса

Yes, an abstract class can have a constructor. Consider this:
```java
abstract class Product { 
    int multiplyBy;
    public Product( int multiplyBy ) {
        this.multiplyBy = multiplyBy;
    }

    public int mutiply(int val) {
       return multiplyBy * val;
    }
}

class TimesTwo extends Product {
    public TimesTwo() {
        super(2);
    }
}

class TimesWhat extends Product {
    public TimesWhat(int what) {
        super(what);
    }
}
```
The superclass Product is abstract and has a constructor. The concrete class TimesTwo has a constructor that just hardcodes the value 2. The concrete class TimesWhat has a constructor that allows the caller to specify the value.

Abstract constructors will frequently be used to enforce class constraints or invariants such as the minimum fields required to setup the class.

NOTE: As there is no default (or no-arg) constructor in the parent abstract class, the constructor used in subclass must explicitly call the parent constructor.

[к оглавлению](#ООП-в-Java)

## Что такое интерфейсы? Какие модификаторы по умолчанию имеют поля и методы интерфейсов?

Ключевое слово interface используется для создания полностью абстрактных классов.

Основное предназначение интерфейса - определять каким образом мы можем использовать класс, который его реализует.

Создатель интерфейса определяет имена методов, списки аргументов и типы возвращаемых значений, но не реализует их поведение. Все методы неявно объявляются как public и abstract.

Начиная с Java 8 в интерфейсах разрешается размещать реализацию методов по умолчанию default и статических static методов.

Интерфейс также может содержать и поля. В этом случае они автоматически являются публичными public, статическими static и неизменяемыми final.

_Что такое static метод интерфейса?_

Статические методы интерфейса похожи на методы по умолчанию, за исключением того, что для них отсутствует возможность переопределения в классах, реализующих интерфейс.

Статические методы в интерфейсе являются частью интерфейса без возможности использовать их для объектов класса реализации; 

Методы класса Java.lang.Object нельзя переопределить как статические; 

Если методы класса Object были бы статическими, то они могли бы вызываться без создания экземпляра объекта. В таком случае, этим методам не были бы доступны данные и состояние конкретного объекта, с которым их было бы связано. Поэтому, замена реализации данных методов статическими методами в подклассе не имела бы смысла, поскольку они не смогут получить доступ к данным экземпляра объекта.

Однако, можно создать собственные статические методы с теми же именами, чтобы предоставить другие функции, которые могут быть полезными в контексте работы с объектами. Такие методы могут оперировать с параметрами или использовать другие статические данные, но они не будут переопределять методы класса Object, которые всегда доступны созданным объектам в Java.

Статические методы в интерфейсе используются для обеспечения вспомогательных методов, например, проверки на null, сортировки коллекций и т.д.

[к оглавлению](#ООП-в-Java)

## Чем интерфейсы отличаются от абстрактных классов?

В каких случаях следует использовать абстрактный класс, а в каких интерфейс?
has a – интерфейс, is a- абстр класс

Интерфейс описывает только поведение. У него нет состояния. А у абстрактного класса состояние есть: он описывает и то, и другое
Абстрактный класс связывает между собой и объединяет классы, имеющие очень близкую связь (птицы: голуби, воробьи). В то же время, один и тот же интерфейс могут реализовать классы, у которых вообще нет ничего общего (Flyable: птицы, наркоман, самолет).
Классы могут реализовывать сколько угодно интерфейсов, но наследоваться можно только от одного класса

+ Интерфейсы описывают только часть функциональности объекта — определённые признаки. Абстрактный класс же может описывать целую категорию разных объектов, а его характеристики имеют право наследовать только те объекты, которые являются частью этой категории. Например, собаки и волки — часть общей категории «Животные», а интерфейс, описывающий умение бегать, может реализовать и человек, и робот, и собака.
+ Интерфейс описывает только поведение (методы), и у него нет полей. Точнее, есть возможность их объявить, но они будут public static final. В то же время абстрактный класс может содержать классические поля, которые будут принадлежать разным объектам.
+ Наследник абстрактного класса обязан наследовать все его составляющие, а интерфейс создан только для реализации (имплементирования). Поэтому в Java мы можем наследовать класс только от одного класса, а на реализацию интерфейсов внутри одного класса ограничений нет.

Когда лучше использовать абстрактные классы:

+ Вы хотите избежать дублирования кода, реализуя несколько тесно связанных классов из одной семантической категории.
+ Классы, которые будут расширять ваш абстрактный класс, имеют много общих свойств и будут реализовывать много похожих методов.
+ Наследуемый класс используется в отношении IS-A — то есть класс-наследник только расширяет функциональность абстрактного класса.
+ Проект уже частично написан, а вы знаете, что выбранные классы будут часто меняться и дополняться новыми методами и полями. То есть поддерживать абстрактный класс и дополнять его намного проще, чем проектировать интерфейс и добавлять его новые методы во все места в коде, где они должны реализовываться.

Когда лучше использовать интерфейсы:

+ Вам нужно описать определённую логику, которую должны поддерживать не связанные между собой объекты.
+ Вам нужно привести к одному типу группу объектов и гарантировать схожую функциональность.
+ Вам необходимо добавить какой-то маркер, который будет говорить о том, что выбранные классы поддерживают определённую логику.
+ Вы хотите использовать множественное наследование типа.


Используйте абстрактные классы, если:
+ Вы хотите поделиться кодом между несколькими тесно связанными классами.
+ Вы ожидаете, что классы, которые расширяют ваш абстрактный класс, имеют много общих методов или полей, или требуют других модификаторов доступа, кроме public (например, protected и private).
+ Вы хотите объявить нестатические или не-final поля. Это позволяет вам определять методы, которые могут получить доступ и изменить состояние объекта, которому они принадлежат.

Используйте интерфейсы, если:
+ Вы ожидаете, что несвязанные классы будут реализовывать ваш интерфейс. Например, интерфейсы Comparable и Cloneable реализуются многими несвязанными классами.
+ Вы хотите определить поведение конкретного типа данных, но вам не важно, кто его реализует.
+ Вы хотите использовать множественное наследование типа.

[к оглавлению](#ООП-в-Java)

## Может ли один интерфейс наследоваться от другого? От двух других?

да, да

[к оглавлению](#ООП-в-Java)

## Что такое дефолтные методы интерфейсов? Для чего они нужны?

Если класс реализует интерфейс, он может, но не обязан, реализовать методы по-умолчанию, уже реализованные в интерфейсе. Класс наследует реализацию по умолчанию.

Дефолтные методы можно переопределить.

Если некий класс реализует несколько интерфейсов, которые имеют одинаковый метод по умолчанию, то класс должен реализовать метод с совпадающей сигнатурой самостоятельно. Ситуация аналогична, если один интерфейс имеет метод по умолчанию, а в другом этот же метод является абстрактным - никакой реализации по умолчанию классом не наследуется.

Метод по умолчанию не может переопределить метод класса Java.lang.Object.

Помогают реализовывать интерфейсы без страха нарушить работу других классов.

Позволяют избежать создания служебных классов, так как все необходимые методы могут быть представлены в самих интерфейсах.

Дают свободу классам выбрать метод, который нужно переопределить.

Одной из основных причин внедрения методов по умолчанию является возможность коллекций в Java 8 использовать лямбда-выражения.

[к оглавлению](#ООП-в-Java)

## Как решается проблема ромбовидного наследования при наследовании интерфейсов при наличии default методов?

Через переопределение (и не только).
```java
   public interface First {
    default void hello(){
        System.out.println("This is First");
    }
}

 public interface Second extends First {
    default void hello(){
        System.out.println("This is Second");
    }
}

  public class MyClass implements First,Second {

    public static void main(String[] args) {
        new MyClass().hello();
    }
}
```
Ниже приведены правила, которым необходимо следовать, когда класс наследует метод с одной и той же сигнатурой из нескольких мест (другой класс или интерфейс):

+ Реализация у класса или у суперкласса всегда имеет более высокий приоритет, чем реализация по умолчанию в интерфейсе.
+ В противном случае выигрывают подынтерфейсы: выбирается метод с такой же сигнатурой в самом ближайшем интерфейсе, предоставляющем значения по умолчанию. (например, в вашем случае метод из второго интерфейса должен работать как второй, расширяющий первый).
+ Наконец, если выбор по-прежнему неоднозначен, класс, наследующий от нескольких интерфейсов, должен явно выбрать, какую реализацию метода по умолчанию использовать, переопределив ее и явным образом вызвав желаемый метод (иначе код не скомпилируется, в Java это просто запрещено и компилятор явно попросит вас реализовать этот метод в классе, реализующем интерфейсы.)

[к оглавлению](#ООП-в-Java)

## Каков порядок вызова конструкторов и блоков инициализации с учётом иерархии классов?

Сначала вызываются все статические блоки в очередности от первого статического блока корневого предка и выше по цепочке иерархии до статических блоков самого класса. Затем вызываются нестатические блоки инициализации корневого предка, конструктор корневого предка и так далее вплоть до нестатических блоков и конструктора самого класса.
```
Parent static block(s) → Child static block(s) → Grandchild static block(s) 

→ Parent non-static block(s) → Parent constructor → 

→ Child non-static block(s) → Child constructor → 

→ Grandchild non-static block(s) → Grandchild constructor
```
[к оглавлению](#ООП-в-Java)

## Зачем нужны и какие бывают блоки инициализации?

Блоки инициализации представляют собой код, заключенный в фигурные скобки и размещаемый внутри класса вне объявления методов или конструкторов.

Существуют статические и нестатические блоки инициализации. Блок инициализации выполняется перед инициализацией класса загрузчиком классов или созданием объекта класса с помощью конструктора.

Несколько блоков инициализации выполняются в порядке следования в коде класса. Блок инициализации способен генерировать исключения, если их объявления перечислены в throws всех конструкторов класса.

Блок инициализации возможно создать и в анонимном классе.
```java
class Dog{ 

private String name; 
private String poroda; 
private int age; 

{ 

name = \"Шарик\"; 
poroda = \"овчарка\"; 
age = 2; 

} 

public Dog(String x, String y, int z){ 

name = x; 
poroda = y; 
age = z; 

}}
```
[к оглавлению](#ООП-в-Java)

## Для чего в Java используются статические блоки инициализации?

Статические блоки инициализация используются для выполнения кода, который должен выполняться один раз при инициализации класса загрузчиком классов, в момент предшествующий созданию объектов этого класса при помощи конструктора.

Такой блок (в отличие от нестатических, принадлежащих конкретном объекту класса) принадлежит только самому классу (объекту метакласса Class).

Статические блоки инициализации в Java используются для инициализации статических полей класса или выполнения других операций, которые должны быть выполнены один раз при загрузке класса или перед его первым использованием.

Вот несколько случаев, когда статические блоки инициализации могут быть полезны:

Инициализация статических полей: Статический блок инициализации может использоваться для установки начальных значений статических полей класса. Это может быть полезно, если значения этих полей зависят от сложных вычислений или требуют взаимодействия с внешними ресурсами, такими как база данных или файловая система.
```java
public class MyClass {
    public static int myStaticField;
    
    static {
        // Выполнение сложных вычислений или взаимодействие с внешними ресурсами
        myStaticField = calculateInitialValue();
    }
    
    // Остальной код класса
}
```
Загрузка драйверов или инициализация внешних ресурсов: Статические блоки инициализации могут использоваться для загрузки драйверов или инициализации внешних ресурсов, таких как библиотеки или конфигурационные файлы. Это позволяет выполнить эти операции один раз при загрузке класса, а не каждый раз при создании объекта.
```java
public class DatabaseConnection {
    static {
        // Загрузка драйвера базы данных
        try {
            Class.forName("com.mysql.jdbc.Driver");
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
    
    // Остальной код класса
}
```
Обработка исключений: Статические блоки инициализации могут использоваться для обработки исключений, которые могут возникнуть при инициализации статических полей или выполнении других операций. Это позволяет обработать исключения на этапе загрузки класса и принять соответствующие меры, например, вывести сообщение об ошибке или выполнить альтернативные действия.
```java
public class MyClass {
    public static int myStaticField;
    
    static {
        try {
            // Выполнение операции, которая может вызвать исключение
            myStaticField = performInitialization();
        } catch (Exception e) {
            // Обработка исключения
            e.printStackTrace();
        }
    }
    
    // Остальной код класса
}
```
Статические блоки инициализации выполняются в порядке их появления в коде и выполняются только один раз при загрузке класса. Они могут быть полезны для выполнения сложных инициализаций, загрузки ресурсов или обработки исключений, связанных с классом или его статическими полями.

[к оглавлению](#ООП-в-Java)

## Что произойдет, если в блоке инициализации возникнет исключительная ситуация?

Если блок статический – ExceptionInInitializerError,

Да, вы правы. Если исключение не обработано в статическом блоке инициализации, оно будет обернуто в `ExceptionInInitializerError` и проброшено из блока инициализации. `ExceptionInInitializerError` является подклассом `Error` и представляет ошибку инициализации класса. 

Вот пример, демонстрирующий выбрасывание `ExceptionInInitializerError` при возникновении исключения в статическом блоке инициализации:

```java
public class MyClass {
    static {
        throw new RuntimeException("Exception occurred in static initialization block");
    }

    public static void main(String[] args) {
        try {
            MyClass instance = new MyClass(); // Возникнет ExceptionInInitializerError
        } catch (ExceptionInInitializerError e) {
            e.printStackTrace();
        }
    }
}
```
В данном примере, при создании экземпляра класса `MyClass` будет выброшено исключение в статическом блоке инициализации. Это приведет к возникновению `ExceptionInInitializerError`, которое будет перехвачено в блоке `catch` и выведено на консоль.

`ExceptionInInitializerError` обычно указывает на серьезную ошибку инициализации класса, и после его возникновения класс становится непригодным для использования.

Если нестатический – вылетит само исключение.

Если в нестатическом блоке инициализации возникнет исключительная ситуация (исключение), то выполнение программы будет прервано, и исключение будет передано обработчику исключений. Дальнейшее выполнение программы зависит от того, есть ли обработчик исключений для данного типа исключения.

Если в коде, вызывающем нестатический блок инициализации, есть обработчик исключений для данного типа исключения, то управление будет передано в этот обработчик. Обработчик может выполнить определенные действия, чтобы обработать исключение, например, вывести сообщение об ошибке или выполнить альтернативные действия.

Если в коде, вызывающем нестатический блок инициализации, нет обработчика исключений для данного типа исключения, то исключение будет передано выше по стеку вызовов, и программа завершится с сообщением об ошибке и трассировкой стека.

В любом случае, исключение в нестатическом блоке инициализации может привести к некорректному состоянию объекта или программы в целом, поэтому важно обрабатывать исключения правильно и принимать соответствующие меры для восстановления или завершения программы в безопасном состоянии.

Для нестатических блоков инициализации, если выбрасывание исключения прописано явным образом требуется, чтобы объявления этих исключений были перечислены в throws всех конструкторов класса. Иначе будет ошибка компиляции.

Для статического блока выбрасывание исключения в явном виде, приводит к ошибке компиляции. 

В остальных случаях, взаимодействие с исключениями будет проходить так же как и в любом другом месте.

Класс не будет инициализирован, если ошибка происходит в статическом блоке и объект класса не будет создан, если ошибка возникает в нестатическом блоке.

[к оглавлению](#ООП-в-Java)

## Какое исключение выбрасывается при возникновении ошибки в блоке инициализации класса?

Если возникшее исключение - наследник RuntimeException:
+ для статических блоков инициализации будет выброшено Java.lang.ExceptionInInitializerError;
+ для нестатических будет проброшено исключение-источник.

Если возникшее исключение - наследник Error, то в обоих случаях будет выброшено Java.lang.Error.

Исключение: Java.lang.ThreadDeath - смерть потока. В этом случае никакое исключение выброшено не будет.

[к оглавлению](#ООП-в-Java)

## Что такое класс Object?

Object это базовый класс для всех остальных объектов в Java. Любой класс наследуется от Object и, соответственно, наследуют его методы.

[к оглавлению](#ООП-в-Java)

## Какие методы есть у класса Object (перечислить все)? Что они делают?

Object это базовый класс для всех остальных объектов в Java. Любой класс наследуется от Object и, соответственно, наследуют его методы.

public boolean equals(Object obj) – служит для сравнения объектов по значению; == по ссылке.

int hashCode() – возвращает hash код для объекта;

String toString() – возвращает строковое представление объекта;

Class getClass() – возвращает класс объекта во время выполнения;

protected Object clone() – создает и возвращает копию объекта;

void notify() – возобновляет поток, ожидающий монитор;

void notifyAll() – возобновляет все потоки, ожидающие монитор;

void wait() – остановка вызвавшего метод потока до момента пока другой поток не вызовет метод notify() или notifyAll() для этого объекта;

void wait(long timeout) – остановка вызвавшего метод потока на определённое время или пока другой поток не вызовет метод notify() или notifyAll() для этого объекта;

void wait(long timeout, int nanos) – остановка вызвавшего метод потока на определённое время или пока другой поток не вызовет метод notify() или notifyAll() для этого объекта;

protected void finalize() – может вызываться сборщиком мусора в момент удаления объекта при сборке мусора.

[к оглавлению](#ООП-в-Java)

## Расскажите про equals и hashcode

Метод equals() - определяет отношение эквивалентности объектов.

При сравнение объектов с помощью == сравнение происходит лишь между ссылками. При сравнении по переопределённому разработчиком equals() - по внутреннему состоянию объектов.

Какими свойствами обладает порождаемое equals() отношение эквивалентности?

+ Рефлексивность: для любой ссылки на значение x, x.equals(x) вернет true;
+ Симметричность: для любых ссылок на значения x и y, x.equals(y) должно вернуть true, тогда и только тогда, когда y.equals(x) возвращает true.
+ Транзитивность: для любых ссылок на значения x, y и z, если x.equals(y) и y.equals(z) возвращают true, тогда и x.equals(z) вернёт true;
+ Непротиворечивость: для любых ссылок на значения х и у, если несколько раз вызвать х.equals(y), постоянно будет возвращаться значение true либо постоянно будет возвращаться значение false при условии, что никакая информация, используемая при сравнении объектов, не поменялась.
+ Для любой ненулевой ссылки на значение х выражение х.equals(null) должно возвращать false.

Метод hashCode() необходим для вычисления хэш кода переданного в качестве входного параметра объекта.

В Java это целое число, в более широком смысле - битовая строка фиксированной длины, полученная из массива произвольной длины.

Этот метод реализован таким образом, что для одного и того же входного объекта, хэш код всегда будет одинаковым.

Следует понимать, что в Java множество возможных хэш кодов ограничено типом int, а множество объектов ничем не ограничено. Из-за этого, вполне возможна ситуация, что хэш коды разных объектов могут совпасть:

+ если хэш коды разные, то и объекты гарантированно разные;
+ если хэш коды равны, то объекты могут не обязательно равны.
+ для одного и того-же объекта, хеш-код всегда будет одинаковым;
+ если объекты одинаковые, то и хеш-коды одинаковые (но не наоборот).

> **Общий совет: выбирать поля, которые с большой долью вероятности будут различаться. Для этого необходимо использовать уникальные, лучше всего примитивные поля, например такие как id, uuid. При этом нужно следовать правилу, если поля задействованы при вычислении hashCode(), то они должны быть задействованы и при выполнении equals().**

[к оглавлению](#ООП-в-Java)

## Каким образом реализованы методы hashCode() и equals() в классе Object?
```java
public boolean equals(Object obj) { return (this == obj);} 

public native int hashCode();
```
native означает, что реализация данного метода выполнена на другом языке (здесь на C++) и обычно возвращает адрес объекта в памяти.

[к оглавлению](#ООП-в-Java)

## Зачем нужен equals(). Чем он отличается от операции ==?

Метод equals() - определяет отношение эквивалентности объектов.

При сравнении объектов с помощью == сравнение происходит лишь между ссылками.

При сравнении по переопределённому разработчиком equals() - по внутреннему состоянию объектов.

[к оглавлению](#ООП-в-Java)

## Правила переопределения equals()

+ Использование оператора == для проверки, является ли аргумент ссылкой на указанный объект. Если является, возвращается true. Если сравниваемый объект == null, должно вернуться false.
+ Использование оператор instanceof и вызова метода getClass() для проверки, имеет ли аргумент правильный тип. Если не имеет, возвращается false.
+ Приведение аргумента к правильному типу. Поскольку эта операция следует за проверкой instanceof она гарантированно будет выполнена.
+ Обход всех значимых полей класса и проверка того, что значение поля в текущем объекте и значение того же поля в проверяемом на эквивалентность аргументе соответствуют друг другу. Если проверки для всех полей прошли успешно, возвращается результат true, в противном случае - false.
+ По окончанию переопределения метода equals() следует проверить: является ли порождаемое отношение эквивалентности рефлексивным, симметричным, транзитивным и непротиворечивым? Если ответ отрицательный, метод подлежит соответствующей правке.

При переопределении метода `equals()` в Java следует соблюдать следующие правила:

1. Рефлексивность: Метод `equals()` должен быть рефлексивным, то есть для любого ненулевого объекта `x` выражение `x.equals(x)` должно возвращать `true`.

2. Симметричность: Метод `equals()` должен быть симметричным, то есть для любых ненулевых объектов `x` и `y` выражение `x.equals(y)` должно возвращать `true`, если и только если `y.equals(x)` также возвращает `true`.

3. Транзитивность: Метод `equals()` должен быть транзитивным, то есть для любых ненулевых объектов `x`, `y` и `z`, если `x.equals(y)` возвращает `true` и `y.equals(z)` возвращает `true`, то `x.equals(z)` также должен возвращать `true`.

4. Консистентность: Метод `equals()` должен быть консистентным, то есть для любых ненулевых объектов `x` и `y`, повторные вызовы `x.equals(y)` должны возвращать одинаковый результат, если никакие поля объектов не изменились.

5. Непротиворечивость с `null`: Метод `equals()` должен возвращать `false`, если аргумент, переданный в метод, равен `null`. То есть для любого ненулевого объекта `x`, `x.equals(null)` должно возвращать `false`.

6. Согласованность с `hashCode()`: Если два объекта равны по методу `equals()`, их хэш-коды, возвращаемые методом `hashCode()`, также должны быть равными. Обратное правило не обязательно выполняется: равные хэш-коды не гарантируют равенство объектов.

При переопределении метода `equals()` в пользовательском классе рекомендуется использовать оператор `instanceof`, чтобы проверить, является ли переданный объект экземпляром того же класса, что и текущий объект. Затем можно сравнивать поля объектов на равенство, используя методы `equals()` для каждого поля.

Пример правильной реализации метода `equals()` в пользовательском классе:

```java
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null || getClass() != obj.getClass()) {
        return false;
    }
    MyClass other = (MyClass) obj;
    // Сравнение полей объектов на равенство
    return field1.equals(other.field1) && field2.equals(other.field2);
}
```

Правильная реализация метода `equals()` позволяет корректно сравнивать объекты на равенство и использовать их в коллекциях, таких как `HashSet` или `HashMap`.

[к оглавлению](#ООП-в-Java)

## Что будет, если переопределить equals() не переопределяя hashCode()?

Классы и методы, которые используют правила этого контракта могут работать некорректно.

Так для HashMap это может привести к тому, что пара «ключ-значение», которая была в нее помещена при использовании нового экземпляра ключа не будет в ней найдена. В HashSet при добавлении объект сначала сравнивается хэш добавляемого и существующие (быстрая проверка очень экономит время), если хэш одинаковый – то дальше сравнивается по equals.

Вы обязаны переопределять оба метода equals() и hashCode() в Java. Метод hashCode используется в hash -коллекциях(например HashSet), и чем меньше будет коллизий (одинаковый код при разных объектах) тем эффективнее эти коллекции будут работать с объектами вашего класса.

Хеш-таблицы в Java используют метод hashCode() для определения индекса, по которому объекты будут храниться внутри таблицы. Когда вы добавляете объект в хеш-таблицу, она вычисляет хеш-код объекта и использует его для определения места, где объект будет храниться. Затем, при поиске объекта в хеш-таблице, она снова вычисляет хеш-код и сравнивает его с хеш-кодами объектов, уже хранящихся в таблице, чтобы найти соответствующий объект.

Если вы переопределите equals() без переопределения hashCode(), это может привести к ситуации, когда два объекта, которые равны согласно equals(), имеют разные хеш-коды. В результате, хеш-таблица не сможет найти объект, даже если он уже присутствует в таблице, и это может привести к неправильному функционированию структуры данных.

Кроме того, если вы используете объекты, переопределяющие equals(), в коллекциях, которые основаны на равенстве объектов (например, HashSet или HashMap), то несогласованные методы equals() и hashCode() могут привести к непредсказуемому поведению. Например, объекты могут быть добавлены в коллекцию несколько раз, даже если они равны по содержимому.

[к оглавлению](#ООП-в-Java)

## Какой контракт между hashCode() и equals()?

Соглашение между equals и hashCode в Java:
+ Если объекты равны по результатам выполнения метода equals, тогда их hashcode должны быть одинаковыми.
+ Если объекты не равны по результатам выполнения метода equals, тогда их hashcode могут быть как одинаковыми, так и разными. Однако для повышения производительности, лучше, чтобы разные объекты возвращали разные коды.

вызов метода hashCode один и более раз над одним и тем же объектом должен возвращать одно и то же хэш-значение, при условии что поля объекта, участвующие в вычислении значения, не изменялись.

[к оглавлению](#ООП-в-Java)

## Для чего нужен метод hashCode()?

Интересная статья на хабр - https://habr.com/ru/articles/165683/

Каждый объект в программе можно представить в виде некоторого целого числа. Процесс вычисления такого числа называется хешированием, а его результат — хешем. Метод hashCode() генерирует хеш для объектов, чтобы их легче было сортировать и искать.

Метод hashCode() необходим для вычисления хэш кода переданного в качестве входного параметра объекта.

В Java это целое число, в более широком смысле - битовая строка фиксированной длины, полученная из массива произвольной длины. Этот метод реализован таким образом, что для одного и того же входного объекта, хэш код всегда будет одинаковым.

Следует понимать, что в Java множество возможных хэш кодов ограничено типом int, а множество объектов ничем не ограничено. Из-за этого, вполне возможна ситуация, что хэш коды разных объектов могут совпасть:

+ если хэш коды разные, то и объекты гарантированно разные;
+ если хэш коды равны, то объекты могут не обязательно равны.

[к оглавлению](#ООП-в-Java)

##  Правила переопределения метода hashcode()

Если хеш-коды разные, то и входные объекты гарантированно разные.

Если хеш-коды равны, то входные объекты не всегда равны.

При вычислении хэш-кода следует использовать те же поля, которые сравниваются в equals и которые не вычисляются на основе других значений.

Для правильной реализации метода в Java определен список следующих требований:

+ Во-первых, если вызов метода hashCode() выполняется неоднократно над одним и тем же объектом, то во всех случаях он должен возвращать одинаковое значение, учитывая, что над полями этого объекта не выполнялись какие-либо изменения.
+ Во-вторых, если вызов рассматриваемого метода выполняется над двумя равнозначными объектами, тогда он обязан возвращать одинаковый результат для обоих. Равенство таких объектов можно проверить благодаря методу equals(). Он должен вернуть true, если сравниваемые объекты равны.
+ И наконец, если возвращаемые результаты при вызове метода для двух объектов одинаковы, то это не гарантирует их равенства. Если они разные, то это гарантирует, что объекты не равны.
  
Представленные выше требования говорят о важности использования рассматриваемого метода вместе с equals() для сравнения объектов. Второй выполняет сравнение объектов, а первый в свою очередь показывает, изменилось ли состояние объекта. Это еще раз подтверждает, что при переопределении метода equals() нужно не забывать про переопределение hashCode().

Существует два варианта правильного переопределения метода hashCode() в Java:

+ Использование существующего алгоритма для собственной реализации переопределения. 
+ Использование вспомогательных методов для генерации хэш-кода.
  
Первый вариант предполагает выполнение следующих правил для переопределения hashCode() в Java:

+ Во-первых, необходимо исключить все избыточные поля, которые не участвуют в equals().
+ Во-вторых, следует выбрать базу — стартовое число, необходимое для расчета hash-кода объекта и присвоить его переменной total. Зачастую разработчики берут число 31, но вы можете выбрать иное значение. Многие IDE выполняют генерацию хэш-кода именно с этим числом.

Далее для каждого из оставшихся полей после исключения проводится расчет хэша. Ниже будет приведена таблица правил вычисления для возможных типов полей:

<img width="547" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/541f79d0-0b3c-4b86-bff5-0ebf633bda05">

Следующее правило гласит, что нужно прибавить рассчитанный хэш каждого из полей (допустим, это переменная compute) к переменной total:
```java
total = 31 * total + compute;
```
И наконец, необходимо вернуть итоговое значение переменной total после выполнения всех расчетов.

Второй вариант предполагает использование вспомогательных методов для генерации хэш-кода, которые доступны благодаря классу java.util.Objects, начиная с версии Java 8+. Пример данной реализации приведен ниже: 
```java
@Override
public int hashCode() {
    return Objects.hash(FCs, city, experience, department);
}
```
У всех стандартных ссылочных типов данных в Java (String, Integer, Double и т. д.) методы equals() и hashCode() уже корректно переопределены. Поэтому их возможно спокойно интегрировать в коллекции HashMap, HashSet и другие.

[к оглавлению](#ООП-в-Java)

## Есть ли какие-либо рекомендации о том, какие поля следует использовать при подсчете hashCode()?

Общий совет: выбирать поля, которые с большой долью вероятности будут различаться. Для этого необходимо использовать уникальные, лучше всего примитивные поля, например такие как id, uuid. При этом нужно следовать правилу, если поля задействованы при вычислении hashCode(), то они должны быть задействованы и при выполнении equals().

[к оглавлению](#ООП-в-Java)

## Могут ли у разных объектов быть одинаковые hashCode()?

да, коллизия.

[к оглавлению](#ООП-в-Java)

## Почему нельзя реализовать hashcode() который будет гарантированно уникальным для каждого объекта?

Ограничение числа int, множество объектов больше чем множество hashcod-ов

[к оглавлению](#ООП-в-Java)

## Есть класс Point{int x, y;}. Почему хэш-код в виде 31 * x + y предпочтительнее чем x + y?

Множитель создает зависимость значения хэш кода от очередности обработки полей, что в итоге порождает лучшую хэш функцию.

Хэш-код в виде `31 * x + y` часто используется в качестве рекомендуемой реализации `hashCode()` для классов, содержащих два целочисленных поля, таких как `Point` с полями `x` и `y`. Это предпочтительный вариант по нескольким причинам:

1. Улучшенное распределение значений: Формула `31 * x + y` обеспечивает лучшее распределение хеш-кодов по возможным значениям. Это позволяет уменьшить вероятность коллизий, когда разные объекты имеют одинаковые хеш-коды. Формула `31 * x + y` производит более равномерное распределение значений, чем простое сложение `x + y`.

2. Учет порядка полей: Формула `31 * x + y` учитывает порядок полей `x` и `y` в хеш-коде. Это означает, что два объекта с разными значениями `x` и `y` будут иметь разные хеш-коды, даже если сумма `x + y` одинакова. Например, объекты `Point(1, 2)` и `Point(2, 1)` будут иметь разные хеш-коды, что может быть полезно, если порядок полей имеет значение для вашего класса.

3. Простота вычисления: Формула `31 * x + y` обеспечивает достаточно эффективное вычисление хеш-кода. Умножение на 31 может быть оптимизировано компилятором с использованием сдвигов и вычитаний, что делает вычисление хеш-кода быстрым и эффективным.

Хотя формула `31 * x + y` является рекомендуемой реализацией для `hashCode()` в данном случае, вам всегда следует выбирать формулу хеш-кода, которая наиболее соответствует требованиям вашего конкретного класса и его использования.

[к оглавлению](#ООП-в-Java)

## Чем a.getClass().equals(A.class) отличается от a instanceOf A.class

getClass() получает только класс, а оператор instanceof проверяет, является ли объект экземпляром класса или его потомком.
Оператор instanceof сравнивает объект и указанный тип. Его можно использовать для проверки, является ли данный объект экземпляром некоторого класса, либо экземпляром его дочернего класса, либо экземпляром класса, который реализует указанный интерфейс.

this.getClass() == that.getClass() проверяет два класса на идентичность, поэтому для корректной реализации контракта метода equals() необходимо использовать точное сравнение с помощью метода getClass().

Для equals всегда нужно сравнивать типы объектов через getClass. instanceof не соблюдает правило симметрии в наследниках.

> **Оператор instanceof нужен, чтобы проверить, был ли объект, на который ссылается переменная X, создан на основе какого-либо класса Y. Оператор instanceof проверяет именно происхождение объекта, а не переменной.**

[к оглавлению](#ООП-в-Java)
