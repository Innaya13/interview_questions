[Вопросы для собеседования](QUESTION.md)

# Многопоточность

+ [Чем процесс отличается от потока?](#чем-процесс-отличается-от-потока)
+ [Чем Thread отличается от Runnable? Когда нужно использовать Thread, а когда Runnable?](##чем-thread-отличается-от-runnable-когда-нужно-использовать-thread-а-когда-runnable)
+ [Как выполнить две задачи параллельно?](#как-выполнить-две-задачи-параллельно)
+ [Что такое монитор? Как монитор реализован в java?](#что-такое-монитор-как-монитор-реализован-в-java)
+ [Что такое синхронизация? Какие способы синхронизации существуют в java?](#что-такое-синхронизация-какие-способы-синхронизации-существуют-в-java)
+ [Как работают методы Object wait(), notify() и notifyAll()?](#как-работают-методы-wait-notify-и-notifyall)
+ [В каких состояниях может находиться поток?](#в-каких-состояниях-может-находиться-поток)
+ [Что такое семафор? Как он реализован в Java?](#что-такое-семафор-как-он-реализован-в-java)
+ [Что обозначает ключевое слово volatile? Почему операции над volatile переменными не атомарны?](#что-обозначает-ключевое-слово-volatile-почему-операции-над-volatile-переменными-не-атомарны)
+ [Расскажи про правила «happens-before» и Java Memory Model (JMM).](#расскажите-про-правила-happens-before-и-java-memory-model-jmm)
+ [Для чего нужны Atomic типы данных? Чем отличаются от volatile?](#для-чего-нужны-atomic-типы-данных-чем-отличаются-от-volatile)
+ [Что такое потоки демоны? Для чего они нужны? Как создать поток-демон?](#что-такое-потоки-демоны-для-чего-они-нужны-как-создать-поток-демон)
+ [Что такое приоритет потока? На что он влияет? Какой приоритет у потоков по умолчанию?](#что-такое-приоритет-потока-на-что-он-влияет-какой-приоритет-у-потоков-по-умолчанию)
+ [Как работает Thread.join()? Для чего он нужен?](#как-работает-threadjoin-для-чего-он-нужен)
+ [Чем отличаются методы yield() и sleep()?](#чем-отличаются-методы-yield-и-sleep)
+ [Как правильно остановить поток? Для чего нужны методы .stop(), .interrupt(), .interrupted(), .isInterrupted().](#как-правильно-остановить-поток-для-чего-нужны-методы-stop-interrupt-interrupted-isinterrupted)
+ [Чем Runnable отличается от Callable?](#чем-runnable-отличается-от-callable)
+ [Что такое FutureTask?](#что-такое-futuretask)
+ [Что такое deadlock?](#что-такое-deadlock)
+ [Что такое livelock?](#что-такое-livelock)
+ [Что такое race condition?](#что-такое-race-condition)
+ [Что такое Фреймворк fork/join? Для чего он нужен?](#что-такое-фреймворк-fork-join-для-чего-он-нужен)
+ [Что означает ключевое слово synchronized? Где и для чего может использоваться?](#что-означает-ключевое-слово-synchronized-где-и-для-чего-может-использоваться)
+ [Что является монитором у статического синхронизированного класса?](#что-является-монитором-у-статического-синхронизированного-класса)
+ [Что является монитором у не статического синхронизированного класса?](#что-является-монитором-у-нестатического-синхронизированного-класса)
+ [Способы управления потоками java.util.сoncurrent](#способы-управления-потоками-javautilсoncurrent)
+ [Расскажи про устройство и алгоритм работы ConcurrentHashMap](#расскажи-про-устройство-и-алгоритм-работы-concurrenthashmap)
+ [Что знаешь про CopyOnWriteArrayList?](#что-знаешь-про-copyonwritearraylist)
+ [Stream API & ForkJoinPool Как связаны, что это такое.](#stream-api--forkjoinpool-как-связаны-что-это-такое)
+ [Зачем используются thread local переменные?](#зачем-используются-thread-local-переменные)
+ [Как реализовать двусторонний обмен данными между потоками?](#как-реализовать-двусторонний-обмен-данными-между-потоками)
+ [Какими коллекциями пользоваться в многопоточной среде?](#какими-коллекциями-пользоваться-в-многопоточной-среде)

**Многопоточность в Java** — это одновременное выполнение двух или более потоков для максимального использования центрального процессора (CPU — central processing unit). 
Каждый поток работает параллельно и не требует отдельной области памяти. К тому же, переключение контекста между потоками занимает меньше времени. 

<img width="1069" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/c0d37564-6504-472e-a367-cb3716f53ef6">

+ [Threads - Java для тестировщиков](https://www.youtube.com/watch?v=0Aiw97_Y300)

+ [Deadlock - Concurrency #1 - Advanced Java](https://www.youtube.com/watch?v=s032s29-NUU)

+ [Многопоточность JavaRush](https://javarush.com/groups/posts/1992-mnogopotochnostjh-v-java-sutjh-pljusih-i-chastihe-lovushki-)

+ [Статья на Хабр - Многопоточность в Java](https://habr.com/ru/articles/164487/)

+ [Краткая статья на Хабр](https://habr.com/ru/articles/693244/)



## Чем процесс отличается от потока?

<img width="525" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/c4163a44-9d8a-475d-831f-18775486b6e7">

<img width="513" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/2d5c99c5-620b-4010-8d23-ac5c21c6fc47">

<img width="392" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/9ad57006-5678-4cc1-9957-f57963dae9c8">

Чем отличается процесс от потока?

Процесс — экземпляр программы во время выполнения, независимый объект, которому выделены системные ресурсы (например, процессорное время и память). Каждый процесс выполняется в отдельном адресном пространстве: один процесс не может получить доступ к переменным и структурам данных другого. Если процесс хочет получить доступ к чужим ресурсам, необходимо использовать межпроцессное взаимодействие. Это могут быть конвейеры, файлы, каналы связи между компьютерами и многое другое.

Для каждого процесса ОС создает так называемое «виртуальное адресное пространство», к которому процесс имеет прямой доступ. Это пространство принадлежит процессу, содержит только его данные и находится в полном его распоряжении. Операционная система же отвечает за то, как виртуальное пространство процесса проецируется на физическую память.

Поток(thread) — определенный способ выполнения процесса, определяющий последовательность исполнения кода в процессе. Потоки всегда создаются в контексте какого-либо процесса, и вся их жизнь проходит только в его границах. Потоки могут исполнять один и тот же код и манипулировать одними и теми же данными, а также совместно использовать описатели объектов ядра, поскольку таблица описателей создается не в отдельных потоках, а в процессах. Так как потоки расходуют существенно меньше ресурсов, чем процессы, в процессе выполнения работы выгоднее создавать дополнительные потоки и избегать создания новых процессов. 

Что такое «зеленые потоки» и есть ли они в Java?

Зелёные (легковесные) потоки(green threads) - потоки эмулируемые виртуальной машиной или средой исполнения. Создание зелёного потока не подразумевает под собой создание реального потока ОС.

Виртуальная машина Java берёт на себя заботу о переключении между разными green threads, а сама машина работает как один поток ОС. Это даёт несколько преимуществ. Потоки ОС относительно дороги в большинстве POSIX-систем. Кроме того, переключение между native threads гораздо медленнее, чем между green threads.

Это всё означает, что в некоторых ситуациях green threads гораздо выгоднее, чем native threads. Система может поддерживать гораздо большее количество green threads, чем потоков OС. Например, гораздо практичнее запускать новый green thread для нового HTTP-соединения к веб-серверу, вместо создания нового native thread.

Однако есть и недостатки. Самый большой заключается в том, что вы не можете исполнять два потока одновременно. Поскольку существует только один native thread, только он и вызывается планировщиком ОС. Даже если у вас несколько процессоров и несколько green threads, только один процессор может вызывать green thread. И всё потому, что с точки зрения планировщика заданий ОС всё это выглядит одним потоком.

Начиная с версии 1.2 Java поддерживает native threads, и с тех пор они используются по умолчанию.


Потоки выполнения процесса можно уподобить нескольким вместе работающим поварам. Все они готовят одно блюдо, читают одну и ту же кулинарную книгу с одним и тем же рецептом и следуют его указаниям, причём не обязательно все они читают на одной и той же странице.

ПОТОКИ:

+ Поток имеет стэк – свою память для исполнения. 
+ Потоки выполнения существуют как составные элементы процессов
+ Несколько потоков выполнения внутри процесса совместно используют информацию о состоянии,а также память и другие вычислительные ресурсы
+ Потоки выполнения совместно используют их адресное пространство
+ Переключение контекста между потоками выполнения в одном процессе,  как правило, быстрее, чем переключение контекста между процессами.
+ Потоки расходуют существенно меньше ресурсов, чем процессы, в процессе выполнения работы выгоднее создавать дополнительные потоки и избегать создания новых процессов

ПРОЦЕССЫ:
+ Процесс – это совокупность кода и данных, функционирующих в виртуальном (адресном) пространстве.
+ Процессы, как правило, независимы
+ Несут значительно больше информации о состоянии
+ Операционная система (ОС) для каждого процесса создает своё, так называемое «виртуальное адресное пространство» в памяти, к которому процесс имеет прямой доступ.
+ Процессы взаимодействуют только через предоставляемые системой механизмы связей между процессами (файлы, каналы связи..)

Когда запускается любое приложение, то начинает выполняться поток, называемый главным потоком (main). От него порождаются дочерние потоки. Главный поток, как правило, является последним потоком, завершающим выполнение программы.

Несмотря на то, что главный поток создаётся автоматически, им можно управлять через объект класса Thread. Для этого нужно вызвать метод currentThread(), после чего можно управлять потоком.

Класс Thread содержит несколько методов для управления потоками.

getName() - получить имя потока

getPriority() - получить приоритет потока

isAlive() - определить, выполняется ли поток

join() - ожидать завершение потока

run() - запуск потока. В нём пишите свой код

sleep() - приостановить поток на заданное время

start() - запустить поток, запускает переопределенный метод run(). Если просто запустить run() не будет параллельности выполнения просто выполниться метод run() 

Процесс – последовательное выполнение программы.  Поток — наименьшее составляющее процесса или легковесный процесс. 
 
Многопоточность – это принцип построения программы, при котором несколько блоков кода могут выполняться одновременно.  
 
Цели:  
+ производительность (разбираем задачу на более мелкие)  
+ параллелизм или concurrency (одновременное выполнение нескольких задач) 
 
На одно ядро процессора, в каждый момент времени, приходится одна единица исполнения. То есть одноядерный процессор может обрабатывать команды только последовательно, по одной за раз (в упрощенном случае).  
 
Однако запуск нескольких параллельных потоков возможен и в системах с одноядерными процессорами. В этом случае система будет периодически переключаться между потоками, поочередно давая выполняться то одному, то другому потоку. Такая схема называется псевдо-параллелизмом. Система запоминает состояние (контекст) каждого потока, перед тем как переключиться на другой поток, и восстанавливает его по возвращению к выполнению потока. 
 
Если потоки не синхронизированы, то каждый раз в консоли будет разный результат. 
 
Процессы в Java: определение и функции 
+ Процесс состоит из кода и данных. Он создается операционной системой при запуске приложения, является достаточно ресурсоемким и обладает собственным виртуальным адресным пространством. 
+ Процессы работают независимо друг от друга, они не имеют прямого доступа к общим данным в других процессах. 
+ Операционная система ОС выделяет ресурсы для процесса — память и время на выполнение.
+ Если один из процессов заблокирован, то ни один другой процесс не может выполняться, пока он не будет разблокирован.
+ Для создания нового процесса обычно дублируется родительский процесс.
+ Процесс может контролировать дочерние процессы, но не процессы того же уровня.

**Что такое потоки**

Поток — наименьшее составляющее процесса. Потоки могут выполняться параллельно друг с другом. Их также часто называют легковесными процессами.  

Они используют адресное пространство процесса и делят его с другими потоками. 

Потоки могут контролироваться друг другом и общаться посредством методов Object wait(), notify(), notifyAll(). 
 
При запуске программы операционная система создает процесс, загружая в его адресное пространство код и данные программы, а затем запускает главный поток созданного процесса.  

Процессы и потоки связаны друг с другом, но при этом имеют существенные различия.
-------
Процесс — экземпляр программы во время выполнения, независимый объект, которому выделены системные ресурсы (например, процессорное время и память). Каждый процесс выполняется в отдельном адресном пространстве: один процесс не может получить доступ к переменным и структурам данных другого. Если процесс хочет получить доступ к чужим ресурсам, необходимо использовать межпроцессное взаимодействие. Это могут быть конвейеры, файлы, каналы связи между компьютерами и многое другое.

Поток использует то же самое пространства стека, что и процесс, а множество потоков совместно используют данные своих состояний. Как правило, каждый поток может работать (читать и писать) с одной и той же областью памяти, в отличие от процессов, которые не могут просто так получить доступ к памяти другого процесса. У каждого потока есть собственные регистры и собственный стек, но другие потоки могут их использовать.

Поток — определенный способ выполнения процесса. Когда один поток изменяет ресурс процесса, это изменение сразу же становится видно другим потокам этого процесса.

[к оглавлению](#многопоточность)

## Чем Thread отличается от Runnable? Когда нужно использовать Thread, а когда Runnable? 

<img width="630" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/83a22522-f3a2-435d-9d45-86025ea39ed8">

<img width="572" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/d06a3bac-718a-4187-8bdf-ece559513b12">
 
Ответ что тред — это класс, а ранбл интерфейс - считается неполным,  нужно рассказать подробно. 
 
Способы запуска потоков 
 
1) Приложение, **создающее экземпляр класса Thread**, должно предоставить код, который будет работать в этом потоке. Существует два способа, чтобы добиться этого: 
 
+ Использовать подкласс Thread. Класс Thread сам реализует Runnable, хотя его метод run не делает ничего.
+ Можно объявить класс Thread подклассом, предоставляя собственную реализацию метода run, как в примере справа. 

> Чтобы породить новый поток нужно: 
> 1)Создать объект класса Thread 
> 2)Передать в него метод, который нужно выполнить 
> 3)Вызвать у созданного объект Thread метод start(). 
> 
> Этот способ больше подходит для простых приложений, но есть условие: класс задачи должен быть потомком Thread.

2) **Предоставить реализацию объекта Runnable**.  Интерфейс Runnable определяет единственный метод — run, который должен содержать код, выполняющийся в потоке. Объект Runnable передается конструктору Thread. Например: 

<img width="569" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/7a38a789-42bd-498d-840d-b6a506603c57">

Объект может превратить отличный от Thread класс в подкласс.  Этот способ более общий и гибкий и может использоваться для высокоуровневых API управления потоками. 

Оба примера вызывают Thread.start, чтобы запустить новый поток. 

<img width="1060" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/6217ebf9-8406-4a1d-ad4f-6fba12cf62a1">

<img width="1059" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/8412beac-fc27-4dd0-8a79-d083b7d4f387">

Чем различаются Thread и Runnable?

+ Thread - это класс, некоторая надстройка над физическим потоком.
+ Runnable - это интерфейс, представляющий абстракцию над выполняемой задачей.

Помимо того, что Runnable помогает разрешить проблему множественного наследования, несомненный плюс от его использования состоит в том, что он позволяет логически отделить логику выполнения задачи от непосредственного управления потоком.

В чём заключается разница между методами start() и run()?

Несмотря на то, что start() вызывает метод run() внутри себя, это не то же самое, что просто вызов run(). Если run() вызывается как обычный метод, то он вызывается в том же потоке и никакой новый поток не запускается, как это происходит, в случае, когда вы вызываете метод start().

В Java существует два основных способа создания и использования параллельных потоков выполнения: через класс `Thread` и через интерфейс `Runnable`. Давайте рассмотрим их различия и ситуации, когда стоит использовать каждый из них:

1. **Thread (Класс Thread):**
   - `Thread` - это класс, предоставляемый Java для работы с потоками. Вы можете создать экземпляр этого класса и переопределить его метод `run()`, который содержит код, который будет выполняться в потоке.
   - Класс `Thread` реализует интерфейс `Runnable`, поэтому можно передать объект `Thread` в качестве аргумента конструктору другого объекта `Thread` или передать его внутрь конструктора `Thread`, если вы создаете собственный класс, расширяющий `Thread`.
   - Пример использования `Thread`:

```java
public class MyThread extends Thread {
    public void run() {
        // Код, выполняющийся в потоке
    }
}

// Создание и запуск потока
MyThread thread = new MyThread();
thread.start();
```

2. **Runnable (Интерфейс Runnable):**
   - `Runnable` - это функциональный интерфейс, который определяет метод `run()`. Вы можете создать свой собственный класс, реализующий этот интерфейс, и переопределить метод `run()` в этом классе.
   - Вместо создания подкласса `Thread` можно создать экземпляр объекта, реализующего `Runnable`, и передать его внутрь конструктора `Thread`.
   - Пример использования `Runnable`:

```java
public class MyRunnable implements Runnable {
    public void run() {
        // Код, выполняющийся в потоке
    }
}

// Создание объекта Runnable
MyRunnable myRunnable = new MyRunnable();

// Создание и запуск потока
Thread thread = new Thread(myRunnable);
thread.start();
```

**Когда использовать Thread, а когда Runnable:**
- Реализация `Runnable` обычно предпочтительнее, так как она позволяет более гибко управлять потоками и унаследовать другие классы, если это необходимо. Когда вы расширяете класс `Thread`, вы "используете" свой объект потока, и это может ограничить вашу способность наследовать другие классы.
- Использование `Runnable` также позволяет более легко разделять один и тот же объект Runnable между несколькими потоками, что может быть полезно в определенных сценариях.
- Однако в некоторых случаях использование класса `Thread` может быть удобным, если вам не требуется более высокого уровня абстракции, предоставляемого `Runnable`.

В общем случае, использование `Runnable` является более гибким и рекомендуемым подходом для работы с потоками.

-----------------

Наследование класса Thread целесообразно применять когда нужно дополнить функциональность самого класса Thread.

Использование интерфейса Runnable – когда просто нужно одновременно выполнить несколько задач и не требуется вносить изменений в сам механизм многопоточности.

[к оглавлению](#многопоточность)

## Как выполнить две задачи параллельно? 
 
Простейший, путь – явно создать два объекта типа Thread, передать им инстансы Runnable, с нужными задачами в реализации их методов run, и запустить вызвав thread.start(). Если в основном потоке нужно дождаться завершения задач, то после start() вызывается метод thread.join(). Исполнение зависнет на вызове этого метода до тех пор, пока тред не закончит свою задачу и не умрет. Вся работа задач с внешними данными должна быть синхронизирована. 
 
Такое ручное создание тредов полезно в учебных целях, но считается плохой практикой в промышленном коде: само создание – дорогостоящая операция, а большое количество случайно созданных потоков может приводить к проблеме голодания  потоков (starvation). 
 
В качестве продвинутой альтернативы используются пуллы потоков – реализации интерфейса ExecutorService.  
 
Такие сервисы создаются статическими фабричными методами класса Executors 
(исполнители). Они умеют принимать задачи в виде Runnable- или Callable- объектов на заранее созданном наборе потоков (собственно, пулле).  

Кроме самого пулла, экземпляры ExecutorService содержат фабрику потоков («инструкцию» как создать тред при необходимости), и коллекцию- очередь задач на исполнение (см. рисунок).

<img width="1100" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/d169d3d1-ae91-4d87-8185-a0fcc54f5355">

<img width="801" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/c8308bc8-cecb-42d7-a348-093f309621ed">

В ответ на передачу на исполнение Runnable или Callable, сервис возвращает связанный с ним объект типа Future – хранилище, которое будет заполнено результатом выполнения задачи в будущем. Даже если никакого результата не ожидается, Future поможет дождаться момента завершения обработки задачи (про это будет отдельный вопрос).

В Java существует несколько способов выполнения задач параллельно. Один из самых распространенных способов - использование многопоточности с помощью классов `Thread` или интерфейса `Runnable`, о которых я рассказывал в предыдущем ответе. Вот пример, как выполнить две задачи параллельно с использованием `Runnable`:

```java
public class ParallelExecutionExample {
    public static void main(String[] args) {
        Runnable task1 = new MyRunnable("Task 1");
        Runnable task2 = new MyRunnable("Task 2");

        Thread thread1 = new Thread(task1);
        Thread thread2 = new Thread(task2);

        thread1.start();
        thread2.start();
    }
}

class MyRunnable implements Runnable {
    private String name;

    public MyRunnable(String name) {
        this.name = name;
    }

    public void run() {
        System.out.println(name + " started");
        // Ваш код задачи
        System.out.println(name + " completed");
    }
}
```

Этот код создает два объекта `MyRunnable`, каждый из которых представляет задачу. Затем создаются и запускаются два потока - каждый для выполнения одной задачи.

Если вы используете Java 8 или более поздние версии, вы также можете воспользоваться `java.util.concurrent` API, предоставляющим более высокоуровневые средства для работы с многопоточностью. Например, можно использовать `ExecutorService` и `Future`:

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class ParallelExecutionExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(2);

        Future<?> future1 = executor.submit(new MyRunnable("Task 1"));
        Future<?> future2 = executor.submit(new MyRunnable("Task 2"));

        // Дожидаемся завершения задач
        try {
            future1.get();
            future2.get();
        } catch (Exception e) {
            e.printStackTrace();
        }

        executor.shutdown();
    }
}

class MyRunnable implements Runnable {
    private String name;

    public MyRunnable(String name) {
        this.name = name;
    }

    public void run() {
        System.out.println(name + " started");
        // Ваш код задачи
        System.out.println(name + " completed");
    }
}
```

Здесь используется `ExecutorService` для управления пулом потоков, и метод `submit()` используется для отправки задач на выполнение. `Future` предоставляет способ получить результат выполнения задачи и обработать возможные исключения. После завершения выполнения задач, пул потоков должен быть закрыт вызовом `shutdown()`.

<img width="398" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/44184b7a-22ee-41ea-8926-49a40850d0e2">

Защелку (CountdownLath) удобно использовать, чтобы потоки стартанули одновременно. 

[к оглавлению](#многопоточность)

## Что такое монитор? Как монитор реализован в java?

<img width="837" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/bd3f4b05-a837-44de-8343-4f8fb3570df7">

Мютекс («mutual exclusion» — «взаимное исключение») – это специальный объект для синхронизации нитей/процессов. Он может принимать два состояния – занят и свободен. Если упростить, то мютекс – это boolean-переменная, которая принимает два значения: занят(true) и свободен(false).

Шлагбаум

Когда тред хочет монопольно владеть некоторым объектом, он помечает его мютекс занятым, а когда закончил работу с ним – помечает его мютекс свободным.

Мютекс прикреплен к каждому объекту в Java. Прямой доступ к мютексу есть только у Java-машины. От программиста он скрыт.

А работать с мютексом в Java можно посредством монитора.

Монитор – это специальный механизм (кусок кода) гарантирует, что только один поток может выполнять данный раздел (или разделы) кода в любой момент времени.

Надстройка над мютексом, который обеспечивает правильную работу с ним. Ведь мало пометить, что объект занят, надо еще обеспечить, чтобы другие нити не пробовали воспользоваться занятым объектом.

В Java монитор реализован с помощью ключевого слова synchronized.

Когда ты пишешь блок synchronized, то компилятор Java заменяет его тремя кусками кода:

+ В начале блока synchronized добавляется код, который отмечает мютекс как занятый.
+ В конце блока synchronized добавляется код, который отмечает мютекс как свободный.
+ Перед блоком synchronized добавляется код, который смотрит, если мютекс занят – то нить должна ждать его освобождения.

Когда ты начинаешь писать код своей нити и в ней обращаешься к различным объектам своей программы, то при вызове каждого метода, ты должен задуматься – а безопасен (thread-safe) ли этот вызов? Все immutable объекты являются thread-safe.

Все объекты, к которым происходит обращение из разных нитей, должны быть thread-safe.

Только методы и блоки могут быть синхронизированы, но не переменные и классы. Если метод, в котором содержится критически важная «многопоточная» логика, статический, синхронизация будет осуществляться по классу.

**Монитор** – механизм синхронизации потоков, обеспечивающий корректную работу и доступ к неразделяемым ресурсам при синхронизации. Частью монитора является mutex, который встроен в класс Object и имеется у каждого объекта. 

Удобно представлять mutex как id захватившего его объекта (одноместный семафор). 
+ Если этот id равен 0, то ресурс свободен.  
+ Если этот id НЕ равен 0, то ресурс занят: встать в очередь и ждать освобождения.

В Java монитор реализован с помощью ключевого слова synchronized. 

<img width="590" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/834bfa04-2f9c-470b-ac39-08786351269a">

Пример из жизни: https://www.baeldung.com/cs/what-is-mutex  

<img width="595" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/601ce4d1-3158-44da-bb1f-f2c30acd3501">

> В чем проблема, для которой мьютексы являются решением? Представим ежедневную утреннюю встречу Scrum с пятью разработчиками и Scrum Master. Один пьёт кофе, другой хочет закончить работу, трое рады рассказать об успехах и начинают говорить одновременно. 
> Это заканчивается хаосом, и никто ничего не понимает. Скраммастер подходит и дает мяч одному из разработчиков и говорит: «Говорить может только тот, у кого мяч!». С этого момента они поняли друг друга и могли быстро завершить встречу.

--------

Мьютекс — поле для синхронизации потоков. Есть у каждого объекта в Java. Это простейший Семафор, который может находиться в одном из двух состояний: true или false.

Монитор — это дополнительная надстройка над Мьютексом.Блокирует объект именно монитор.

Когда один тред заходит внутрь synchronized блока кода, JVM тут же блокирует Mьютекс синхронизированного объекта.

[к оглавлению](#многопоточность)

## Что такое синхронизация? Какие способы синхронизации существуют в java? 

<img width="756" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/525a7e7b-37af-4aba-8ebb-9c0892310148">

Синхронизация – процесс, который позволяет выполнять потоки параллельно. В Java все объекты имеют блокировку, благодаря которой только один поток одновременно может получить доступ к критическому коду в объекте.  Такая синхронизация помогает предотвратить повреждение состояния объекта. 
 
Способы синхронизации в Java: 
+ Системная синхронизация с использованием wait() (ждать), notify() (уведомлять) 
 
Поток, который ждет выполнения каких-либо условий, вызывает у этого объекта метод wait(), предварительно захватив его монитор. На этом его работа приостанавливается.  
 
Другой поток может вызвать на этом же самом объекте метод notify(), предварительно захватив монитор объекта. В результате, ждущий на объекте поток «просыпается» и продолжает свое выполнение. В обоих случаях монитор надо захватывать в явном виде, через synchronized-блок, потому как методы wait() и notify() не синхронизированы! 
 
+ Системная синхронизация с использованием join() (присоединяться) 
 
Метод join(), вызванный у экземпляра класса Thread, позволяет текущему потоку остановиться до того момента, пока другой поток, связанный с этим объектом, закончит свою работу. 
 
+ Использование классов из пакета java.util.concurrent.locks - механизмы синхронизации потоков, альтернативы базовым synchronized (wait, notify, notifyAll): Lock, Condition, ReadWriteLock. 

-------

Синхронизация в программировании относится к механизмам управления доступом нескольких потоков исполнения к общим ресурсам, таким как переменные, объекты или участки кода. Основная цель синхронизации - обеспечить правильное и безопасное взаимодействие между потоками, чтобы избежать состояний гонки и других проблем, связанных с параллельным выполнением кода.

В Java существует несколько способов реализации синхронизации:

1. **Synchronized методы и блоки**: Ключевое слово `synchronized` может быть применено к методам и блокам кода. Если метод помечен как `synchronized`, только один поток может одновременно вызывать этот метод у одного объекта. Если блок кода помечен как `synchronized`, только один поток может выполнять код в этом блоке для данного объекта. Это обеспечивает монопольный доступ к синхронизированным ресурсам.

2. **Объекты монитора**: Каждый объект в Java является монитором, который можно использовать для синхронизации. Методы `wait()`, `notify()` и `notifyAll()` могут быть вызваны на объекте монитора для ожидания, уведомления другого потока или уведомления всех потоков, соответственно.

3. **ReentrantLock**: Это класс из пакета `java.util.concurrent.locks`, который предоставляет более гибкий и мощный способ управления блокировками. Он позволяет более точно управлять процессами блокировки и разблокировки, а также поддерживает справедливость блокировок.

4. **Semaphore**: Семафоры - это счетчики, которые контролируют количество потоков, которым разрешено одновременно выполнять определенный код.

5. **CountDownLatch**: Этот механизм позволяет потоку ждать до тех пор, пока не будет достигнуто определенное количество событий.

6. **CyclicBarrier**: Позволяет группе потоков ожидать друг друга на барьере, прежде чем они могут продолжить выполнение.

7. **ReadWriteLock**: Этот механизм разделяет блокировку на чтение и блокировку на запись, что может быть полезно в случае, когда несколько потоков могут одновременно читать данные, но только один поток может записывать.

Выбор конкретного способа синхронизации зависит от контекста и требований вашей программы. Важно правильно применять синхронизацию, чтобы избежать блокировок, состояний гонки и других проблем, связанных с параллельным выполнением кода.

[к оглавлению](#многопоточность)

## Как работают методы wait(), notify() и notifyAll()?

**wait()** 
+ Поток входит в блок Synchronized.
+ Объект-монитор - занят
+ Поток заблокировал монитор и не может работать дальше, т.к. каких-то данных еще не хватает – поток останавливается и ждет их, остальные потоки, которые ждут освобождения монитора, тоже ждут – очень дорого
+ Поток ставиться на паузу методом wait() - освобождает монитор для других потоков

**notify() (уведомить)**

Методы notify/notifyAll можно вызвать у объекта-монитора и только, когда этот монитор занят – т.е. внутри блока synchronized.

Метод notifyAll снимает с паузы все потоки, которые стали на паузу с помощью данного объекта-монитора.

{Висеть на методе wait() одного монитора могут сразу несколько потоков. При вызове notify() только один из них выходит из wait() и пытается захватить монитор, а затем продолжает работу со следующего после wait() оператора. Какой из них выйдет - заранее неизвестно.

А при вызове notifyAll(), все висящие на wait() потоки выходят из wait(), и все они пытаются захватить монитор.

Понятно, что в любой момент времени монитор может быть захвачен только одним потоком, а остальные ждут своей очереди.

Порядок очереди определяется планировщиком потоков Java.

> Планировщик потоков (Thread Scheduler) в Java - это часть операционной системы или виртуальной машины Java, которая управляет выполнением потоков в многозадачной среде. Его основная задача - распределение доступных ресурсов процессора и времени между различными потоками, работающими в программе. Планировщик потоков решает, какой поток будет выполняться в данный момент, а также определяет порядок смены потоков при переключении между ними.
>
> Операционные системы имеют свои собственные планировщики потоков для управления потоками на низком уровне. Виртуальные машины Java также предоставляют собственные планировщики, которые работают поверх планировщиков операционной системы и управляют потоками Java.
> 
> В Java планировщик потоков выполняет следующие задачи:
>
> 1. **Планирование выполнения**: Определяет, какие потоки будут запущены и продолжены, а также какое количество процессорного времени будет выделено каждому потоку.
>
> 2. **Переключение потоков**: Планировщик управляет переключением выполнения между разными потоками. Когда текущий поток временно блокируется (например, из-за ожидания ввода-вывода), планировщик может выбрать другой готовый к выполнению поток.
>
> 3. **Управление приоритетами**: Планировщик может учитывать приоритеты, назначенные потокам, и предоставлять больше времени выполнения потокам с более высоким приоритетом.
>
> 4. **Управление блокировками**: Планировщик также играет важную роль в случае блокировок и синхронизации, решая, какие потоки должны ожидать освобождения блокировок, чтобы избежать состояний гонки.
>
> Важно понимать, что планирование потоков может влиять на производительность и эффективность многопоточных программ. Правильное использование многопоточности и понимание работы планировщика помогут создавать более эффективные и отзывчивые приложения.

Методы wait(), notify(), notifyAll() должны вызываться только из синхронизированного кода. 

<img width="556" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/17501764-c062-4049-b715-c96a51690c87">
 
Для извещения потоком других потоков о своих действиях часто используются следующие методы: 
 
wait() – тормозит текущий поток на этом объекте (ждите) и отпускает его монитор (уступает дорогу). 
 
notify() – НЕ освобождает монитор и будит поток, у которого был ранее вызван метод wait(); 
 
notifyAll() – НЕ освобождает монитор и будит ВСЕ потоки, у которых ранее был вызван метод wait(); 
 
Часто этот вопрос формулируется как задача Producer-consumer* 
https://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem  
 
Эту задачу и практические задачи на многопоточность вообще при возможности лучше реализовывать на высокоуровневых примитивах синхронизации. Другой подход – воспользоваться также низкоуровневой, но оптимистической блокировкой на compareAndSet. Но обычно использование notify/wait (пессимистическая блокировка) 
– условие этого задания, то есть требуется реализовать уже существую BlockingQueue. 
 
Эти методы вместе с synchronized – самый низкий уровень пессимистических блокировок в Java, использующийся внутри реализации примитивов синхронизации.  
 
Еще с Java 5 в непосредственном использовании этих методов нет необходимости, но теоретические знания всё еще часто спрашивают на интервью.  
 
Чтобы вызывать эти методы у объекта, необходимо чтобы был захвачен его монитор (т.е. нужно быть внутри synchronized-блока на этом объекте). 

В противном случае будет выброшено IllegalMonitorStateException. Так что для полного ответа нужно понимать, как работает monitor lock (блок synchronized).

Вызов wait тормозит текущий поток на ожидание на этом объекте и отпускает его монитор. Исполнение продолжится, когда другой поток вызовет notify и отпустит 
блокировку монитора. Если на объекте ожидают несколько потоков, notify разбудит один случайный, notifyAll - все сразу.

<img width="487" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/a2155ce5-fbd1-453a-a031-c755a4f5c307">

В теории, ожидание wait может быть прервано без вызова notify, по желанию JVM (spurious wakeup). На практике это бывает крайне редко, но нужно страховаться и после вызова wait добавлять дополнительную проверку условия завершения ожидания.

Еще два нештатных случая завершения wait – прерывание потока извне и таймаут ожидания. В случае прерывания выбрасывается InterruptedException. Для таймаута нужно указать время ожидания параметрами метода wait. Значение 0 игнорируется.

<img width="832" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/75cd6862-f0e9-4f8c-89f2-edf072ee402d">

<img width="903" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/aa73ca08-3f87-4b81-9131-29aeb8b79657">

[к оглавлению](#многопоточность)

## В каких состояниях может находиться поток?

Потоки могут находиться в одном из следующих состояний:

**Новый (New).** После создания экземпляра потока, он находится в состоянии Новый до тех пор, пока не вызван метод start(). В этом состоянии поток не считается живым.
Thread twoThread = new Thread(\"Yulia\");

**Работоспособный (Runnable).** Поток переходит в состояние Работоспособный, когда вызывается метод start(). Поток может перейти в это состояние также из состояния Работающий или из состояния Блокирован. Когда поток находится в этом состоянии, он считается живым.
twoThread.start(); 

**Работающий (Running).** Поток переходит из состояния Работоспособный в состояние Работающий, когда Планировщик потоков выбирает его как работающий в данный момент.
Планировщик потоков выбирает поток

**Живой, но не работоспособный (Alive, but notrunnable).** Поток может быть живым, но неработоспособным по нескольким причинам:
Ожидание (Waiting). Поток переходит в состояние Ожидания, вызывая метод wait(). Вызов notify() или notifyAll() может перевести поток из состояния Ожидания в состояние Работоспособный.
wait() notify()

**Сон (Sleeping).** Метод sleep() переводит поток в состояние Сна на заданный промежуток времени в миллисекундах.
sleep()

**Блокировка (Blocked).** Поток может перейти в это состояние, в ожидании ресурса, такого как ввод/вывод или из-за блокировки другого объекта. В этом случае поток переходит в состояние Работоспособный, когда ресурс становится доступен.

**Мёртвый (Dead).** Поток считается мёртвым, когдаего метод run() полностью выполнен. Мёртвый поток не может перейти ни в какое другое состояние, даже если для него вызван метод start().

--------

<img width="912" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/d0605937-4c46-4621-987f-907d56c36196">

<img width="931" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/e2d88896-49b1-4687-8fb0-b81606250df5">

Жизненный цикл потока: 
 
Поток может находиться в одном из состояний, соответствующих элементам статически вложенного перечисления Thread.state: 
+ New – поток создан, но еще не запущен
+ Runnable – поток выполняется методы: start(), принудительное продолжение notify(), notifyAll().
+ Blocked – поток блокирован (состояние возникает при синхронизации: вызов методов помеченных, как synchronized)
+ Waiting – поток ждёт окончания работы другого потока или принудительного продолжения. Методы: join(), wait(), suspend() (deprecated).
+ Timed_waiting – поток некоторое время ждёт окончания другого потока. Методы: yield(), sleep(long mills), join(long timeout) и wait(long timeout).
+ Terminated – поток завершён. Методы: interrupt(), stop() (deprecated) или нормальное завершение метода run().
+ Dead — после того, как поток завершил свое выполнение, его состояние меняется на dead, то есть он завершает свой жизненный цикл.

Теперь, что касается "dead" (мёртвый) и "alive, but not runnable" (живой, но не готовый к выполнению), эти термины не являются официальными состояниями потоков в Java. Потоки, которые завершили выполнение, считаются завершёнными (TERMINATED). "Alive, but not runnable" может относиться к случаю, когда поток был создан, но пока не вошёл в состояние RUNNABLE. Это может произойти, например, если планировщик потоков операционной системы пока не выбрал этот поток для выполнения.

"Sleeping" (спящий) часто ассоциируется с состоянием TIMED_WAITING, когда поток находится в ожидании в течение определенного времени. "Dead" (мертвый) относится к потокам, которые завершили выполнение и не могут быть перезапущены.
 
Получить текущее значение состояния потока можно через getState(). 
 
> *Задача про обедающих философов — классический пример, используемый в информатике для иллюстрации проблем синхронизации при разработке параллельных алгоритмов и техник решения этих проблем.  
> Задача была сформулирована в 1965 году Эдсгером Дейкстрой как экзаменационное упражнение для студентов. В качестве примера был взят конкурирующий доступ к ленточному накопителю. Задача была сформулирована Энтони Хоаром в том виде, в каком она известна сегодня. 
> Пять безмолвных философов сидят вокруг круглого стола, перед каждым философом стоит тарелка спагетти. Вилки лежат на столе между каждой парой ближайших философов. 
> Каждый философ может либо есть, либо размышлять. Приём пищи не ограничен количеством оставшихся спагетти — подразумевается бесконечный запас. Тем не менее, философ может есть только тогда, когда держит две вилки — взятую справа и слева (альтернативная формулировка проблемы подразумевает миски с рисом и палочки для еды вместо тарелок со спагетти и вилок). 
> Каждый философ может взять ближайшую вилку (если она доступна) или положить — если он уже держит её. Взятие каждой вилки и возвращение её на стол являются раздельными действиями, которые должны выполняться одно за другим. 
> Вопрос задачи заключается в том, чтобы разработать модель поведения (параллельный алгоритм), при котором ни один из философов не будет голодать, то есть будет вечно чередовать приём пищи и размышления. 
> 
> Проблема: Задача сформулирована таким образом, чтобы иллюстрировать проблему избежания взаимной блокировки (deadlock) — состояния системы, при котором прогресс невозможен. 
> Варианты решения: официант (семафор), иерархия ресурсов (приоритизация), взаимоисключающая блокировка (мьютекс).  
> Загуглить или прочитать Wiki =) 

[к оглавлению](#многопоточность)

## Что такое семафор? Как он реализован в Java?

Semaphore – это новый тип синхронизатора: семафор со счётчиком, реализующий шаблон  синхронизации  Семафор.  Доступ  управляется  с  помощью  счётчика изначальное значение счётчика задаётся в конструкторе при создании синхронизатора, когда  поток  заходит  в  заданный  блок  кода,  то  значение  счётчика  уменьшается  на единицу, когда поток его покидает, то увеличивается. Если значение счётчика равно нулю, то текущий поток блокируется, пока кто-нибудь не выйдет из защищаемого блока.

Semaphore  используется  для  защиты  дорогих  ресурсов,  которые  доступны  в ограниченном количестве, например подключение к базе данных в пуле.

Установить количество разрешений для доступа к ресурсу можно с помощью конструкторов класса Semaphore:
```java
Semaphore(int permits)

Semaphore(int permits, boolean fair)
```
Параметр permits указывает на количество допустимых разрешений для доступа к ресурсу. Параметр fair во втором конструкторе позволяет установить очередность получения доступа. Если он равен true, то разрешения будут предоставляться ожидающим потокам в том порядке, в каком они запрашивали доступ. Если же он равен false, то разрешения будут предоставляться в неопределенном порядке.

Для получения разрешения у семафора надо вызвать метод acquire(), который имеет две формы:
```java
void acquire() throws InterruptedException

void acquire(int permits) throws InterruptedВxception
```
Для получения одного разрешения применяется первый вариант, а для получения нескольких разрешений - второй вариант.

После вызова этого метода пока поток не получит разрешение, он блокируется.

После окончания работы с ресурсом полученное ранее разрешение надо освободить с помощью метода release():
```java
void release()

void release(int permits)
```
Первый вариант метода освобождает одно разрешение, а второй вариант - количество разрешений, указанных в permits.

------
Короткий ответ: Semaphore – это новый тип синхронизатора: семафор со счётчиком, реализующий шаблон синхронизации Семафор.  
 
Доступ управляется с помощью счётчика: изначальное значение счетчика задается в конструкторе при создании синхронизатора, когда поток заходит в заданный блок кода, то значение счетчика уменьшается на единицу, когда поток его покидает, то увеличивается.  

<img width="587" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/05239939-7cc2-4af5-8add-433c2cdc482c">
 
Если значение счетчика равно нулю, то текущий поток блокируется, пока кто-нибудь не выйдет из защищаемого блока. Semaphore используется для защиты дорогих ресурсов, которые доступны в ограниченном количестве, например подключение к базе данных в пуле. 
 
Подробнее. Поток должен ждать. Ждать до тех пор, пока не удастся получить эксклюзивный доступ к ресурсу или пока не появятся задачи для исполнения. Один из механизмов ожидания, при котором поток не ставится на исполнение планировщиком ядра ОС, реализуется при помощи семафора. 
 
Семафор – один из старейших примитивов синхронизации. Он был изобретен Эдсгер Дейкстра в 1968 году. По большому счету это счетчик, который можно увеличивать и уменьшать из разных потоков.  
 
Уменьшение до 0 блокирует уменьшающий поток. Состояние, когда счетчик больше нуля называют сигнальное состояние, операцию его увеличения – release (освобождение) или signal, уменьшения – acquire (захват) или wait (ожидание). 
 
На практике можно представить, что release – выделение квоты доступа к критической секции программы, а acquire – использование необходимого объема доступной квоты, 
или ожидание, если её не хватает. Подробнее с деталями работы семафора поможет ознакомиться перевод статьи с картинками на хабре. https://habr.com/ru/post/261273/  

<img width="880" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/0ff39927-a9ad-4938-a012-cc9ef0ef6589">

В  Java семафор реализован классом Semaphore. Состоит этот класс в основном из разных форм методов acquire (с таймаутом, с игнорированием InterruptedException, 
неблокирующий) и release. Методы могут принимать параметр permits (разрешения) – тот самый объем квот, которые необходимо освободить/захватить.

Несколько вспомогательных методов позволяют узнать больше о количестве и составе очереди потоков, которые ждут освобождения пермитов. А методы availablePermits и drainPermits позволяют узнать количество оставшихся пермитов, и захватить их все соответственно. В конструкторе конфигурируются изначальное количество пермитов, и свойство fair (аналогичное свойству ReentrantLock).
```java
*Вопрос. Что будет если счётчик Семафора равен 1? 
Ответ. Тогда алгоритм работы Семафора будет такой же, как у Lock (открыто/закрыто).
```
Пример очереди к телефонной будке: 2 кабины, пять человек (Трегулов З.):

<img width="951" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/535901f2-e5b7-42ca-85fb-733964bf0c0d">

[к оглавлению](#многопоточность)

## Что обозначает ключевое слово volatile? Почему операции над volatile переменными не атомарны?

volatile - этот модификатор вынуждает потоки отключить оптимизацию доступа и использовать единственный экземпляр переменной. Если переменная примитивного типа – этого будет достаточно для обеспечения потокобезопасности. Если же переменная является ссылкой на объект – синхронизировано будет исключительно значение этой ссылки. Все же данные, содержащиеся в объекте, синхронизированы не будут!

![image](https://github.com/Oknel-Vap/Interview_questions/assets/116596752/d9cf8d22-1599-44fb-9065-6c9b63b80629)

может случиться такое когда кэш ядра 1 (поток1) возьмет переменную и изменит её и кэш ядра 2 (поток2) возьмет ту же переменную и изменит её. Возможно, что она не будет равна. Тогда кэши не будут когерентны («равны»).

volotaile (изменчивый) – переменная может быть изменена, она не будет кэшироваться (будет находиться в главной памяти), гарантирует когерентность кэшей. 

Операция, которая делает одно чтение/запись – атомарна. 

Операция, которая требует более одного чтения/записи - например, i++, который эквивалентен i = i + 1, который делает одно чтение и плюсует один - не является атомарным, поскольку другой поток может написать в i между чтением и записью.

-------------

<img width="925" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/89c5ab66-d4f3-4835-9ce0-4b337b341387">

Переменная volatile находится в хипе, а не в кэше стека! 
 
Volatile (eng. изменчивый, непостоянный). При создании многопоточных приложений мы можем столкнуться с двумя серьезными проблемами. Обе проблемы решаются с помощью всего одного ключевого слова — volatile. 
 
 
 
Что за проблемы?  
 
Во-первых, в процессе работы многопоточного приложения разные потоки могут кэшировать значения переменных.  
 
Возможна ситуация, когда один поток изменил значение переменной, а второй НЕ увидел этого изменения, потому что работал со своей, кэшированной копией переменной. 
 
См. дальше Java Memory Model (JMM) 
 
Во-вторых, в Java операции чтения и записи полей всех типов, кроме long и double, являются атомарными (состоят из одной части). 

<img width="966" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/f7ed308e-7667-4feb-8142-a282bec4d7f6">

Например, если в одном потоке меняешь значение переменной int, а в другом потоке читаешь значение этой переменной, то получишь либо ее старое значение, либо новое — то, которое получилось после изменения в потоке 1. Никаких «промежуточных вариантов» там появиться не может. Однако с long и double это не работает (64 бита). 
 
Почему? Из-за кроссплатформенности! https://youtu.be/ShzQJUFzq58?t=3014  

<img width="452" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/96b59b2a-7ed1-4cd0-bb35-2b55d83cf57a">

long и double — самые «тяжеловесные» примитивы в Java: они весят по 64 бита. И в некоторых 32-битных платформах просто не реализована атомарность чтения и записи 64-битных переменных.  
 
Такие переменные читаются и записываются в две операции. Сначала в переменную записываются первые 32 бита, потом еще 32. Соответственно, в этих случаях может возникнуть проблема.  
 
Один поток записывает какое-то 64-битное значение в переменную Х, и делает он это «в два захода». В то же время второй поток пытается прочитать значение этой переменной, причем делает это как раз посередине, когда первые 32 бита уже записаны, а вторые — еще нет.  В результате он читает промежуточное, некорректное значение, и получается ошибка. 
 
Если мы объявляем в программе какую-то переменную, со словом volatile, это означает: 
+ Переменная всегда будет атомарно читаться и записываться (даже если это 64битные double или long) 
+ Java-машина НЕ будет помещать ее в кэш. Так что ситуация, когда 10 потоков работают со своими локальными копиями исключена.

Для синхронизации значения переменной между потоками ключевое слово volatile используется тогда, когда только ОДИН поток может изменять значение этой переменной, а остальные потоки могут его только читать. 

----------
Для чего используется ключевое слово volatile, synchronized, transient, native?

volatile - этот модификатор вынуждает потоки отключить оптимизацию доступа и использовать единственный экземпляр переменной. Если переменная примитивного типа – этого будет достаточно для обеспечения потокобезопасности. Если же переменная является ссылкой на объект – синхронизировано будет исключительно значение этой ссылки. Все же данные, содержащиеся в объекте, синхронизированы не будут!

synchronized - это зарезервированное слово позволяет добиваться синхронизации в помеченных им методах или блоках кода.

Ключевые слова transient и native к многопоточности никакого отношения не имеют, первое используется для указания полей класса, которые не нужно сериализовать, а второе - сигнализирует о том, что метод реализован в платформо-зависимом коде.

-------
Переменная помеченная ключевым словом volatile является атомарной для чтения и записи. Операции над переменной помеченной volatile НЕ являются атомарными

Подробно:

Атомарная операция выглядит единой и неделимой командой процессора, которая может быть или уже выполненной или ещё невыполненной.

Если переменную сделать volatile, то запись и чтение происходит атомарно. НО если, происходит какая-то операция, например, инкримент, то уже атомарность не обеспечивается, потому что это сначала выполняется чтение(1), потом изменение(2) в локальной памяти, а затем запись(3). Такая операция не является атомарной и в неё может вклиниться поток по середине.

Источник: https://docs.oracle.com/javase/tutorial/essential/concurrency/atomic.html

> volatile обеспечивает только видимость (visibility) изменений, к атомарности он не имеет отношения. Классический пример со счетчиком: допустим есть поле volatile int i, к которому мы применим инкремент (декремент), возможна ситуация, когда два разных потока сначала проведут инкремент (декремент), а потом оба заберут результат двух инкрементов (декрементов). Такое воможно, потому что операции инкремента (декремента) не атомарны, а фактически состоят из последовательности операций, хотя и записываются одним выражением: i++ например.

[к оглавлению](#многопоточность)

## Расскажите про правила «happens-before» и Java Memory Model (JMM). 

Давайте с учетом этой информации запишем более полное определение happens-before:


Пусть есть поток T1 и поток T2 (необязательно отличающийся от потока T1) и действия x и y, выполняющиеся в потоках T1 и T2 соответственно
Если x happens-before y, то треду T2 во время выполнения y и всех действий, идущих в порядке программы позже, будут видны все изменения, выполняемые тредом T1 в x и всех действиях, идущих в порядке программе ранее
 
В Java основную часть работы по выделению времени и ресурсов потокам для выполнения их задач выполняет планировщик потоков, т.к. потоки выполняются в произвольном порядке, и чаще всего предсказать порядок невозможно.

<img width="970" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/09c2910d-657d-48d3-89bd-69f2e0cea8fc">

Описывает, КАК потоки должны взаимодействовать через общую память, определяет набор действий меж поточного взаимодействия, например: 
+ чтение и запись переменной 
+ захват и освобождений монитора
+ чтение и запись volatile переменной
+ запуск нового потока.  

JMM определяет отношение между этими действиями "happens-before" - абстракцией обозначающей, что если операция X связана отношением happens-before с операцией Y, то весь код следуемый за операцией Y, выполняемый в одном потоке, видит все изменения, сделанные другим потоком, до операции X.  

https://habr.com/ru/company/golovachcourses/blog/221133/  

<img width="942" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/b8b91c85-f2a1-4e8f-b10c-79f2219e07ba">

Можно выделить несколько основных областей, имеющих отношение к модели памяти: 
+ **Synchronized (синхронизация)**
  
При входе в synchronized метод или блок поток обновляет содержимое локальной памяти, а при выходе из synchronized метода или блока поток записывает изменения, сделанные в локальной памяти, в главную. Такое поведение synchronized методов и блоков следует из правил для отношения «happens-before». 
+ **Visibility (видимость)**

Один поток может временно сохранить значения некоторых полей не в основную память, а в регистры или локальный кэш процессора, таким образом второй поток, читая из основной памяти, может не увидеть последних изменений поля. И наоборот, если поток на протяжении какого-то времени работает с регистрами и локальными кэшами, читая данные оттуда, он может сразу не увидеть изменений, сделанных другим потоком в основную память. 

К вопросу видимости имеют отношение следующие ключевые слова языка Java: synchronized, volatile, final. 

С точки зрения Java все переменные (за исключением локальных переменных, объявленных внутри метода) хранятся в heap памяти, которая доступна всем потокам. Кроме этого, каждый поток имеет локальную (рабочую) память, где он хранит копии переменных, с которыми он работает, и при выполнении программы поток работает только с этими копиями.
+ **Volatile (волатильность, изменчивость) Запись volatile-переменных производится в основную память, минуя локальную.**

Чтение volatile переменной производится также из основной памяти, то есть значение переменной не может сохраняться в регистрах или локальной памяти потока, и операция чтения этой переменной гарантированно вернёт последнее записанное в неё значение. 
+ **Final (финализация)**

После того как объект был корректно создан, любой поток может видеть значения его final полей без дополнительной синхронизации. «Корректно создан» означает, что ссылка на создающийся объект не должна использоваться до тех пор, пока не завершился конструктор объекта.  

Рекомендуется изменять final поля объекта только внутри конструктора, в противном случае поведение не специфицировано. 
+ **Reordering (переупорядочивание)**

Для увеличения производительности процессор/компилятор могут переставлять местами некоторые инструкции/операции. Процессор может решить поменять порядок выполнения операций, если, например, сочтет что такая последовательность выполнится быстрее. Эффект может наблюдаться, когда один поток кладет результаты первой операции в регистр или локальный кэш, а результат второй операции попадает непосредственно в основную память. Тогда второй поток, обращаясь к основной памяти может сначала увидеть результат второй операции, и только потом первой, когда все регистры или кэши синхронизируются с основной памятью.  

Также регулируется набором правил «happens-before»: операции чтения и записи volatile переменных не могут быть переупорядочены с операциями чтения и записи других volatile и не-volatile переменных. 

----
Модель памяти Java (Java Memory Model, JMM) описывает поведение потоков в среде исполнения Java. Это часть семантики языка Java, набор правил, описывающий выполнение многопоточных программ и правил, по которым потоки могут взаимодействовать друг с другом посредством основной памяти. 
Program order - правило порядка выполнения программы.(Program order гарантирует, что в отдельных потоках оптимизация переупорядочения, введенная компилятором, не может привести к результатам, отличным от того, что произошло бы, если бы программа выполнялась послендовательно.)
Формально модель памяти определяет набор действий межпоточного взаимодействия (эти действия включают в себя, в частности, чтение и запись переменной, захват и освобождений монитора, чтение и запись volatile переменной, запуск нового потока), а также модель памяти определяет отношение между этими действиями -happens-before - абстракции обозначающей, что если операция A связана отношением happens-before с операцией B, то весь код следуемый за операцией B, выполняемый в одном потоке, видит все изменения, сделанные другим потоком, до операции A.

Существует несколько основных правил для отношения happens-before:
+ В рамках одного потока любая операция идущая в program order является - happens-before по отношению к любой операции следующей за ней в исходном коде;
+ Освобождение монитора (unlock) happens-before захват того же монитора (lock);
+ Выход из synchronized блока/метода happens-before вход в synchronized блок/метод на том же мониторе;
+ Запись volatile поля happens-before чтение того же самого volatile поля;
+ Завершение метода run() экземпляра класса Thread happens-before выход из метода join() или возвращение false методом isAlive() экземпляром того же потока;
+ Вызов метода start() экземпляра класса Thread happens-before начало метода run() экземпляра того же потока;
+ Завершение конструктора happens-before начало метода finalize() этого класса;
+ Вызов метода interrupt() на потоке happens-before обнаружению потоком факта, что данный метод был вызван либо путем выбрасывания исключения InterruptedException, либо с помощью методов isInterrupted() или interrupted().
+ Связь happens-before транзитивна, т.е. если X happens-before Y, а Y happens-before Z, то X happens-before Z.

Освобождение/захват монитора и запись/чтение в volatile переменную связаны отношением happens-before, только если операции проводятся над одним и тем же экземпляром объекта.

В отношении happens-before участвуют только два потока, о поведении остальных потоков ничего сказать нельзя, пока в каждом из них не наступит отношение happens-before с другим потоком.

[к оглавлению](#многопоточность)

## Для чего нужны Atomic типы данных? Чем отличаются от volatile?

Чтобы безопасно выполнять операции при параллельных вычислениях в нескольких потоках не используя при этом ни блокировок, ни синхронизацию synchronized.

Операция называется атомарной, если её можно безопасно выполнять при параллельных вычислениях в нескольких потоках, не используя при этом ни блокировок, ни синхронизацию synchronized.

volatile принуждает использовать единственный экземпляр переменной, но не гарантирует атомарность. Например, операция count++ не станет атомарной просто потому что count объявлена volatile. C другой стороны class AtomicInteger предоставляет атомарный метод для выполнения таких комплексных операций атомарно, например getAndIncrement() – атомарная замена оператора инкремента, его можно использовать, чтобы атомарно увеличить текущее значение на один. Похожим образом сконструированы атомарные версии и для других типов данных.

------
Начнем с того, что такое атомики и зачем нужны.  Atomic* – семейство классов из java.util.concurrent. Они предоставляют набор атомарных операций для соответствующих типов.  

Например, с помощью методов getAndIncrement и incrementAndGet класса AtomicInteger можно делать ЦЕЛОСТНЫМ неатомарный в обычных условиях инкремент 

<img width="959" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/46826220-af02-4d61-934a-ed1cd5ab1508">

Условно можно разделить подходы реализации большинства atomic-методов на две группы: compare-and-set и set-and-get. 
 
Методы категории compare-and-set принимают старое значение и новое. Если переданное старое значение совпало с текущим, устанавливается новое. 

Обычно делегируют вызов в методы класса Unsafe, которые заменяются нативными реализациями виртуальной машины. Виртуальная машина в большинстве случаев использует атомарную операцию процессора compare-and-swap (CAS).  

Поэтому атомики обычно более эффективны чем стандартная дорогостоящая блокировка. Все операции, которые нужны, происходят атомарно. В случае set-and-get старое значение неизвестно. Поэтому нужен небольшой трюк: программа сначала считывает текущее значение, а затем записывает новое, тоже с помощью CAS, потому что запись могла успеть поменяться даже за этот шаг. Эта попытка чтения + записи повторяется в цикле, пока старое значение не совпадет и переменная не будет успешно записана. 

Этот трюк называется double-checked или optimistic locking, и может быть использован и в пользовательском коде с любым способом синхронизации. Оптимистичность заключается в том, что мы надеемся что состояния гонки нет, прибегая к синхронизации только если гонка всё же случилась. Реализация оптимистичной блокировки может быть дана как отдельная задача. 

<img width="1043" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/a546e6e2-7c6f-40d1-9f18-7c84363060d1">

<img width="1056" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/d05004ca-2d9b-47ad-8209-dd7176387c28">

**Семейство Atomics** 

**AtomicBoolean, AtomicInteger, AtomicLong:**
+ Операции с этими классами работают быстрее, чем если синхронизироваться через synchronized/volatile;
+ Существуют методы для атомарного добавления на заданную величину, а также инкремент/декремент.
  
**AtomicIntegerArray, AtomicLongArray** – классы с массивами 

**AtomicReference** – класс для атомарных операций со ссылкой на объект. 

**AtomicMarkableReference** – класс для атомарных операций со следующей парой полей: 
+ ссылка на объект и битовый флаг true/false.

**AtomicStampedReference** – класс для атомарных операций со следующей парой полей: ссылка на объект и int значение. 

**AtomicReferenceArray** – массив ссылок на объекты, которые могут атомарно обновляться.

Примеры и устройство Atomics: 

<img width="1079" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/83bc75f8-e291-4024-a812-e3b25705f42c">

-------

В чём различия между volatile и Atomic переменными?

volatile принуждает использовать единственный экземпляр переменной, но не гарантирует атомарность. Например, операция count++ не станет атомарной просто потому что count объявлена volatile. C другой стороны class AtomicInteger предоставляет атомарный метод для выполнения таких комплексных операций атомарно, например getAndIncrement() – атомарная замена оператора инкремента, его можно использовать, чтобы атомарно увеличить текущее значение на один. Похожим образом сконструированы атомарные версии и для других типов данных.

В чём заключаются различия между java.util.concurrent.Atomic*.compareAndSwap() и java.util.concurrent.Atomic*.weakCompareAndSwap()?
+ weakCompareAndSwap() не создает memory barrier и не дает гарантии happens-before;
+ weakCompareAndSwap() сильно зависит от кэша/CPU, и может возвращать false без видимых причин;
+ weakCompareAndSwap(), более легкая, но поддерживаемая далеко не всеми архитектурами и не всегда эффективная операция.

[к оглавлению](#многопоточность)

## Что такое потоки демоны? Для чего они нужны? Как создать поток-демон?

Потоки-демоны работают в фоновом режиме вместе с программой, но не являются неотъемлемой частью программы. Если какой-либо процесс может выполняться на фоне работы основных потоков выполнения и его деятельность заключается в обслуживании основных потоков приложения, то такой процесс может быть запущен как поток-демон с помощью метода setDaemon(boolean value), вызванного у потока до его запуска. Метод boolean isDaemon() позволяет определить, является ли указанный поток демоном или нет. Базовое свойство потоков-демонов заключается в возможности основного потока приложения завершить выполнение с окончанием кода метода main(), не обращая внимания на то, что поток-демон еще работает.

В Java процесс завершается тогда, когда завершаются все его основные и дочерние потоки. 
Потоки-демоны — это низкоприоритетные потоки, работающие в фоновом режиме для выполнения таких задач, как сбор «мусора» (освобождают память неиспользованных объектов и очищают кэш). 
Большинство потоков JVM (Java Virtual Machine) являются потоками-демонами.  
 
Свойства потоков-демонов: 
•Не влияют на закрытие JVM, когда все пользовательские потоки завершили свое исполнение; 
•JVM сама закрывается, когда все пользовательские потоки перестают выполняться; 
•Если JVM обнаружит работающий поток-демон, она завершит его, после чего закроется. JVM не учитывает, работает поток или нет. 
 
Чтобы установить, является ли поток демоном, используется метод boolean isDaemon(). Если да, то он возвращает значение true, если нет, то — то значение false. 
 
Daemon потоки предназначены для выполнение фоновых задач и оказания различных сервисов User потокам. При завершении работы последнего User потока программа завершает своё выполнение, не дожидаясь окончания Daemon потоков. 
 
Потоки не-демоны называются пользовательскими (user thread). 

Метод setDaemon() вызывается ДО запуска потока, ДО того, как поток будет запущен. В параметры передаём значение true. Так объявляем поток Демон потоком. 

<img width="548" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/425f93b4-3819-4d71-bdbb-182ce0686261">

Если мы запустили поток и только потом создаём Демона, то будет выброшено исключение IllegalThreadStateException. 
 
Метод isDaemon() – проверяем, является ли поток Демон-потоком. 

Демон в широком значении – фоновая программа. В Java потоки-демоны имеют схожий смысл: это потоки для фоновых действий по обслуживанию основных потоков.  
 
Тред создается демоном, если его родитель демон. Свойство Java-треда isDaemon можно переключать в любой момент до старта потока. 
 
По сравнению с пользовательскими потоками демоны имеют меньший приоритет выполнения. 
 
Когда все пользовательские треды завершились, JVM завершает работу. Демоны не выполняют самостоятельных задач, поэтому не препятствуют остановке, программа завершается, не дожидаясь окончания их работы. 
 
Daemon thread может быть полезен для таких действий, как инвалидация кэша, периодическая актуализация значений из внешних источников, освобождение неиспользуемых пользовательских ресурсов. 

------
Что такое «потоки-демоны»?

Потоки-демоны работают в фоновом режиме вместе с программой, но не являются неотъемлемой частью программы. Если какой-либо процесс может выполняться на фоне работы основных потоков выполнения и его деятельность заключается в обслуживании основных потоков приложения, то такой процесс может быть запущен как поток-демон с помощью метода setDaemon(boolean value), вызванного у потока до его запуска. Метод boolean isDaemon() позволяет определить, является ли указанный поток демоном или нет. Базовое свойство потоков-демонов заключается в возможности основного потока приложения завершить выполнение потока-демона (в отличие от обычных потоков) с окончанием кода метода main(), не обращая внимания на то, что поток-демон еще работает.

Можно ли сделать основной поток программы демоном?

Нет. Потоки-демоны позволяют описывать фоновые процессы, которые нужны только для обслуживания основных потоков выполнения и не могут существовать без них.

[к оглавлению](#многопоточность)

## Что такое приоритет потока? На что он влияет? Какой приоритет у потоков по умолчанию?

Приоритеты потоков используются планировщиком потоков для принятия решений о том, когда какому из потоков будет разрешено работать. Теоретически высокоприоритетные потоки получают больше времени процессора, чем низкоприоритетные. Практически объем времени процессора, который получает поток, часто зависит от нескольких факторов помимо его приоритета.

Чтобы установить приоритет потока, используется метод класса Thread: final void setPriority(int level). Значение level изменяется в пределах от Thread.MIN_PRIORITY = 1 до Thread.MAX_PRIORITY = 10. Приоритет по умолчанию - Thread.NORM_PRlORITY =5.

Получить текущее значение приоритета потока можно вызвав метод: final int getPriority() у экземпляра класса Thread.

------
Каждому потоку исполнения в Java присваивается свой приоритет, который определяет поведение данного потока по отношению к другим потокам.  

Приоритеты потоков исполнения задаются целыми числами (обычно от 1 до 10), определяющими относительный приоритет одного потока над другими. Приоритет потока исполнения используется для принятия решения при переходе от одного потока исполнения к другому. Это так называемое переключение контекста. Задается с помощью метода public final void setPriority(int newPriority). По умолчанию приоритет потока = 5. 

<img width="797" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/0feef961-ca53-45ed-b266-4657077ce589">

НЕ полагайтесь на приоритет потоков при проектировании многопоточных приложений! Скорее всего планировщик потоков будет использовать приоритеты при выборе следующего потока на выполнение, но это НЕ гарантируется. 

<img width="759" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/a453baf7-2b92-45f6-869a-7282f5722838">

[к оглавлению](#многопоточность)

## Как работает Thread.join()? Для чего он нужен?

public final void join(). Этот метод приостановит выполнение текущего потока до тех пор, пока другой поток не закончит свое выполнение. Если поток прерывается, бросается InterruptedException.
```java
Thread t1 = new Thread(new MyRunnable(), "t1");

Thread t2 = new Thread(new MyRunnable(), "t2");

t1.start();

//стартуем 2-й поток тол ько после того, как 1 поток закончит свое выполнение

        try {

            t1.join();

        } catch (InterruptedException e) {

            e.printStackTrace();

        }

        t2.start();
```
Метод join() имеет перегруженную версию, которая получает в качестве параметра время ожидания. В этом случае join() возвращает управление либо когда завершится ожидаемый поток, либо когда закончится время ожидания. Подобно методу Thread.sleep() метод join может ждать в течение миллисекунд и наносекунд – аргументы те же.

С помощью задания времени ожидания потока можно, например, выполнять обновление анимированной картинки пока главный (или любой другой) поток ждёт завершения побочного потока, выполняющего ресурсоёмкие операции.

-------
Если в основном потоке нужно дождаться завершения задач – после start(), вызывается метод thread.join() (присоединиться). Исполнение зависнет на вызове этого метода до тех пор, пока тред не закончит свою задачу и не умрет. 
 
Одна нить может вызывать метод join() у объекта второй нити. В результате первая нить (которая вызвала метод) приостанавливает свою работу до окончания работы второй нити (у объекта которой был вызван метод). 

<img width="783" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/d1475add-0bf6-4430-a3ff-b7ed627622e8">

Метод можно использовать с параметрами (пример выше), принимает мили секунды. 
 
Тогда поток, в котором вызван метод join() (здесь в main потоке), будет ждать пока тред (thread.join) не завершит свою работу или не пройдёт период 1,5 сек. Какое из этих событий случится первым, то и подстегнёт поток main продолжить свою работу. 
 
Как работает Join: 

<img width="781" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/6ddc9429-3175-452d-a493-c07fd2e0c9b9">

[к оглавлению](#многопоточность)

## Чем отличаются методы yield() и sleep()?

В то время как yield () может сделать только эвристическую попытку (зависит от платформы и планировщика) приостановить выполнение текущего потока без гарантии того, когда он будет запланирован назад, sleep () может заставить планировщик приостановить выполнение текущего потока как минимум на указанный период времени в качестве его параметра.
```java
public class ThreadYield {

    public static void main(String[]args) {

        Runnable r = () -> {

            int counter = 0;

            while (counter < 2) {   

                System.out.println(Thread.currentThread().getName());

                counter++;

                Thread.yield();

            }

        };

        new Thread(r).start();

        new Thread(r).start();

    }

}

Прогон 1:

Thread-0

Thread-1

Thread-1

Thread-0

Прогон 2:

Thread-0

Thread-0

Thread-1

Thread-1
```
------------
Короткий ответ:  
+ sleep(500) – текущая нить «засыпает», то есть приостанавливает свою работу на 500 миллисекунд – 0.5 секунды 
+ yield() – текущая нить «пропускает свой ход». Из состояния running переходит в состояние ready, а Java-машина приступает к выполнению следующей нити. 

<img width="444" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/ae60c7a1-e00b-40d9-aae2-5e90c1477620">

Подробнее. Метод sleep() останавливает работу потока на заданное количество времени. 
 
В этом примере почему слово «конец» выведено вначале? Потому что при запуске новых потоков, поток main их запустил. Далее эти потоки «ответвились» от него (работают независимо), а main продолжает свою работу. Он запустил потоки и работает дальше – выводит слово «конец» в консоль. Он не спит, поэтому работает быстро. А через секунду оба потока начинают поочерёдно выводить цифры в консоль и продолжают дальше с интервалом в 1 секунду. 
 
Пока эти потоки не прекратят работу, программа не завершится. Исключение InterruptedException нужно обработать в trycatch блоке, т.к. поток может ПРЕРВАТЬ другой поток. Если поток просит остановиться, а мы в этот момент находимся в «спячке», то будет выброшен InterruptedException Exc. 

<img width="850" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/3d52adc2-0511-48c7-bc08-23a566cef1f7">

Когда это время истекает – процессор переключается на другую нить и начинает выполнять ее команды.  
 
Вызов метода Thread.yield() позволяет досрочно завершить квант времени текущей нити или, другими словами, переключает процессор на следующую нить. 
 Когда мы вызываем метод yield у потока, он фактически говорит другим потокам: «Так, ребята, я никуда особо не тороплюсь, так что, если кому-то из вас важно получить время процессора — берите, мне не срочно».    
 
**Поток, реализующий интерфейс Runnable**

<img width="646" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/b087f699-9933-419b-a342-f877636599d9">

<img width="783" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/4f00597d-0d30-4501-85cd-362b9b7b1e41">

-------------
Чем отличаются методы Thread.sleep() и Thread.yield()?

Метод yield() служит причиной того, что поток переходит из состояния работающий (running) в состояние работоспособный (runnable), давая возможность другим потокам активизироваться. Но следующий выбранный для запуска поток может и не быть другим.
Метод sleep() вызывает засыпание текущего потока на заданное время, состояние изменяется с работающий (running) на ожидающий (waiting).

Что значит «усыпить» поток?

Это значит приостановить его на определенный промежуток времени, вызвав в ходе его выполнения статический метод Thread.sleep() передав в качестве параметра необходимое количество времени в миллисекундах. До истечения этого времени поток может быть выведен из состояния ожидания вызовом interrupt() с выбрасыванием InterruptedException.

--------------
Оба метода, `Thread.sleep()` и `Thread.yield()`, связаны с управлением выполнением потоков в Java (или других языках, поддерживающих многопоточность). Однако они имеют различное поведение и цель.

1. **Thread.sleep()**:
Метод `Thread.sleep()` позволяет временно приостановить выполнение потока на определенный интервал времени. Это может быть полезно, например, когда вам необходимо замедлить выполнение потока или создать паузу перед выполнением определенных операций. Вызов `Thread.sleep()` может вызывать исключение `InterruptedException`, поэтому необходимо обрабатывать это исключение.

Пример:
```java
try {
    Thread.sleep(1000); // Приостановить поток на 1 секунду
} catch (InterruptedException e) {
    e.printStackTrace();
}
```

2. **Thread.yield()**:
Метод `Thread.yield()` предназначен для добровольной передачи управления другому потоку с тем же приоритетом. Однако это лишь рекомендация для планировщика потоков, и планировщик может проигнорировать вызов `yield()`. Этот метод используется, когда вы хотите дать другим потокам возможность выполниться в случае, если текущий поток находится в состоянии готовности.

Пример:
```java
Thread.yield(); // Передать управление другому потоку того же приоритета
```

Важно понимать, что использование `Thread.yield()` может быть непредсказуемым, так как его эффективность зависит от реализации планировщика потоков в конкретной среде выполнения. `Thread.yield()` следует использовать осторожно и только в случаях, когда вы точно знаете, как это повлияет на вашу конкретную ситуацию.

Кратко, `Thread.sleep()` используется для приостановки потока на определенный интервал времени, а `Thread.yield()` позволяет передать управление другому потоку с тем же приоритетом.

[к оглавлению](#многопоточность)

## Как правильно остановить поток? Для чего нужны методы .stop(), .interrupt(), .interrupted(), .isInterrupted().

.stop() помечен как deprecated. Потому что он просто останавливал поток без какой-либо дополнительной работы.

Как известно метод Thread.stop() объявлен как Deprecated поскольку «не потокобезопасен», а безопасная инструкция Thread.interrupt() только сообщает потоку о необходимости остановки. Но если данное сообщение проигнорировано, т.е. разработчик не вставил обработку, то и поток не остановится. Сам разработчик пишет выход из потока! (например If (условие выхода и isInterrupted()) – break)

interrupt() -  Вызов этого метода устанавливает у потока статус, что он прерван. Сам метод возвращает true, если поток может быть прерван, в ином случае возвращается false. 

clockThread.interrupt();    

Метод interrupt() также способен вывести поток из состояния ожидания или спячки. Т.е. если у потока были вызваны методы sleep() или wait() – текущее состояние прервется и будет выброшено исключение InterruptedException. Флаг в этом случае не выставляется.

isInterrupted() – Нестатический метод используется одним потоком для проверки статуса прерывания у другого потока, не изменяя флаг прерывания.

------------------
**ТАК неправильно!**
 
Метод stop() прерывает поток грубо, в неоконченном состоянии. Метод считается устаревшим. 
  
Если хотим прервать поток, то должны позаботиться об исключении, чтобы вОвремя узнать о непредвиденной ситуации: 

<img width="776" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/479df17d-f5bf-4725-b06b-38a3d000ece6">

Есть возможность послать сигнал потоку, что мы хотим его прервать interrupt(). 

Есть возможность в самом потоке проверить, хотят ли его прервать isInterrupted(). Что делать, если проверка показала, что поток хотят прервать, должен решать сам программист. 

<img width="716" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/7292628a-4c34-4fd0-a422-e39f3a3c8868">

**Метод interrupt**
 
В классе Thread существует переменная isInterrupted и метод остановки interrupt(). Никто не гарантирует, что нить можно остановить. Она может остановиться только сама. 

<img width="770" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/1da12b8a-eafe-4db9-a2f5-4efb8074fe46">

-------------------
Как остановить поток?

На данный момент в Java принят уведомительный порядок остановки потока (хотя JDK 1.0 и имеет несколько управляющих выполнением потока методов, например stop(), suspend() и resume() - в следующих версиях JDK все они были помечены как deprecated из-за потенциальных угроз взаимной блокировки).

Для корректной остановки потока можно использовать метод класса Thread - interrupt(). Этот метод выставляет некоторый внутренний флаг-статус прерывания. В дальнейшем состояние этого флага можно проверить с помощью метода isInterrupted() или Thread.interrupted() (для текущего потока). Метод interrupt() также способен вывести поток из состояния ожидания или спячки. Т.е. если у потока были вызваны методы sleep() или wait() – текущее состояние прервется и будет выброшено исключение InterruptedException. Флаг в этом случае не выставляется.

Схема действия при этом получается следующей:

+ Реализовать поток.

В потоке периодически проводить проверку статуса прерывания через вызов isInterrupted(). Если состояние флага изменилось или было выброшено исключение во время ожидания/спячки, следовательно поток пытаются остановить извне.
+ Принять решение – продолжить работу (если по каким-то причинам остановиться невозможно) или освободить заблокированные потоком ресурсы и закончить выполнение.

Возможная проблема, которая присутствует в этом подходе – блокировки на потоковом вводе-выводе. Если поток заблокирован на чтении данных - вызов interrupt() из этого состояния его не выведет. Решения тут различаются в зависимости от типа источника данных. Если чтение идет из файла – долговременная блокировка крайне маловероятна и тогда можно просто дождаться выхода из метода read(). Если же чтение каким-то образом связано с сетью – стоит использовать неблокирующий ввод-вывод из Java NIO.

Второй вариант реализации метода остановки (а также и приостановки) – сделать собственный аналог interrupt(). Т.е. объявить в классе потока флаги – на остановку и/или приостановку и выставлять их путем вызова заранее определённых методов извне. Методика действия при этом остаётся прежней – проверять установку флагов и принимать решения при их изменении. 

Недостатки такого подхода:
+ Во-первых, потоки в состоянии ожидания таким способом не «оживить».
+ Во-вторых, выставление флага одним потоком совсем не означает, что второй поток тут же его увидит. Для увеличения производительности виртуальная машина использует кеш данных потока, в результате чего обновление переменной у второго потока может произойти через неопределенный промежуток времени (хотя допустимым решением будет объявить переменную-флаг как volatile).

Почему не рекомендуется использовать метод Thread.stop()?

При принудительной остановке (приостановке) потока, stop() прерывает поток в недетерменированном месте выполнения, в результате становится совершенно непонятно, что делать с принадлежащими ему ресурсами. Поток может открыть сетевое соединение - что в таком случае делать с данными, которые еще не вычитаны? Где гарантия, что после дальнейшего запуска потока (в случае приостановки) он сможет их дочитать? Если поток блокировал разделяемый ресурс, то как снять эту блокировку и не переведёт ли принудительное снятие к нарушению консистентности системы? То же самое можно расширить и на случай соединения с базой данных: если поток остановят посередине транзакции, то кто ее будет закрывать? Кто и как будет разблокировать ресурсы?

В чем разница между interrupted() и isInterrupted()?

Механизм прерывания работы потока в Java реализован с использованием внутреннего флага, известного как статус прерывания. Прерывание потока вызовом Thread.interrupt() устанавливает этот флаг. Методы Thread.interrupted() и isInterrupted() позволяют проверить, является ли поток прерванным.
Когда прерванный поток проверяет статус прерывания, вызывая статический метод Thread.interrupted(), статус прерывания сбрасывается.
Нестатический метод isInterrupted() используется одним потоком для проверки статуса прерывания у другого потока, не изменяя флаг прерывания.

<img width="516" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/c7769a47-9e1d-4c64-80e2-9bb68b4bca0d">

<img width="503" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/5f2cd73c-bc35-4cdd-b259-f000da22b720">

-------------------
Для остановки потока в Java есть несколько способов, в том числе методы stop(), interrupt() и isInterrupted().

Метод stop() представляет собой устаревший способ остановки потока и не рекомендуется использовать. Этот метод может прерывать выполнение потока в любой момент, не завершая при этом выполнение всех необходимых операций и уничтожая объекты. Это может привести к непредсказуемым результатам и нестабильности работы приложения.

Метод interrupt() является более безопасным способом остановки потока. Он устанавливает флаг прерывания потока, который может быть проверен другими частями программы. В ответ на установку флага, исполнение потока может быть остановлено в безопасной точке, что позволяет закончить выполнение задачи перед завершением работы потока.

Метод interrupted() используется для проверки того, был ли поток прерван, и сбрасывает флаг прерывания в false.

Метод isInterrupted() также используется для проверки наличия установленного флага прерывания, но не сбрасывает этот флаг.

В целом, лучшим подходом для остановки потока является использование метода interrupt(). Важно понимать, что для корректной обработки метода interrupt() необходимо наличие проверки установки флага прерывания в коде потока, и правильное написание работы с этим флагом, чтобы предотвратить возможные ошибки и непредсказуемое поведение программы.

[к оглавлению](#многопоточность)

## Чем Runnable отличается от Callable?

Оба интерфейса предназначены для представления задачи, которая может выполняться несколькими потоками. Задачи Runnable можно запускать с помощью класса Thread или ExecutorService , тогда как Callables можно запускать только с использованием последнего

Runnable
+ появилcя в Java 1.0
+ Классы, реализующие интерфейс Runnable для выполнения задачи должны реализовывать метод run()
+ Runnable.run() не принимает никаких параметров и не возвращает никаких значений
+ Метод run() не может выбрасывать проверяемые исключения

Callable
+ Появилcя в Java 5.0 в составе библиотеки java.util.concurrent (улучшенная версия)
 ```java
  метод call()
  public interface Callable<V> {

    V call() throws Exception;

  }
```
+ Callable.call() возвращает объект Future, который может содержать результат вычислений;
+ Метод call() избавляет нас от необходимости на проверяемые исключения писать try-catch блоки

-----------
Коротко: Метод Runnable.run() не возвращает никакого значения, Callable.call() возвращает объект Future, который может содержать результат вычислений; Метод run() не может выбрасывать проверяемые исключения, в то время как метод call() может. 
 
Разница между интерфейсами Runnable и Callable: 

<img width="783" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/90a51d06-f08d-4572-addc-1378f96e4114">

<img width="766" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/d83a9641-ce79-4e70-b380-af4baf849e16">

`Runnable` и `Callable` - это два интерфейса в Java, которые используются для выполнения кода в многозадачных приложениях, но они имеют разные особенности и предназначены для разных целей:

1. **Runnable**:
   - `Runnable` - это функциональный интерфейс, введенный в Java для представления задачи, которую можно выполнить в отдельном потоке.
   - Он определяет один метод `void run()`, который не возвращает результат и не выбрасывает проверяемых исключений.
   - `Runnable` обычно используется для выполнения задач, которые не требуют возврата результата или выбрасывания исключений. Он часто применяется в конструкции `Thread` для создания нового потока выполнения.

Пример использования `Runnable`:

```java
Runnable myRunnable = () -> {
    // код, который будет выполнен в отдельном потоке
};

Thread thread = new Thread(myRunnable);
thread.start();
```

2. **Callable**:
   - `Callable` - это также функциональный интерфейс, введенный в Java, но он представляет задачу, которая может вернуть результат и выбросить проверяемое исключение.
   - Он определяет метод `V call() throws Exception`, где `V` - это тип возвращаемого значения, и метод может выбросить исключение типа `Exception`.
   - `Callable` обычно используется вместе с `ExecutorService`, чтобы отправить задачу на выполнение в пул потоков и получить результат выполнения или обработать исключение, если оно произошло.

Пример использования `Callable`:

```java
import java.util.concurrent.*;

Callable<Integer> myCallable = () -> {
    // код, который будет выполнен в отдельном потоке
    return 42;
};

ExecutorService executorService = Executors.newSingleThreadExecutor();
Future<Integer> result = executorService.submit(myCallable);

try {
    Integer value = result.get(); // получение результата
    System.out.println("Результат: " + value);
} catch (InterruptedException | ExecutionException e) {
    e.printStackTrace(); // обработка исключений
}

executorService.shutdown();
```

Итак, основное различие между `Runnable` и `Callable` заключается в том, что `Runnable` не возвращает результат и не выбрасывает проверяемых исключений, тогда как `Callable` может возвращать результат и выбрасывать исключения. Выбор между ними зависит от требований вашей задачи.

[к оглавлению](#многопоточность)

## Что такое FutureTask?

FutureTask представляет собой отменяемое асинхронное вычисление в параллельном Java приложении. 

java.util.concurrent.Future - Этот класс предоставляет базовую реализацию Future, с методами для запуска и остановки вычисления, методами для запроса состояния вычисления и извлечения результатов. Результат может быть получен только когда вычисление завершено, метод получения будет заблокирован, если вычисление ещё не завершено. Объекты FutureTask могут быть использованы для обёртки объектов Callable и Runnable. Так как FutureTask реализует Runnable, его можно передать в Executor на выполнение.

---------
FutureTask представляет собой отменяемое асинхронное вычисление в параллельном потоке. Этот класс предоставляет базовую реализацию Future, с методами для запуска и остановки вычисления, методами для запроса состояния вычисления и извлечения результатов.  
 
Результат может быть получен только когда вычисление завершено, метод получения будет заблокирован, если вычисление ещё не завершено.  
 
Объекты FutureTask могут быть использованы для обёртки объектов Callable и Runnable. Так как FutureTask помимо Future реализует Runnable, его можно передать в Executor на выполнение. 

<img width="715" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/c6fe9353-0917-4e27-8aa9-bbe6861e6191">

Callable, так же как и Runable, представляет собой определённое задание, которое выполняется потоком. В отличии от Runable, Callable:  
•имеет тип возвращаемого значения (НЕ void)  
•может выбрасывать исключение 
 
Метод submit() передаёт задание (task) в пул потоков для выполнения одним из потоков и возвращает тип Future, в котором и хранится результат выполнения задания.  
 
Метод get() позволяет получить результат из объекта Future. 

<img width="766" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/9c5d499f-82ca-4a83-8185-8657f6c9ad28">

-------------
Что такое FutureTask?

FutureTask представляет собой отменяемое асинхронное вычисление в параллельном Java приложении. Этот класс предоставляет базовую реализацию Future, с методами для запуска и остановки вычисления, методами для запроса состояния вычисления и извлечения результатов. Результат может быть получен только когда вычисление завершено, FutureTask метод получения будет заблокирован, если вычисление ещё не завершено. Объекты FutureTask могут быть использованы для обёртки объектов Callable и Runnable. Так как FutureTask реализует Runnable, его можно передать в Executor на выполнение.


В Java Future и FutureTask используются для асинхронного выполнения задач и получения их результатов в будущем. Разница между ними заключается в том, что Future является интерфейсом, который определяет операции для получения результата, проверки статуса задачи и отмены задачи, в то время как FutureTask - это конкретный класс, который реализует Future интерфейс и предоставляет дополнительные методы для управления задачей и ее выполнения.

Future обычно используется, когда результаты задачи не требуют дополнительной обработки, и не нужна возможность управлять задачей. Он также может использоваться, когда результаты должны быть получены немедленно.

Однако, если вам нужна возможность управления задачей (отмена, проверка статуса и т. д.) или если результаты нужно обработать после их завершения (например, чтобы отправить электронное сообщение или записать результат в файл), то вы можете использовать класс FutureTask.

Таким образом, если вы просто хотите получить результаты задачи из потока и дальше их обработать, то можно использовать Future. Если вам нужна более тонкая настройка управления потоком и задачей, то рекомендуется использовать FutureTask.


--------------------------

Поскольку задача типа `Runnable` не возвращает результат, вызов метода `submit()` на `ExecutorService` вернет объект `Future<?>`, который можно использовать для проверки статуса выполнения задачи или ожидания ее завершения.

Использование `submit()` и возврат объекта `Future` дает возможность контролировать выполнение задачи, получать статус ее завершения, обрабатывать исключения и выполнять другие операции на основе результата задачи или ее статуса.


То есть это некая замена методу join()? 

Да, метод `submit()` в сочетании с объектом `Future` является альтернативой методу `join()` для ожидания завершения выполнения задачи типа `Runnable` в многопоточной среде.

В классе `Thread` есть метод `join()`, который блокирует выполнение текущего потока до тех пор, пока заданный поток не завершится. Это полезно, когда вам нужно дождаться окончания работы определенного потока, прежде чем продолжить выполнение остальной части кода.

Однако, в случае использования `ExecutorService` и задач типа `Runnable`, вы не имеете непосредственного доступа к объекту `Thread`. Вместо этого, `ExecutorService` управляет набором потоков, назначает задачи на выполнение и возвращает объект `Future`, который предоставляет информацию о статусе и результате выполнения задачи.

Вы можете использовать метод `get()` на объекте `Future`, чтобы блокировать выполнение текущего потока до завершения задачи, то есть ожидать, пока задача типа `Runnable` не завершится. Это обеспечивает функциональность аналогичную методу `join()`. Таким образом, `submit()` и `Future` обеспечивают функциональность аналогичную методу `join()`, позволяя вам ожидать завершения выполнения задачи типа `Runnable` в многопоточной среде.


То есть, если мы используем Runnable в executorService в методе execute, то не сможем контролировать, когда выполнение закончится, задача Runnubl будет просто асинхронно выполняться, но мы не сможем получить информацию о ей статусе выполнения и не сможем притормозить текущий поток?


Да, вы правильно понимаете. Когда вы используете метод `execute()` с задачей типа `Runnable` в `ExecutorService`, он запускает выполнение задачи асинхронно и не возвращает никакого результата или объекта, связанного с задачей.

Метод `execute()` предназначен для простого выполнения задач без возможности контроля над их выполнением или получения результатов. Он отправляет задачу в очередь на выполнение и продолжает выполнять следующий код без ожидания завершения задачи.

Если вам нужен контроль над выполнением задачи, возможность получить результат или ожидать завершения, вам следует вместо этого использовать метод `submit()`, который возвращает объект `Future`.

Таким образом, используя `submit()` и `Future`, вы получаете контроль над выполнением задачи типа `Runnable`, имеете возможность получить результаты выполнения и ожидать её завершения, в отличие от метода `execute()`.

[к оглавлению](#многопоточность)

## Что такое deadlock?

Взаимная блокировка (deadlock) - явление при котором все потоки находятся в режиме ожидания. Происходит, когда достигаются состояния:

+ взаимного исключения: по крайней мере один ресурс занят в режиме неделимости и следовательно только один поток может использовать ресурс в любой данный момент времени.
+ удержания и ожидания: поток удерживает как минимум один ресурс и запрашивает дополнительные ресуры, которые удерживаются другими потоками.
+ отсутствия предочистки: операционная система не переназначивает ресурсы: если они уже заняты, они должны отдаваться удерживающим потокам сразу же.
+ цикличного ожидания: поток ждёт освобождения ресурса другим потоком, который в свою очередь ждёт освобождения ресурса заблокированного первым потоком.

Простейший способ избежать взаимной блокировки – не допускать цикличного ожидания. Этого можно достичь, получая мониторы разделяемых ресурсов в определённом порядке и освобождая их в обратном порядке.

----------------
Deadlock – это взаимная блокировка, ситуация, когда два или более потока «наступают друг-другу на хвост» – зависают в вечном ожидании ресурсов, захваченных друг другом. 
 
Deadlock – это ситуация в многопоточном программировании, когда два или более потока залочены навсегда, ожидают друг друга и ничего не делают. 

<img width="509" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/f2d50992-d7af-4ef9-a61f-626f778baaa3">

Такая ситуация может возникнуть, когда несколько потоков используют синхронизацию на нескольких объектах не в одинаковом порядке.  
 
В мультипрограммной среде более одного процесса могут конкурировать за конечный набор ресурсов. Если процесс запрашивает ресурс, а ресурс в данный момент недоступен, то процесс ожидает его. Иногда этому ожидающему процессу никогда не удается получить доступ к ресурсу.  

На рисунке сценарий взаимоблокировки между процессами 1 и 2. Оба процесса удерживают один ресурс и ждут другого ресурса, удерживаемого другим процессом. Это тупиковая ситуация, поскольку ни процесс 1, ни процесс 2 не могут двигаться вперед, пока один из процессов не откажется от своего ресурса (пример кода из урока Заура Трегулова).

<img width="926" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/ab6474cf-307b-4d93-8bd0-5eee9ca239ab">

Выход: синхронизироваться в одинаковом порядке для разных методов. 
 
Циклическое ожидание: это условие можно сделать ложным, установив общий порядок всех типов ресурсов и гарантируя, что каждый процесс запрашивает ресурсы в возрастающем порядке перечисления. Например, если есть набор n ресурсов R1, R2…… Rn и процессу требуется ресурс R1, R2, то для успешного выполнения задачи ему нужно сначала запросить R1, а затем R2. 
Стандартный подход к обеспечению гарантии защиты от дедлока – установка строгого порядка взятия блокировок. Если для мониторов A и B соблюдается всеобщий порядок захвата AB (и соответственно отпускания BA), то ни с одним потоком не случится попасть на ожидание B, успешно при этом захватив A. 
 
Из этого можно догадаться, простой способ гарантировать возможность дедлока – явно нарушить это условие. 
CyclicBarrier
Нарушение условия даст дедлок «скорее всего когда-нибудь». Чтобы получить его точно и с первого раза, нужно гарантировать, что оба потока окажутся на этапе между захватами одного и другого ресурса в одно время. Это можно сделать множеством способов, в примере ниже использован . 
 
Вопрос дедлоков – одна из краеугольных тем параллельных вычислений, уходящая далеко за рамки этого вопроса. Для дальнейшего изучения рекомендуются статьи на википедии про дедлоки, про задачу об обедающих философах как классическая иллюстрация проблемы, и глава 10.1 книги Java Concurrency in Practice. 

-----------------
В многопоточных приложениях deadlock (захват) - это ситуация, когда два или более потока приложения блокируются (запираются) на ожидании друг друга, чтобы освободить ресурсы, которые необходимы для продолжения своей работы.

Таким образом, каждый поток ожидает освобождения ресурсов, необходимых другому потоку, чтобы завершить свою работу. Поскольку каждый из потоков ждет, в итоге создается зацикленная ситуация (deadlock), при которой ни один из потоков не может продолжить работу и приложение зависает.

Deadlock может возникнуть, когда несколько потоков имеют доступ к общим ресурсам, которые они хотят использовать в определенной последовательности или когда один поток удерживает блокировку, которая не дает другому потоку доступ к требуемому ресурсу.

Чтобы избежать deadlock, необходимо разработать правильную стратегию управления блокировками и планирования потоков, чтобы гарантировать отсутствие возможности блокировки. Также можно использовать инструменты и методологии для обнаружения и исправления deadlock-ситуаций, например, мониторинг и анализ производительности приложения или использование алгоритмов, которые обеспечивают корректное управление блокировками и предотвращают deadlock.

[к оглавлению](#многопоточность)

## Что такое livelock?

livelock – тип взаимной блокировки, при котором несколько потоков выполняют бесполезную работу, попадая в зацикленность при попытке получения каких-либо ресурсов. При этом их состояния постоянно изменяются в зависимости друг от друга. Фактической ошибки не возникает, но КПД системы падает до 0. Часто возникает в результате попыток предотвращения deadlock.

Реальный пример livelock, – когда два человека встречаются в узком коридоре и каждый, пытаясь быть вежливым, отходит в сторону, и так они бесконечно двигаются из стороны в сторону, абсолютно не продвигаясь в нужном им направлении.

----------------
Livelock – похожая на DeadLock проблема, с тем лишь отличием, что потоки не останавливаются, а вместо этого зацикливаются, выполняя одни и те же бесполезные действия, ходят по кругу. 
 
LiveLock – это ситуация, когда два или более потоков залочены навсегда, ожидают друг друга, проделывают какую-то работу, но без какого-либо прогресса. 
 
Работа есть, прогресса нет. 

<img width="450" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/df5906f9-c2c6-4685-bf2e-1ec301596ced">

На рисунке показан пример livelock. И «процесс 1», и «процесс 2» нуждаются в общем ресурсе. Каждый процесс проверяет, находится ли другой процесс в активном состоянии. Если да, то он передает ресурс другому процессу.  

Однако, поскольку оба процесса находятся в неактивном состоянии, оба продолжают передавать ресурсы друг другу на неопределенный срок.

* Что такое lock starvation?

Это ситуация, когда менее приоритетные потоки ждут долгое время для того, чтобы могли запуститься. 

[к оглавлению](#многопоточность)

## Что такое race condition?

Пример: операция инкремента над волойтал переменной

Состояние гонки (race condition) - ошибка проектирования многопоточной системы или приложения, при которой эта работа напрямую зависит от того, в каком порядке выполняются потоки. Состояние гонки возникает когда поток, который должен исполнится в начале, проиграл гонку и первым исполняется другой поток: поведение кода изменяется, из-за чего возникают недетерменированные (непредопределенные) ошибки.

Распространённые способы решения:
+ Использование локальной копии — копирование разделяемой переменной в локальную переменную потока. Этот способ работает только тогда, когда переменная одна и копирование производится атомарно (за одну машинную команду), использование volatile.
+ Синхронизация - операции над разделяемым ресурсом происходят в синхронизированном блоке (при использовании ключевого слова synchronized).
+ Комбинирование методов - вышеперечисленные способы можно комбинировать, копируя «опасные» переменные в синхронизированном блоке. С одной стороны, это снимает ограничение на атомарность, с другой — позволяет избавиться от слишком больших синхронизированных блоков.

Очевидных способов выявления и исправления состояний гонки не существует.

Лучший способ избавиться от гонок — правильное проектирование многозадачной системы

<img width="741" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/82610efc-26e2-464f-903e-c02d46c2e03b">

DataRace – это свойство выполнения программы. Согласно JMM, выполнение считается содержащим гонку данных, если оно содержит по крайней мере два конфликтующих доступа (чтение или запись в одну и ту же переменную), которые не упорядочены отношениями «happens before». 
 
Starvation – голодание, т.е. потоки не заблокированы, но есть нехватка ресурсов из-за чего потоки ничего не делают. 
 
Самый простой способ решения — копирование переменной в локальную переменную. Или просто синхронизация потоков методами и sync-блоками. 

----------------

Race condition - это ситуация, возникающая при параллельном выполнении потоков, когда несколько потоков одновременно обращаются к общему ресурсу и пытаются изменить его значение, что может привести к непредсказуемым результатам.

Вот несколько способов избежать race condition в Java:

1. Синхронизация: Используйте ключевое слово `synchronized` или блокировки (`Lock`) для обеспечения доступа к общим ресурсам только одним потоком в определенный момент времени. Это предотвратит одновременное изменение общих данных и гарантирует последовательное выполнение критических участков кода.

2. Использование атомарных операций: В Java есть классы, такие как `AtomicInteger`, `AtomicLong`, `AtomicReference`, которые предоставляют атомарные операции для выполнения на общих ресурсах. Атомарные операции гарантируют, что операция будет выполнена без прерывания другими потоками.

3. Использование немутабельных (неизменяемых) объектов: Если возможно, используйте неизменяемые объекты, которые не могут быть изменены после создания. Немутабельные объекты не подвержены race condition, поскольку они не могут быть изменены после своего создания.

4. Использование потокобезопасных коллекций: В Java есть классы, такие как `ConcurrentHashMap`, `CopyOnWriteArrayList`, которые обеспечивают потокобезопасность при работе с коллекциями в параллельных средах. Использование таких коллекций может помочь избежать race condition при доступе к общим данным.

5. Избегайте общего изменяемого состояния: Попытайтесь избегать ситуаций, когда несколько потоков одновременно изменяют общие данные. Вместо этого разделите данные между потоками или используйте потокобезопасные структуры данных, чтобы минимизировать конфликты и race condition.

6. Правильная синхронизация чтения/записи: Если несколько потоков только читают общие данные, но не изменяют их, вы можете использовать неблокирующие или потокобезопасные структуры данных для обеспечения безопасного доступа к данным без блокирования.

Важно отметить, что правильное обращение с race condition требует тщательного планирования и анализа кода. Необходимо учитывать особенности конкретной ситуации, особенности потоков и манипуляций с общими данными для выбора наилучшего подхода к избежанию race condition.

[к оглавлению](#многопоточность)

## Что такое Фреймворк fork-join? Для чего он нужен?

Фреймворк Fork/Join, представленный в JDK 7, - это набор классов и интерфейсов позволяющих использовать преимущества многопроцессорной архитектуры современных компьютеров. Он разработан для выполнения задач, которые можно рекурсивно разбить на маленькие подзадачи, которые можно решать параллельно.

**Этап Fork:** большая задача разделяется на несколько меньших подзадач, которые в свою очередь также разбиваются на меньшие. И так до тех пор, пока задача не становится тривиальной и решаемой последовательным способом.

**Этап Join:** далее (опционально) идёт процесс «свёртки» - решения подзадач некоторым образом объединяются пока не получится решение всей задачи.
Решение всех подзадач (в т.ч. и само разбиение на подзадачи) происходит параллельно.

<img width="923" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/4a48b0fb-4c1f-46fd-9cee-06eb3ce78ab0">

Для решения некоторых задач этап Join не требуется. Например, для параллельного QuickSort — массив рекурсивно делится на всё меньшие и меньшие диапазоны, пока не вырождается в тривиальный случай из 1 элемента.

Хотя в некотором смысле Join будет необходим и тут, т.к. всё равно остаётся необходимость дождаться пока не закончится выполнение всех подзадач.

Ещё одно замечательное преимущество этого фреймворка заключается в том, что он использует work-stealing алгоритм: потоки, которые завершили выполнение собственных подзадач, могут «украсть» подзадачи у других потоков, которые всё ещё заняты.


--------------
Платформа fork/join — это реализация интерфейса ExecutorService, которая помогает вам использовать преимущества нескольких процессоров. Он предназначен для работы, которую можно рекурсивно разбить на более мелкие части. Цель состоит в том, чтобы использовать всю доступную вычислительную мощность для повышения производительности вашего приложения.

Как и в любой ExecutorServiceреализации, платформа fork/join распределяет задачи по рабочим потокам в пуле потоков. Платформа fork/join отличается тем, что использует алгоритм кражи работы . Рабочие потоки, которым не хватает дел, могут украсть задачи у других потоков, которые все еще заняты.

Центром структуры fork/join является ForkJoinPoolкласс, расширение класса AbstractExecutorService. ForkJoinPoolреализует основной алгоритм кражи работы и может выполнять ForkJoinTaskпроцессы.

Основное использование
Первым шагом при использовании платформы fork/join является написание кода, выполняющего часть работы. Ваш код должен выглядеть примерно так:

если (моя часть работы достаточно мала) 
  выполнить работу напрямую, 
иначе 
  разделить мою работу на две части 
  , вызвать две части и дождаться результатов
Оберните этот код в ForkJoinTaskподкласс, обычно используя один из его более специализированных типов RecursiveTask(который может возвращать результат) или RecursiveAction.

После того, как ваш ForkJoinTaskподкласс будет готов, создайте объект, который представляет всю работу, которую необходимо выполнить, и передайте его методу invoke()экземпляра ForkJoinPool.


[к оглавлению](#многопоточность)

## Что означает ключевое слово synchronized? Где и для чего может использоваться?

В Java монитор реализован с помощью ключевого слова synchronized.

Когда ты пишешь блок synchronized, то компилятор Java заменяет его тремя кусками кода:

+ В начале блока synchronized добавляется код, который отмечает мютекс как занятый.
+ В конце блока synchronized добавляется код, который отмечает мютекс как свободный.
+ Перед блоком synchronized добавляется код, который смотрит, если мютекс занят – то нить должна ждать его освобождения.

Когда ты начинаешь писать код своей нити и в ней обращаешься к различным объектам своей программы, то при вызове каждого метода, ты должен задуматься – а безопасен (thread-safe) ли этот вызов? Все immutable объекты являются thread-safe.

Все объекты, к которым происходит обращение из разных нитей, должны быть thread-safe.

Только методы и блоки могут быть синхронизированы, но не переменные и классы.

Если метод, в котором содержится критически важная «многопоточная» логика статический, синхронизация будет осуществляться по классу.

-------------
Когда одна нить заходит внутрь блока кода, помеченного словом synchronized, то Java машина тут же блокирует мьютекс у объекта, который указан в круглых скобках после слова synchronized.  

Больше ни ода нить не сможет зайти в этот блок, пока наша нить его не покинет. Как только наша нить выйдет из блока, помеченного synchronized, то мьютекс тут же автоматически разблокируется и будет свободен для захвата другой нитью. 
 
Ключевым словом synchronized может быть помечен как блок кода, так и метод. 
 
Зарезервированное слово позволяет добиваться синхронизации в помеченных им методах или блоках кода. Блокировка по ОБЪЕКТУ! 
 
Нити мешают друг-другу, когда пытаются сообща работать с общими объектами и/или ресурсами. Поэтому был придуман специальный объект – мьютекс.  
Он имеет два состояния: объект свободен или занят (еще называют заблокирован или разблокирован, lock или unlock, принцип «одиночный семафор»). 
 
Разработчики встроили мьютекс в класс Object, так что даже создавать его не нужно, mutex есть у каждого объекта. 

Ключевое слово synchronized можно применять как модификатор метода, и как самостоятельный оператор с блоком кода. Выполняет код при захваченном мониторе
объекта. В виде оператора объект указывается явно. В виде модификатора нестатического метода используется this, статического – .class текущего класса.

Один из основных инструментов обеспечения потокобезопасности. Одновременно выполняется не более одного блока synchronized на одном и том же объекте. Такая 
блокировка называется intrinsic lock или monitor lock.

<img width="944" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/dca0d5bc-d120-4ee4-8116-8104bd9ef600">

Блок synchronized также необходим для использования методов wait, notify, notifyAll.  
 
Блокировка по объекту: 

<img width="524" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/c9fe5c82-2105-461b-b580-459fa6d313b8">
 
Любой объект Java может служить блокировкой через ключевое слово synchronized 
 
Снятие блокировки производится автоматически! 

<img width="944" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/b245f6c2-bac2-4753-ae05-8a9665b874db">

[к оглавлению](#многопоточность)

## Что является монитором у статического синхронизированного класса?

Монитор – это доступ к блоку кода - synchronized. Если создаем экземпляр статического вложенного класса, - все что можно достать из объекта – принадлежит статическому классу,

Память для статического метода выделяется только один раз во время загрузки класса. Это означает, что при выполнении статического метода весь класс блокируется. Таким образом, другие статические синхронизированные методы также блокируются. Если один поток выполняет статический синхронизированный метод, все остальные потоки, пытающиеся выполнить любые статические синхронизированные методы, будут заблокированы.

-----------------
Объект типа Class, соответствующий классу, в котором определен метод. 

<img width="473" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/a4cb1157-0c3f-44b8-86aa-04bf5c9af8ab">

[к оглавлению](#многопоточность)

## Что является монитором у нестатического синхронизированного класса?

Объект (this).

В случае нестатического синхронизированного метода память выделяется многократно при каждом вызове метода.

[к оглавлению](#многопоточность)

## Способы управления потоками java.util.сoncurrent

Возможности классов этого пакета обеспечивают высокую производительность, масштабируемость, построение потокобезопасных блоков. 

<img width="974" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/7b512073-c294-48e9-b90f-3a7fdcca6939">

Синхронизированные коллекции достигают потокобезопасности благодаря тому, что используют Lock через synchronized блоки для всех методов. Это значит, что если несколько потоков захотят добавить или удалить элемент в ArrayList, то доступ в коллекцию будет осуществляться через один поток.  
 
Т.е. первый поток заходит, ставит Lock (замок), отрабатывает и только после этого (когда он закончит работу), будет разблокирован доступ для работы второго потока и т.д. 
  
Операция «дорогая», производительность у таких коллекций при многопоточности низкая. 
 
Чтобы обезопасить приложение от вызова исключения ConcurrentModificationException необходимо целиком блокировать коллекцию на время перебора. 
 
Пример слева: выброшено исключение ConcurrentModificationException. 

Пример справа: когда идёт перебор элементов и вывод в консоль, то до тех пор, пока этот поток не отработает, метод remove() не будет вызван, т.е. поток 2 будет ждать окончания работы потока 1 и результат получим правильный (консоль).

<img width="954" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/b40a1cca-63d7-41c3-92df-8bb80adebe3d">

Состав java.util.concurrent  
 
Специально для работы в условиях многопоточности были созданы Concurrent collections:  усовершенствован вызов утилит синхронизации, добавлены классы семафоров и блокировок и т.д. 

<img width="835" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/a7b60fad-7877-4388-84b2-4055dffb3109">
 
Atomics – набор потокобезопасных переменных и массивов. 
 
Механизм управления заданиями, основанный на интерфейсе Executor: 
+ организация запуска пула потоков: ThreadPoolExecutor
+ Эффективная реализация пула ExecutorService – ForkJoinPool 
+ Службы планирования: ScheduledThreadPoolExecutor 
 
Параллельные аналоги классов-коллекций 
+ Блокирующие очереди BlockingQueue и BlockingDeque, гарантирующие остановку потока если нет элемента или нет места для вставки)
+ Класс Exchanger позволяет двум потокам обмениваться объектами.
+ Классы CopyOnArrayList и CopyOnWriteArraySet, копирующие своё содержимое при попытке его изменения, причём ранее полученный итератор будет корректно продолжать работать с исходным набором данных.
+ ConcurrentHashMap, ConcurrentLinkedQueue – эффективные аналоги HashTable и LinkedList. 
 
Классы – барьеры синхронизации (Synchronizers): 
+ CountDownLatch – заставляет потоки ожидать завершения заданного числа операций, по окончании чего все ожидающие потоки освобождаются.
+ Semaphore – предлагают потоку ожидать завершения действий в других потоках.
+ CyclicBarrier – предлагает нескольким потокам ожидать момента, когда они все достигнут какой-либо точки, после чего барьер снимается.
+ Phaser – улучшенная реализация барьера для синхронизации потоков, совмещает в себе функционал CyclicBarrier и CountDownLatch. Количество потоков может динамически изменяться. Класс может пере-использоваться. 
 
Неблокирующие коллекции: 
+ ConcurrentLinkedQueue (LinkedList)
+ ConcurrentLinkedDeque (ArrayDeque)
+ CopyOnWriteArrayList (ArrayList)
+ CopyOnWriteArraySet (HashSet)
+ ConcurrentHashMap (HashMap)
+ ConcurrentScipListMap (TreeMap)
+ ConcurrentScipListSet (TreeSet) 
 
Принципы: 
+ Простые операции атомарны
+ Пакетные операции (addAll, removeAll) могут быть не атомарны!
+ Как правило, длина не хранится (isEmpty() !)
+ Не кидает ConcurrentModificationException 

[к оглавлению](#многопоточность)

## Расскажи про устройство и алгоритм работы ConcurrentHashMap  

В ConcurrentHashMap ключи и значения хранятся внутри сегментов (segments), каждый из которых представляет собой свою небольшую "хеш-таблицу" (hash table), где каждая ячейка является отдельной корзиной (bucket) для хранения пар ключ-значение.

При добавлении новой пары ключ-значение в ConcurrentHashMap, сначала вычисляется хэш-код ключа. Затем, используя этот хэш-код, определяется номер сегмента, в который должна быть добавлена пара. Внутри сегмента затем снова используется хэш-код ключа для определения корзины, в которой будет храниться пара.

Эта двухуровневая схема позволяет распределять нагрузку на несколько небольших и независимых хеш-таблиц, что обеспечивает более эффективную параллельную работу и уменьшает возможность блокировки при доступе к разным сегментам.

Конкретно ReentrantLock используется для защиты сегментов ConcurrentHashMap. ConcurrentHashMap разделяет свои данные на отдельные сегменты, каждый из которых может блокироваться независимо от других при доступе к своим элементам. По умолчанию, ConcurrentHashMap разбивается на 16 сегментов и каждый сегмент защищается с помощью экземпляра ReentrantLock.
 
ConcurrentHashMap создает массив поверх него, и каждый индекс этого массива представляет HashMap.  
 
<img width="1006" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/445e050e-8f82-4184-afda-2905a7ea92c5">

В Java 8 ConcurrentHashMap – это уже древовидная структура вместо связанного списка для дальнейшего повышения производительности. 

<img width="1098" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/006acce5-b4b8-436d-a1ea-50186b8a7bdf">

**Операция чтения, записи и удаления в ConcurrentHashMap**
+ Если посмотреть на приведенную выше диаграмму, становится ясно, что независимо от того, является ли это операцией вставки или чтения, необходимо сначала определить индекс сегмента, в котором предполагается выполнение операции вставки/чтения. 
+ После того, как это идентифицировано, необходимо определить внутреннюю корзину/массив хэш-карты, чтобы найти точную позицию для вставки/чтения. 
+ После определения корзины выполните итерацию по связанному списку, чтобы проверить пару ключ-значение. 
  + В случае вставки, если ключ совпадает, замените значение новым, в противном случае вставьте ключ со значением в конце связанного списка. 
  + В случае чтения везде, где совпадают ключи, извлеките значение и верните это значение, а если нет совпадения, верните ноль. 
  + В случае удаления, если ключ совпадает, удалите ссылку, соответствующую этому ключу. 

<img width="1007" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/995660db-1c08-416f-8fee-be21f7bbd379">

Смотрите рисунок (Hashtable). 

Оба потока блокируют коллекцию целиком и это делает Hashtable неэффективным…  Именно поэтому Java придумала ConcurrentHashMap. 

ConcurrentHashMap работает иначе, чем, HashTable, поскольку ConcurrentHashMap получает блокировку для каждого сегмента отдельно.

Это означает, что вместо блокировки всей карты он имеет несколько блокировок на уровне сегментов. Таким образом, два потока, работающие с разными сегментами, могут получить блокировку этих сегментов, не мешая друг другу, и могут работать одновременно, поскольку они работают с отдельными блокировками сегмента. 

+ Поток T1 вызывает concurrentHashMap.put(key, value), он получает блокировку, скажем, в сегменте 1 и вызывает метод put. 
+ Поток T2 вызывает concurrentHashMap.put(key, value), он получает блокировку, скажем, в сегменте 15 и вызывает метод put, как показано ниже. 

<img width="1144" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/69d5417e-104c-477b-9f6a-bc8101401181">

Именно так ConcurrentHashMap повышает производительность и обеспечивает безопасность потоков. 

**Одновременные операции чтения и записи несколькими потоками в одном или разных сегментах ConcurrentHashMap:**

Операция чтения/получения: два потока T1 и T2 могут одновременно считывать данные из одного и того же или разных сегментов ConcurrentHashMap, не блокируя друг друга.

Операция записи/ввода: два потока T1 и T2 могут одновременно записывать данные в разные сегменты, не блокируя друг друга. 

Но два потока не могут одновременно записывать данные в одни и те же сегменты. Один должен ждать, пока другой завершит операцию. 

Операция чтения-записи: два потока могут одновременно читать и записывать данные в разные сегменты, не блокируя друг друга. Как правило, операции извлечения не блокируются, поэтому могут пересекаться с операциями записи (помещения/удаления). Последнее обновленное значение будет возвращено операцией получения, которая является самым последним обновленным значением операции записи (включая размещение/удаление). 

**Размер сегментов и уровень параллелизма ConcurrentHashMap**

По умолчанию ConcurrentHashMap имеет размер массива сегментов равный 16, поэтому одновременно 16 потоков могут помещать данные в карту, учитывая, что каждый поток работает с отдельным индексом массива сегментов. 

ConcurrentHashMap имеет конструктор с 3 аргументами, который помогает настроить размер массива сегментов, определив concurrencyLevel. 

<img width="871" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/0bc9913c-40fb-4490-88a9-ab8b28d12efe">

<img width="873" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/da32672d-f568-47ef-9965-b64fb8b57b85">

Как показано на диаграмме выше, каждый индекс массива сегментов представляет собой HashMap, а в HashMap бакет/корзина/массив относится к классу Entry[], а в 
ConcurrentHashMap массив относится к классу HashEntry[] (в Java 8 — древовидная структура, а не связанный список). 
 
Размер массива сегментов = 2 в степени x, где результат должен быть ≥ concurrencyLevel (в нашем случае это 10). Размер массива сегментов = 2 ^ 4 = 16 ≥ 10, что означает, что размер массива сегментов должен быть равен 16. 

<img width="848" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/26024373-b3d3-441d-8912-54a3e0b9445e">

В ConcurrentHashMap каждый сегмент повторно хешируется отдельно, поэтому нет конфликта между потоком 1, записывающим в сегмент с индексом 1, и потоком 2, записывающим в сегмент с индексом 4. 

Например, если поток 1 помещает данные в индекс массива Segment [] 3 и обнаруживает, что массив HashEntry [] необходимо повторно хешировать из-за превышения емкости коэффициента загрузки, тогда он будет повторно хешировать массив HashEntry [], присутствующий в индексе массива Segment [] только 3.  

Массив HashEntry[] в других индексах сегмента останется нетронутым и продолжит обслуживать запросы на размещение и получение параллельно. 

<img width="838" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/dc93f82d-27c9-43e5-a45d-2833c7b6e89b">

[к оглавлению](#многопоточность)

## Что знаешь про CopyOnWriteArrayList? 
 
CopyOnWriteArrayList: 
+ volatile массив внутри 
+ lock только при модификации списка, поэтому операции чтения очень быстрые 
+ новая копия массива при модификации 
+ fail-fast итератор 
+ модификация через iterator невозможна: UnsupportedOperationException

<img width="480" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/a8abd638-ca2e-42a1-bb1b-85d37fb295ba">
 
Почему важно, чтобы операции по удалению и вставке элементов были не частыми? 
 
При каждом изменении элементов в данной коллекции, создаётся КЛОН – копия листа нового вида. 
 
Итератор запоминает состояние коллекции на момент итерации и выводит в консоль эти элементы. Что происходит в параллельных потоках уже не важно. 
 
Во втором потоке, когда удалили элемент создалась копия коллекции. 

А затем добавили новый элемент и создалась ещё одна новая копия коллекции. И только после того, как итератор закончил работу, старая копия уже не нужна и теперь итератор работает с самой новой копией данных. 
 
Элементов коллекции может быть много, а операции затратны. Именно поэтому стоит использовать CopyOnWriteArrayList тогда, когда в программе НЕ много операций по изменению элементов, НО много операций чтения. 

<img width="834" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/2feb3f18-51c9-49e7-a614-770e02ec43b5">

Есть еще класс CopyOnWriteArraySet, который работает по схожему сценарию. 
 
**synchronizers**

Объекты синхронизации, позволяющие разработчику управлять и/или ограничивать работу нескольких потоков. Cодержит пять объектов синхронизации: semaphore, countDownLatch, ciclycBarrier, exchanger, phaser. 
 
**CountDownLatch**

объект синхронизации потоков, блокирующий один или несколько потоков до тех пор, пока не будут выполнены определенные условия. Количество условий задается счетчиком. При обнулении счетчика, т.е. при выполнении всех условий, блокировки выполняемых потоков будут сняты, и они продолжат выполнение кода. Одноразовый. 
 
CountDownLatch + Executor (пример кода ниже) 

<img width="807" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/9ea2f5e7-2df3-4bda-bf72-45a0f68afc7b">

**CyclicBarrier**

Барьерная синхронизация останавливает поток в определенном месте в ожидании прихода остальных потоков группы. Как только все потоки достигнут барьера, барьер снимается и выполнение потоков продолжается. Как и CountDownLatch, использует счетчик и похож на него. Отличие: барьер можно использовать повторно (в цикле).

<img width="837" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/589f7ef9-b9fc-4962-9ffa-44684fe69e23">

**Exchanger**
 
Объект синхронизации, используемый для двустороннего обмена данными между двумя потоками. При обмене данными допускается null значения, что позволяет использовать класс для односторонней передачи объекта или же просто, как синхронизатор двух потоков. Обмен данными выполняется вызовом метода exchange(), сопровождаемый самоблокировкой потока.  
 
Как только второй поток вызовет метод exchange, то синхронизатор Exchanger выполнит обмен данными между потоками.  
 
Пример Трегулова: камень, ножницы, бумага (код ниже). 

<img width="418" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/b4e2fa53-4d11-4979-8725-53ef0804e9d5">

**Phaser**
 
Объект синхронизации типа «Барьер», но, в отличие от CyclicBarrier, может иметь несколько барьеров (фаз), и количество участников на каждой фазе может быть разным. 
 
**Atomic**
 
Набор атомарных классов для выполнения атомарных операций. Операция является атомарной, если её можно безопасно выполнять при параллельных вычислениях в нескольких потоках, не используя при этом ни блокировок, ни синхронизацию synchronized. 
 
**Queues**

Cодержит классы формирования неблокирующих и блокирующих очередей для многопоточных приложений. Неблокирующие очереди «заточены» на скорость выполнения, блокирующие очереди приостанавливают потоки при работе с очередью. Работает правило FIFO. 

<img width="837" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/13b78d00-9610-451a-85e4-9a03141f9f3c">

Если попытаемся добавить пятый элемент при capacity = 4, то будет выброшено исключение queue full (очередь заполнена). А если использовать метод offer(), то исключение не будет выброшено, но элемент не добавится. 

<img width="799" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/f3e2805b-58ba-4117-9111-8ff954dd0fd3">

<img width="816" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/5785678c-716d-4c21-a39a-460d567cc6f3">

**Locks**

Механизмы синхронизации потоков, альтернативы базовым synchronized, wait, notify, notifyAll: Lock, Condition, ReadWriteLock. 
 
Lock — базовый интерфейс, предоставляющий более гибкий подход при ограничении доступа к ресурсам/блокам по сравнению с использованием synchronized. Так, при использовании нескольких блокировок, порядок их освобождения может быть произвольный. Имеется возможность перехода к альтернативному сценарию, если блокировка уже захвачена. 

<img width="816" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/5005f794-5943-425f-a712-5cdfd85a3d45">

**Condition** — интерфейсное условие в сочетании с блокировкой Lock позволяет заменить методы монитора/мьютекса (wait, notify и notifyAll) объектом, управляющим ожиданием событий. Объект с условием чаще всего получается из блокировок с использованием метода lock.newCondition(). Таким образом можно получить несколько комплектов wait/notify для одного объекта. Блокировка Lock заменяет использование synchronized, а Condition — объектные методы монитора. 
 
**ReadWriteLock** — интерфейс создания read/write блокировок, который реализует один единственный класс ReentrantReadWriteLock. Блокировку чтение-запись следует использовать при длительных и частых операциях чтения и редких операциях записи. Тогда при доступе к защищенному ресурсу используются разные методы блокировки, как показано ниже: 
```java
ReadWriteLock rwl = new ReentrantReadWriteLock(); 
Lock readLock = rwl.readLock(); 
Lock writeLock = rwl.writeLock(); 
```
**Executors** - включает средства, называемые сервисами исполнения, позволяющие управлять потоковыми задачами с возможностью получения результатов через интерфейсы Future и Callable

<img width="830" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/9e12a685-7f3e-4db7-8f3f-e662dcf985bc">

ExecutorService служит альтернативой классу Thread, предназначенному для управления потоками.  
 
В основу сервиса исполнения положен интерфейс Executor, в котором определен один метод void execute(Runnable thread);  
 
При вызове метода execute исполняется поток thread. 
 
**Интерфейс ExecutorService:**

<img width="809" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/f1261d6b-ff10-46dd-9c91-92f5926e8248">

[к оглавлению](#многопоточность)

## Stream API & ForkJoinPool Как связаны, что это такое. 

В Stream API есть простой способ распараллеливания потока методом parallel() или parallelStream(), чтобы получить выигрыш в производительности на многоядерных машинах. 
По умолчанию parallel stream используют ForkJoinPool.commonPool. Этот пул создается статически и живет пока не будет вызван System::exit. Если задачам не указывать конкретный пул, то они будут исполняться в рамках commonPool. 

По умолчанию, размер пула равен на 1 меньше, чем количество доступных ядер. 

Когда некий тред отправляет задачу в common pool, то пул может использовать вызывающий тред (caller-thread) в качестве исполнителя. ForkJoinPool пытается загрузить своими задачами и вызывающий тред. 

**Сортировка слиянием на FJP (ForkJoinPool)**

<img width="805" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/2a84079e-6d79-468b-9ebe-80f33b1b27c5">

-------------
Stream API и ForkJoinPool - это два разных, но взаимосвязанных компонента в Java, предназначенные для обработки данных параллельно и эффективно. Давайте разберемся, что это такое и как они связаны.

1. **Stream API:**
Stream API представляет собой высокоуровневый инструмент в Java, предназначенный для работы с коллекциями данных. Он позволяет выполнять операции над элементами коллекции в функциональном стиле. Основные преимущества Stream API включают:

   - Декларативный стиль программирования: Выражения на Stream API описывают, что нужно сделать с данными, а не как это делать.
   - Параллельная обработка: Stream API предоставляет возможность легко распараллеливать операции над данными, что может улучшить производительность на многопроцессорных системах.

2. **ForkJoinPool:**
ForkJoinPool - это специализированный пул потоков в Java, предназначенный для эффективного распределения и выполнения задач, которые могут быть разделены на более мелкие подзадачи. ForkJoinPool использует подход "разделяй и властвуй" (divide and conquer) для рекурсивного разделения задач на подзадачи и их параллельного выполнения. Он обычно используется для реализации рекурсивных алгоритмов, которые могут быть легко разбиты на подзадачи.

**Связь между Stream API и ForkJoinPool:**
Когда вы выполняете параллельные операции над Stream с использованием метода `parallel()` или `parallelStream()`, Stream API автоматически использует внутри себя ForkJoinPool для распараллеливания операций. ForkJoinPool разделяет работу на более мелкие задачи и распределяет их между доступными потоками пула.

Важно понимать, что хотя Stream API упрощает параллельную обработку данных, не всегда имеет смысл параллелизовать все операции. Некоторые операции могут быть более эффективными при последовательной обработке из-за накладных расходов на распараллеливание. Поэтому рекомендуется анализировать характер задачи и оптимально выбирать, какие операции следует выполнять параллельно с использованием Stream API и ForkJoinPool.

[к оглавлению](#многопоточность)

## Зачем используются thread local переменные? 

Класс ThreadLocal представляет хранилище тред-локальных переменных. По способу использования он похож на обычную обертку над значением, с методами 
get(), set() и remove() для доступа к нему, и дополнительным фабричным методом ThreadLocal.withInitial(), устанавливающим значение по-умолчанию. 
 
Отличие тред-локальной переменной от обычной в том, что ThreadLocal хранит отдельную независимую копию значения для каждого ее использующего потока.  

**Работа с такой переменной поток- безопасна.**
 
Проще говоря, объект класса ThreadLocal хранит внутри не одно значение, а как бы хэштаблицу поток ➝ значение, и при использовании обращается к значению для текущего потока. 
 
Первый, самый очевидный вариант использования – данные, относящиеся непосредственно к треду, определенный пользователем «контекст потока». На скриншоте ниже пример такого использования: ThreadId.get() вернет порядковый номер текущего треда. 
 
Другой случай, с которым локальная переменная потока может помочь – кэширование read-only данных в многопоточной среде без дорогостоящей синхронизации. 

Помимо обычного ThreadLocal, в стандартной библиотеке присутствует его расширение InheritableThreadLocal. Этот класс «наследует» значение – изначально берет его для потока, являющегося родителем текущего.

<img width="774" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/8bcec30f-e8a7-42a8-849d-4eeb654ad85a">

hreadLocal переменные хранятся в специальной области памяти, называемой ThreadLocalMap, которая является частью каждого потока исполнения (Thread) в JVM. ThreadLocalMap хранится в heap памяти и содержит все ThreadLocal переменные, созданные для данного потока исполнения.

Каждый раз, когда поток исполнения обращается к ThreadLocal переменной, он получает ее значение из своего экземпляра ThreadLocalMap, который хранится в heap, и она возвращается в поток исполнения. Каждый поток исполнения имеет свой собственный экземпляр ThreadLocalMap, что гарантирует, что значения ThreadLocal переменных будут уникальны для каждого потока исполнения.

[к оглавлению](#многопоточность)

## Как реализовать двусторонний обмен данными между потоками? 

Вопрос, который зачастую дается в виде практической задачи. Конечно, результата можно добиться разными способами: парой атомарных переменных, критическими секциями, потокобезопасными коллекциями.  

<img width="336" alt="image" src="https://github.com/Oknel-Vap/Interview_questions/assets/116596752/0b7d41a5-01a5-4d74-b605-3317b3f5fc35">

Но полезно знать, что специально для этого случая в стандартной библиотеке  java.util.concurrent есть простой класс Exchanger. 
 
Класс содержит единственный метод V exchange(V x). Один поток передает в него данные, и встает в ожидание. Ожидание завершается, когда второй поток также приходит в метод exchange со своей порцией информации. В качестве результата вызова потоки получают данные друг друга. 
 
На основе класса Exchanger удобно создавать пайплайны обработки данных. Первый поток выполняет свою часть обработки, и складывает результаты в буфер. В качестве буфера может работать любой многоразовый объект-контейнер. Когда он заполняется, следующий поток обменивает его на второй, пустой буфер. Таким образом два буфера используются поочередно, не выделяется лишний раз память и не нагружается GC. Далее из попарно обменивающихся буферами потоков может строиться длинная многопоточная цепочка обработки. 

[к оглавлению](#многопоточность)

## Какими коллекциями пользоваться в многопоточной среде? 

Первый вариант – превратить в синхронизированную обычную коллекцию, вызвав соответствующий ее типу метод Collections.synchronized*(). Самый общий и самый примитивный способ, создает обертку с синхронизацией всех операций с помощью synchronized. 
 
Если работа с коллекцией состоит в основном из чтения, лучшая в плане производительности альтернатива – CopyOnWriteArrayList, и содержащий его в реализации CopyOnWriteArraySet. Поток безопасность достигается копированием внутреннего массива при любой модификации, оригинальный массив остается immutable. Program order достигается модификатором volatile на внутреннем массиве. 
 
Третий вариант – использование Concurrent-коллекций: 
+ Неблокирующие хэш таблицы ConcurrentSkipListMap, ConcurrentHashMap и ConcurrentSkipListSet (хэш-таблица в основе реализации) 
+ Неблокирующие очереди ConcurrentLinkedQueue и ConcurrentLinkedDeque
+ Большой набор различных блокирующих очередей

[к оглавлению](#многопоточность)
